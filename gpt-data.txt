Directory Structure with Token Counts:

- / - 935 tokens
- __test__/ - 72 tokens
    + custom-test-env.js - 72 tokens
- ai/ - 2411 tokens
    + PoseDetector.ts - 516 tokens
    + RoboflowAPIObjectDetector.ts - 659 tokens
    + SSDObjectDetector.ts - 494 tokens
    + YOLOV5ObjectDetector.ts - 742 tokens
- data/ - 4513 tokens
    + EditorData.ts - 123 tokens
    + ExportFormatData.ts - 339 tokens
    + HotKeyAction.ts - 26 tokens
    + ImportFormatData.ts - 231 tokens
    + ImporterSpecData.ts - 179 tokens
    + MobileDeviceData.ts - 22 tokens
    + RectAnchor.ts - 38 tokens
    - enums/ - 820 tokens
        + AIModel.ts - 49 tokens
        + AcceptedFileType.ts - 37 tokens
        + AnnotationFormatType.ts - 52 tokens
        + ContextType.ts - 49 tokens
        + CustomCursorStyle.ts - 64 tokens
        + Direction.ts - 67 tokens
        + EventType.ts - 69 tokens
        + InferenceServerType.ts - 28 tokens
        + LabelStatus.ts - 34 tokens
        + LabelType.ts - 46 tokens
        + LineAnchorType.ts - 19 tokens
        + Notification.ts - 105 tokens
        + NotificationType.ts - 30 tokens
        + PopupWindowType.ts - 141 tokens
        + ProjectType.ts - 30 tokens
    - info/ - 2376 tokens
        + DropDownMenuData.ts - 702 tokens
        + EditorFeatureData.ts - 267 tokens
        + InferenceServerData.ts - 183 tokens
        + LabelToolkitData.ts - 320 tokens
        + NotificationsData.ts - 650 tokens
        + SocialMediaData.ts - 254 tokens
    - labels/ - 359 tokens
        + COCO.ts - 177 tokens
        + VGG.ts - 182 tokens
- interfaces/ - 118 tokens
    + ILabelFormatData.ts - 36 tokens
    + ILine.ts - 28 tokens
    + IPoint.ts - 14 tokens
    + IRect.ts - 26 tokens
    + ISize.ts - 14 tokens
- logic/ - 45368 tokens
    - __tests__/ - 7799 tokens
        - actions/ - 687 tokens
            + AIActions.test.ts - 173 tokens
            + AIObjectDetectionActions.test.ts - 514 tokens
        - export/ - 3040 tokens
            + RectLabelExport.test.ts - 1302 tokens
            - polygon/ - 1738 tokens
                + COCOExporter.test.ts - 321 tokens
                + VGGExporter.test.ts - 1417 tokens
        - import/ - 4072 tokens
            - coco/ - 353 tokens
                + COCOUtils.tests.ts - 353 tokens
            - voc/ - 1013 tokens
                + VOCImporter.tests.ts - 1013 tokens
            - yolo/ - 2706 tokens
                + YOLOImporter.test.ts - 540 tokens
                + YOLOUtils.test.ts - 2166 tokens
    - actions/ - 10389 tokens
        + AIActions.ts - 909 tokens
        + AIPoseDetectionActions.ts - 1145 tokens
        + AIRoboflowAPIObjectDetectionActions.ts - 917 tokens
        + AISSDObjectDetectionActions.ts - 1014 tokens
        + AIYOLOObjectDetectionActions.ts - 1007 tokens
        + EditorActions.ts - 1372 tokens
        + ImageActions.ts - 1012 tokens
        + LabelActions.ts - 1236 tokens
        + PopupActions.ts - 63 tokens
        + ViewPortActions.ts - 1714 tokens
    - context/ - 2314 tokens
        + BaseContext.ts - 49 tokens
        + ContextManager.ts - 700 tokens
        + EditorContext.ts - 1396 tokens
        + PopupContext.ts - 169 tokens
    - export/ - 5596 tokens
        + LineLabelExport.ts - 446 tokens
        + PointLabelsExport.ts - 424 tokens
        + RectLabelsExporter.ts - 2091 tokens
        + TagLabelsExport.ts - 596 tokens
        - polygon/ - 2039 tokens
            + COCOExporter.ts - 1188 tokens
            + PolygonLabelsExporter.ts - 117 tokens
            + VGGExporter.ts - 734 tokens
    - helpers/ - 614 tokens
        + CSSHelper.ts - 90 tokens
        + ViewPortHelper.ts - 524 tokens
    - imageRepository/ - 322 tokens
        + ImageLoadManager.ts - 187 tokens
        + ImageRepository.ts - 135 tokens
    - import/ - 4760 tokens
        + AnnotationImporter.ts - 138 tokens
        - coco/ - 1620 tokens
            + COCOErrors.ts - 215 tokens
            + COCOImporter.ts - 1227 tokens
            + COCOUtils.ts - 178 tokens
        - voc/ - 1035 tokens
            + VOCImporter.ts - 1035 tokens
        - yolo/ - 1967 tokens
            + YOLOErrors.ts - 234 tokens
            + YOLOImporter.ts - 950 tokens
            + YOLOUtils.ts - 783 tokens
    - initializer/ - 478 tokens
        + AppInitializer.ts - 478 tokens
    - render/ - 13096 tokens
        + BaseRenderEngine.ts - 480 tokens
        + LineRenderEngine.ts - 2645 tokens
        + PointRenderEngine.ts - 1940 tokens
        + PolygonRenderEngine.ts - 3980 tokens
        + PrimaryEditorRenderEngine.ts - 787 tokens
        + RectRenderEngine.ts - 3264 tokens
- settings/ - 1172 tokens
    + RenderEngineSettings.ts - 334 tokens
    + Settings.ts - 758 tokens
    + ViewPointSettings.ts - 80 tokens
- staticModels/ - 337 tokens
    + EditorModel.ts - 281 tokens
    + PlatformModel.ts - 56 tokens
- store/ - 6710 tokens
    + Actions.ts - 464 tokens
    + index.ts - 91 tokens
    - ai/ - 1260 tokens
        + actionCreators.ts - 377 tokens
        + reducer.ts - 411 tokens
        + types.ts - 472 tokens
    - general/ - 1552 tokens
        + actionCreators.ts - 498 tokens
        + reducer.ts - 494 tokens
        + types.ts - 560 tokens
    - labels/ - 1687 tokens
        + actionCreators.ts - 451 tokens
        + reducer.ts - 456 tokens
        + types.ts - 780 tokens
    - notifications/ - 416 tokens
        + actionCreators.ts - 98 tokens
        + reducer.ts - 184 tokens
        + types.ts - 134 tokens
    - selectors/ - 1240 tokens
        + AISelector.ts - 293 tokens
        + GeneralSelector.ts - 300 tokens
        + LabelsSelector.ts - 647 tokens
- utils/ - 14179 tokens
    + ArrayUtil.ts - 494 tokens
    + CanvasUtil.ts - 261 tokens
    + DirectionUtil.ts - 226 tokens
    + DrawUtil.ts - 1207 tokens
    + EditorUtil.ts - 306 tokens
    + EnvironmentUtil.ts - 46 tokens
    + ExporterUtil.ts - 163 tokens
    + FileUtil.ts - 499 tokens
    + ImageDataUtil.ts - 405 tokens
    + ImageUtil.ts - 58 tokens
    + LabelUtil.ts - 444 tokens
    + LineUtil.ts - 244 tokens
    + MouseEventUtil.ts - 93 tokens
    + NotificationUtil.ts - 203 tokens
    + NumberUtil.ts - 87 tokens
    + PlatformUtil.ts - 161 tokens
    + PointUtil.ts - 191 tokens
    + PolygonUtil.ts - 122 tokens
    + RectUtil.ts - 1447 tokens
    + RenderEngineUtil.ts - 1359 tokens
    + SizeUtil.ts - 57 tokens
    + UnitUtil.ts - 52 tokens
    + VirtualListUtil.ts - 379 tokens
    + XMLSanitizerUtil.ts - 69 tokens
    - __tests__/ - 5606 tokens
        + ArrayUtil.test.ts - 852 tokens
        + DrawUtil.test.ts - 235 tokens
        + FileUtil.test.ts - 358 tokens
        + ImageDataUtil.test.ts - 525 tokens
        + LabelUtil.test.ts - 563 tokens
        + LineUtil.test.ts - 789 tokens
        + NumberUtil.test.ts - 171 tokens
        + RectUtil.test.ts - 359 tokens
        + RenderEngineUtil.test.ts - 1754 tokens
- views/ - 40455 tokens
    - Common/ - 2365 tokens
        - ImageButton/ - 436 tokens
            + ImageButton.tsx - 436 tokens
        - StyledTextField/ - 150 tokens
            + StyledTextField.tsx - 150 tokens
        - TextButton/ - 218 tokens
            + TextButton.tsx - 218 tokens
        - TextInput/ - 288 tokens
            + TextInput.tsx - 288 tokens
        - UnderlineTextButton/ - 182 tokens
            + UnderlineTextButton.tsx - 182 tokens
        - VirtualList/ - 1091 tokens
            + VirtualList.tsx - 1091 tokens
    - EditorView/ - 19264 tokens
        + EditorView.tsx - 209 tokens
        - Editor/ - 2260 tokens
            + Editor.tsx - 2260 tokens
        - EditorBottomNavigationBar/ - 476 tokens
            + EditorBottomNavigationBar.tsx - 476 tokens
        - EditorContainer/ - 1101 tokens
            + EditorContainer.tsx - 1101 tokens
        - EditorTopNavigationBar/ - 1466 tokens
            + EditorTopNavigationBar.tsx - 1466 tokens
        - FeatureInProgress/ - 89 tokens
            + FeatureInProgress.tsx - 89 tokens
        - LabelControlPanel/ - 967 tokens
            + LabelControlPanel.tsx - 967 tokens
        - SideNavigationBar/ - 10288 tokens
            + SideNavigationBar.tsx - 227 tokens
            - EmptyLabelList/ - 243 tokens
                + EmptyLabelList.tsx - 243 tokens
            - ImagePreview/ - 1211 tokens
                + ImagePreview.tsx - 1211 tokens
            - ImagesList/ - 838 tokens
                + ImagesList.tsx - 838 tokens
            - LabelInputField/ - 1623 tokens
                + LabelInputField.tsx - 1623 tokens
            - LabelsToolkit/ - 1415 tokens
                + LabelsToolkit.tsx - 1415 tokens
            - LineLabelsList/ - 947 tokens
                + LineLabelsList.tsx - 947 tokens
            - PointLabelsList/ - 1001 tokens
                + PointLabelsList.tsx - 1001 tokens
            - PolygonLabelsList/ - 949 tokens
                + PolygonLabelsList.tsx - 949 tokens
            - RectLabelsList/ - 1023 tokens
                + RectLabelsList.tsx - 1023 tokens
            - TagLabelsList/ - 811 tokens
                + TagLabelsList.tsx - 811 tokens
        - StateBar/ - 577 tokens
            + StateBar.tsx - 577 tokens
        - TopNavigationBar/ - 1612 tokens
            + TopNavigationBar.tsx - 594 tokens
            - DropDownMenu/ - 1018 tokens
                + DropDownMenu.tsx - 1018 tokens
        - VerticalEditorButton/ - 219 tokens
            + VerticalEditorButton.tsx - 219 tokens
    - MainView/ - 1788 tokens
        + MainView.tsx - 886 tokens
        - ImagesDropZone/ - 902 tokens
            + ImagesDropZone.tsx - 902 tokens
    - MobileMainView/ - 904 tokens
        + MobileMainView.tsx - 904 tokens
    - NotificationsView/ - 634 tokens
        + NotificationsView.tsx - 634 tokens
    - PopupView/ - 15369 tokens
        + PopupView.tsx - 612 tokens
        - ConnectInferenceServerPopup/ - 1579 tokens
            + ConnectInferenceServerPopup.tsx - 1579 tokens
        - ExitProjectPopup/ - 616 tokens
            + ExitProjectPopup.tsx - 616 tokens
        - ExportLabelsPopup/ - 803 tokens
            + ExportLabelPopup.tsx - 803 tokens
        - GenericLabelTypePopup/ - 622 tokens
            + GenericLabelTypePopup.tsx - 622 tokens
        - GenericSideMenuPopup/ - 280 tokens
            + GenericSideMenuPopup.tsx - 280 tokens
        - GenericYesNoPopup/ - 401 tokens
            + GenericYesNoPopup.tsx - 401 tokens
        - ImportLabelPopup/ - 1700 tokens
            + ImportLabelPopup.tsx - 1700 tokens
        - InsertLabelNamesPopup/ - 2255 tokens
            + InsertLabelNamesPopup.tsx - 2148 tokens
            - ColorSelectorView/ - 107 tokens
                + ColorSelectorView.tsx - 107 tokens
        - LoadLabelNamesPopup/ - 1115 tokens
            + LoadLabelNamesPopup.tsx - 1115 tokens
        - LoadModelPopup/ - 1108 tokens
            + LoadModelPopup.tsx - 1108 tokens
        - LoadMoreImagesPopup/ - 630 tokens
            + LoadMoreImagesPopup.tsx - 630 tokens
        - LoadYOLOv5ModelPopup/ - 2259 tokens
            + LoadYOLOv5ModelPopup.tsx - 2259 tokens
        - SuggestLabelNamesPopup/ - 1389 tokens
            + SuggestLabelNamesPopup.tsx - 1389 tokens
    - SizeItUpView/ - 131 tokens
        + SizeItUpView.tsx - 131 tokens


--- All Code Content ---
Path: README.md
```md
[![Github Stars](https://img.shields.io/badge/stars-nominate-brightgreen?logo=github)](https://stars.github.com/nominate/)
![GitHub release (latest by date including pre-releases)](https://img.shields.io/github/v/release/SkalskiP/make-sense?include_prereleases)
[![codecov](https://codecov.io/gh/SkalskiP/make-sense/branch/develop/graph/badge.svg?token=lWsADbAey2)](https://codecov.io/gh/SkalskiP/make-sense)
[![Gitter](https://badges.aleen42.com/src/gitter.svg)](https://gitter.im/make-sense-ai/community)
[![Discord](https://badges.aleen42.com/src/discord.svg)](https://discord.gg/ASCjCrNdA7)

<h1 align="center">makesense.ai</h1>

<p align="center">
    </br>
    <img width="100" src=".//public/favicon.png" alt="make sense logo">
    </br>
</p>

[makesense.ai][1] is a free-to-use online tool for labeling photos. Thanks to the use of a browser it does not require any complicated installation - just visit the website and you are ready to go. It also doesn't matter which operating system you're running on - we do our best to be truly cross-platform. It is perfect for small computer vision deep learning projects, making the process of preparing a dataset much easier and faster. Prepared labels can be downloaded in one of the multiple supported formats. The application was written in TypeScript and is based on React/Redux duo.

## üìÑ Documentation

You can find out more about our tool from the newly released [documentation][14] - still under üöß construction. Let us know what topics we should cover first.

## ü§ñ Advanced AI integrations

[makesense.ai][1] strives to significantly reduce the time you have to spend on photo labeling. We are doing our best to integrate the latest and greatest AI models, that can give you recommendations as well as automate repetitive and tedious activities.

* [YOLOv5][16] is our most powerful integration yet. Thanks to the use of [yolov5js][17] you can load not only pretrained models from [yolov5js-zoo](18), but above all your own models trained thanks to YOLOv5 and [exported](19) to tfjs format.
* [SSD][8] pretrained on the [COCO dataset][9], which will do some of the work for you in drawing bounding boxes on photos and also (in some cases) suggest a label.
* [PoseNet][11] is a vision model that can be used to estimate the pose of a person in an image or video by estimating where key body joints are.

The engine that drives our AI functionalities is [TensorFlow.js][10] - JS version of the most popular framework for training neural networks. This choice allows us not only to speed up your work but also to care about the privacy of your data, because unlike with other commercial and open-source tools, your photos do not have to be transferred to the server. This time AI comes to your device!

https://user-images.githubusercontent.com/26109316/193255987-2d01c549-48c3-41ae-87e9-e1b378968966.mov

## üíª Local Setup

```bash
# clone repository
git clone https://github.com/SkalskiP/make-sense.git

# navigate to main dir
cd make-sense

# install dependencies
npm install

# serve with hot reload at localhost:3000
npm start
```
To ensure proper functionality of the application locally, npm `8.x.x` and node.js `v16.x.x` versions are required. More information about this problem is available in the [#16][4].

## üê≥ Docker Setup

```bash
# Build Docker Image
docker build -t make-sense -f docker/Dockerfile .

# Run Docker Image as Service
docker run -dit -p 3000:3000 --restart=always --name=make-sense make-sense

# Get Docker Container Logs
docker logs make-sense

# Access make-sense: http://localhost:3000/
```

## ‚å®Ô∏è Keyboard Shortcuts

| Functionality                      | Context  | Mac | Windows / Linux  |
|:-----------------------------------|:--------:|:---:|:----------------:|
| Polygon autocomplete               | Editor   | <kbd>Enter</kbd> | <kbd>Enter</kbd> |
| Cancel polygon drawing             | Editor   | <kbd>Escape</kbd> | <kbd>Escape</kbd> |
| Delete currently selected label    | Editor   | <kbd>Backspace</kbd> | <kbd>Delete</kbd> |
| Load previous image                | Editor   | <kbd>‚å•</kbd> + <kbd>Left</kbd> | <kbd>Ctrl</kbd> + <kbd>Left</kbd> |
| Load next image                    | Editor   | <kbd>‚å•</kbd> + <kbd>Right</kbd> | <kbd>Ctrl</kbd> + <kbd>Right</kbd> |
| Zoom in                            | Editor   | <kbd>‚å•</kbd> + <kbd>+</kbd> | <kbd>Ctrl</kbd> + <kbd>+</kbd> |
| Zoom out                           | Editor   | <kbd>‚å•</kbd> + <kbd>-</kbd> | <kbd>Ctrl</kbd> + <kbd>-</kbd> |
| Move image                         | Editor   | <kbd>Up</kbd> / <kbd>Down</kbd> / <kbd>Left</kbd> / <kbd>Right</kbd> | <kbd>Up</kbd> / <kbd>Down</kbd> / <kbd>Left</kbd> / <kbd>Right</kbd> |
| Select Label                       | Editor   | <kbd>‚å•</kbd> + <kbd>0-9</kbd> | <kbd>Ctrl</kbd> + <kbd>0-9</kbd> |
| Exit popup                         | Popup    | <kbd>Escape</kbd> | <kbd>Escape</kbd> |

**Table 1.** Supported keyboard shortcuts

## ‚¨ÜÔ∏è Export Formats

|               | CSV | YOLO | VOC XML | VGG JSON | COCO JSON | PIXEL MASK |
|:-------------:|:---:|:----:|:-------:|:--------:|:---------:|:----------:|
| **Point**     | ‚úì   | ‚úó    | ‚òê       | ‚òê        | ‚òê         | ‚úó          |
| **Line**      | ‚úì   | ‚úó    | ‚úó       | ‚úó        | ‚úó         | ‚úó          |
| **Rect**      | ‚úì   | ‚úì    | ‚úì       | ‚òê        | ‚òê         | ‚úó          |
| **Polygon**   | ‚òê   | ‚úó    | ‚òê       | ‚úì        | ‚úì         | ‚òê          |
| **Label**     | ‚úì   | ‚úó    | ‚úó       | ‚úó        | ‚úó         | ‚úó          |

**Table 2.** The matrix of supported labels export formats, where:
* ‚úì - supported format
* ‚òê - not yet supported format
* ‚úó - format does not make sense for a given label type

You can find examples of export files along with a description and schema on our [Wiki][7].

## ‚¨áÔ∏è Import Formats

|               | CSV | YOLO | VOC XML | VGG JSON | COCO JSON | PIXEL MASK |
|:-------------:|:---:|:----:|:-------:|:--------:|:---------:|:----------:|
| **Point**     | ‚òê   | ‚úó    | ‚òê       | ‚òê        | ‚òê         | ‚úó          |
| **Line**      | ‚òê   | ‚úó    | ‚úó       | ‚úó        | ‚úó         | ‚úó          |
| **Rect**      | ‚òê   | ‚úì    | ‚úì       | ‚òê        | ‚úì         | ‚úó          |
| **Polygon**   | ‚òê   | ‚úó    | ‚òê       | ‚òê        | ‚úì         | ‚òê          |
| **Label**     | ‚òê   | ‚úó    | ‚úó       | ‚úó        | ‚úó         | ‚úó          |

**Table 3.** The matrix of supported labels import formats
* ‚úì - supported format
* ‚òê - not yet supported format
* ‚úó - format does not make sense for a given label type

## üîê Privacy

We don't store your images, because we don't send them anywhere in the first place.

## üöÄ Tutorials

If you are just starting your adventure with deep learning and would like to learn and create something cool along the way, [makesense.ai][1] can help you with that. Leverage our bounding box labeling functionality to prepare a data set and use it to train your first state-of-the-art object detection model. Follow [instructions][12] and [examples][13] but most importantly, free your creativity.


## üèÜ Contribution

<p align="center">
    <a href="https://github.com/SkalskiP/make-sense/graphs/contributors">
      <img src="https://contrib.rocks/image?repo=SkalskiP/make-sense" />
    </a>
</p>

## üí¨ Citation

Please cite Make Sense in your publications if this is useful for your research. Here is an example BibTeX entry:

```BibTeX
@MISC{make-sense,
   author = {Piotr Skalski},
   title = {{Make Sense}},
   howpublished = "\url{https://github.com/SkalskiP/make-sense/}",
   year = {2019},
}
```

## ü™ß License

This project is licensed under the GPL-3.0 License - see the [LICENSE][2] file for details. Copyright &copy; 2019 Piotr Skalski.

[1]: http://makesense.ai
[2]: ./LICENSE
[3]: https://twitter.com/PiotrSkalski92
[4]: https://github.com/SkalskiP/make-sense/issues/16
[5]: https://gitter.im/make-sense-ai/community?utm_source=share-link&utm_medium=link&utm_campaign=share-link
[6]: https://github.com/SkalskiP/make-sense/wiki/Road-Map
[7]: https://github.com/SkalskiP/make-sense/wiki/Supported-Output-Formats
[8]: https://arxiv.org/abs/1512.02325
[9]: http://cocodataset.org
[10]: https://www.tensorflow.org/js
[11]: https://www.tensorflow.org/lite/models/pose_estimation/overview
[12]: https://towardsdatascience.com/chess-rolls-or-basketball-lets-create-a-custom-object-detection-model-ef53028eac7d
[13]: https://github.com/SkalskiP/ILearnDeepLearning.py/tree/master/02_data_science_toolkit/02_yolo_object_detection
[14]: https://skalskip.github.io/make-sense/
[15]: https://github.com/SkalskiP/make-sense/issues
[16]: https://github.com/ultralytics/yolov5
[17]: https://github.com/SkalskiP/yolov5js
[18]: https://github.com/SkalskiP/yolov5js-zoo
[19]: https://github.com/ultralytics/yolov5/blob/master/export.py
```


Path: docker/Dockerfile
```dockerfile
FROM node:16.16.0

RUN apt-get update && apt-get -y install git && rm -rf /var/lib/apt/lists/*

COPY ./ /make-sense

RUN cd /make-sense && \
  npm install

WORKDIR /make-sense

ENTRYPOINT ["npm", "run", "dev"]
```

Path: jest.config.ts
```ts
import type { Config } from '@jest/types';

// Sync object
const config: Config.InitialOptions = {
  rootDir: process.cwd(),
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx'],
  transformIgnorePatterns: [],
  testEnvironment: 'jsdom',
  roots: ["<rootDir>/src"],
  setupFilesAfterEnv: ["<rootDir>/src/configureTest.ts"],
  transform: {
    "^.+(t|j)sx?$": [
      "@swc/jest",
      {
        jsc: {
          transform: {
            react: {
              runtime: 'automatic',
            },
          },
        },
      },
    ],
  },
  "moduleNameMapper": {
    "\\.(css|scss|less)$": "identity-obj-proxy"
  },
  extensionsToTreatAsEsm: [".ts", ".tsx"],
  collectCoverageFrom: [
    "**/*.{ts,tsx}",
    "!**/node_modules/**",
    "!**/dist/**",
    "!**/coverage/**",
  ],
};
export default config;
```


Path: vite.config.ts
```ts
import {
  defineConfig,
  loadEnv,
  UserConfig,
  UserConfigExport,
} from 'vite';

import react from '@vitejs/plugin-react';

export default ({ mode }: UserConfig): UserConfigExport => {
  process.env = { ...process.env, ...loadEnv(mode || 'development', process.cwd()) };
  return defineConfig({
    plugins: [react()],
    build: {
      minify: 'terser',
      sourcemap: mode === 'development',
      chunkSizeWarningLimit: 1024 * 1024,
      rollupOptions: {
        treeshake: true,
        maxParallelFileReads: 4,
        output: {
          manualChunks: {
            lodash: ['lodash'],
            classnames: ['classnames'],
            runtime: ['react', 'react-is'],
            'runtime-dom': ['react-dom'],

            ai: ['@tensorflow/tfjs',
              '@tensorflow/tfjs-backend-cpu',
              '@tensorflow/tfjs-backend-webgl',
              '@tensorflow/tfjs-core',
              '@tensorflow/tfjs-node'],
            models: [
              '@tensorflow-models/coco-ssd',
              '@tensorflow-models/posenet',
            ],
            ui: ['@mui/material', '@mui/system'],
            moment: ['moment']

          },
        },
      },
    },
    esbuild: {
      logOverride: { 'this-is-undefined-in-esm': 'silent' }
    },
    css: {
      modules: {
        generateScopedName: mode === 'development' ? '[name]__[local]___[hash:base64:5]' : '[hash:base64:8]',
        scopeBehaviour: 'local',
        localsConvention: 'camelCase',
      },
      postcss: {
        plugins: [
          {
            postcssPlugin: 'internal:charset-removal',
            AtRule: {
              charset: (atRule) => {
                if (atRule.name === 'charset') {
                  atRule.remove();
                }
              },
            },
          },
        ],
      },
    },
  });
};
```


Path: package.json
```json
{
  "name": "make-sense",
  "version": "1.11.0-alpha",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.9.3",
    "@emotion/styled": "^11.9.3",
    "@mui/material": "^5.9.1",
    "@mui/system": "^5.9.1",
    "@tensorflow-models/coco-ssd": "^2.2.2",
    "@tensorflow-models/posenet": "^2.2.2",
    "@tensorflow/tfjs": "^3.19.0",
    "@tensorflow/tfjs-backend-cpu": "^3.19.0",
    "@tensorflow/tfjs-backend-webgl": "^3.19.0",
    "@tensorflow/tfjs-core": "^3.19.0",
    "@tensorflow/tfjs-node": "^3.19.0",
    "axios": "^1.1.3",
    "classnames": "^2.3.1",
    "file-saver": "^2.0.5",
    "jszip": "^3.10.0",
    "lodash": "^4.17.21",
    "mobile-detect": "^1.4.5",
    "moment": "^2.29.4",
    "react": "18.2.0",
    "react-custom-scrollbars-2": "^4.5.0",
    "react-dom": "18.2.0",
    "react-dropzone": "^14.2.2",
    "react-redux": "^8.0.2",
    "react-spinners": "^0.13.3",
    "redux": "^4.2.0",
    "uuid": "^8.3.2",
    "yolov5js": "^1.0.0"
  },
  "scripts": {
    "dev": "vite --host --port 3000",
    "start": "vite --port 3000",
    "build": "vite build",
    "preview": "vite preview --host --port 3000",
    "test": "jest",
    "test:coverage": "jest --coverage",
    "lint": "eslint src/**/*.ts src/**.tsx"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@redux-devtools/core": "^3.13.1",
    "@swc/core": "^1.2.218",
    "@swc/jest": "^0.2.22",
    "@testing-library/jest-dom": "^5.16.4",
    "@testing-library/react": "^13.3.0",
    "@testing-library/user-event": "^14.3.0",
    "@types/file-saver": "^2.0.5",
    "@types/jest": "^28.1.6",
    "@types/lodash": "^4.14.182",
    "@types/node": "18.0.6",
    "@types/react": "18.0.15",
    "@types/react-custom-scrollbars": "^4.0.10",
    "@types/react-dom": "18.0.6",
    "@types/react-redux": "^7.1.24",
    "@types/uuid": "^8.3.4",
    "@typescript-eslint/eslint-plugin": "^5.30.7",
    "@typescript-eslint/parser": "^5.30.7",
    "@vitejs/plugin-react": "^2.0.0",
    "aws-sdk": "^2.1181.0",
    "eslint": "^8.20.0",
    "eslint-plugin-react": "^7.30.1",
    "identity-obj-proxy": "^3.0.0",
    "jest": "^28.1.3",
    "jest-environment-jsdom": "^28.1.3",
    "mock-aws-s3": "^4.0.2",
    "nock": "^13.2.9",
    "prettier": "^2.7.1",
    "sass": "^1.54.0",
    "terser": "^5.14.2",
    "ts-jest": "^28.0.7",
    "ts-node": "^10.9.1",
    "tslint": "^6.1.3",
    "tslint-react": "^5.0.0",
    "typescript": "4.7.4",
    "vite": "^3.0.2",
    "vite-tsconfig-paths": "^3.5.0"
  }
}
```


Path: index.html
```html
<!DOCTYPE html>
<html lang="en">
  <head>

    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-155837750-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-155837750-1');
    </script>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
              new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
            j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
            'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5N6WR7G');</script>

    <meta charset="utf-8" />

    <link rel="shortcut icon" href="/make-sense-ico.png" />
    <link href="https://fonts.googleapis.com/css?family=Saira+Semi+Condensed&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta name="theme-color" content="#171717" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="/manifest.json" />
    <title>Make Sense</title>
  </head>
  <body>
    <style>
      body {
        background-color: #171717;
      }
    </style>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <noscript>
      <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5N6WR7G" height="0" width="0" style="display:none;visibility:hidden"></iframe>
    </noscript>
    <div id="root"></div>
    <script type="module" src="/src/index.tsx"></script>
  </body>
</html>
```





Path: src/App.tsx
```tsx
import React from 'react';
import './App.scss';
import EditorView from './views/EditorView/EditorView';
import MainView from './views/MainView/MainView';
import {ProjectType} from './data/enums/ProjectType';
import {AppState} from './store';
import {connect} from 'react-redux';
import PopupView from './views/PopupView/PopupView';
import MobileMainView from './views/MobileMainView/MobileMainView';
import {ISize} from './interfaces/ISize';
import {Settings} from './settings/Settings';
import {SizeItUpView} from './views/SizeItUpView/SizeItUpView';
import {PlatformModel} from './staticModels/PlatformModel';
import classNames from 'classnames';
import NotificationsView from './views/NotificationsView/NotificationsView';
import { RoboflowAPIDetails } from './store/ai/types';

interface IProps {
    projectType: ProjectType;
    windowSize: ISize;
    isObjectDetectorLoaded: boolean;
    isPoseDetectionLoaded: boolean;
    isYOLOV5ObjectDetectorLoaded: boolean;
    roboflowAPIDetails: RoboflowAPIDetails;
}

const App: React.FC<IProps> = (
    {
        projectType,
        windowSize,
        isObjectDetectorLoaded,
        isPoseDetectionLoaded,
        isYOLOV5ObjectDetectorLoaded,
        roboflowAPIDetails
    }
) => {
    const selectRoute = () => {
        if (!!PlatformModel.mobileDeviceData.manufacturer && !!PlatformModel.mobileDeviceData.os)
            return <MobileMainView/>;
        if (!projectType)
            return <MainView/>;
        else {
            if (windowSize.height < Settings.EDITOR_MIN_HEIGHT || windowSize.width < Settings.EDITOR_MIN_WIDTH) {
                return <SizeItUpView/>;
            } else {
                return <EditorView/>;
            }
        }
    };
    const isAILoaded = isObjectDetectorLoaded
        || isPoseDetectionLoaded
        || isYOLOV5ObjectDetectorLoaded
        || (roboflowAPIDetails.model !== '' && roboflowAPIDetails.key !== '' && roboflowAPIDetails.status)

    return (
        <div className={classNames('App', {'AI': isAILoaded})} draggable={false}
        >
            {selectRoute()}
            <PopupView/>
            <NotificationsView/>
        </div>
    );
};


const mapStateToProps = (state: AppState) => ({
    projectType: state.general.projectData.type,
    windowSize: state.general.windowSize,
    isSSDObjectDetectorLoaded: state.ai.isSSDObjectDetectorLoaded,
    isPoseDetectorLoaded: state.ai.isPoseDetectorLoaded,
    isYOLOV5ObjectDetectorLoaded: state.ai.isYOLOV5ObjectDetectorLoaded,
    roboflowAPIDetails: state.ai.roboflowAPIDetails
});

export default connect(
    mapStateToProps
)(App);

```

Path: src/configureStore.ts
```ts
import { createStore } from 'redux';
import { rootReducer } from './store';

export default function configureStore() {
    return createStore(
        rootReducer,
        // @ts-ignore
        window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
    );
}
```

Path: src/configureTest.ts
```ts
import "@testing-library/jest-dom";
import crypto from 'crypto';

jest.mock("./App.tsx", () => "App");


Object.defineProperty(global.self, 'crypto', {
  value: {
    getRandomValues: arr => crypto.randomBytes(arr.length)
  }
});

import { unmountComponentAtNode } from "react-dom";

let container = null;
beforeEach(() => {
  // setup a DOM element as a render target
  container = document.createElement("div");
  container.setAttribute("id", "root");
  document.body.appendChild(container);
});

afterEach(() => {
  // cleanup on exiting
  unmountComponentAtNode(container);
  container.remove();
  container = null;
});
```

Path: src/index.tsx
```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.scss';
import App from './App';
import configureStore from './configureStore';
import { Provider } from 'react-redux';
import { AppInitializer } from './logic/initializer/AppInitializer';

export const store = configureStore();
AppInitializer.inti();

const root = ReactDOM.createRoot(document.getElementById('root') || document.createElement('div'));
root.render(
    <React.StrictMode>
        <Provider store={store}>
            <App />
        </Provider>
    </React.StrictMode>
);


```

Path: src/settings/RenderEngineSettings.ts
```ts
import { ISize } from "../interfaces/ISize";
import { Settings } from "./Settings";

export class RenderEngineSettings {
  public static readonly LINE_THICKNESS: number = 2;
  public static readonly lineActiveColor: string = Settings.PRIMARY_COLOR;
  public static readonly defaultLineColor: string = "#ffffff";
  public static readonly CROSS_HAIR_LINE_COLOR: string = "#ffffff";
  public static readonly crossHairPadding: number = 25;
  public static readonly anchorSize: ISize = {
    width: Settings.RESIZE_HANDLE_DIMENSION_PX,
    height: Settings.RESIZE_HANDLE_DIMENSION_PX,
  };
  public static readonly anchorHoverSize: ISize = {
    width: Settings.RESIZE_HANDLE_HOVER_DIMENSION_PX,
    height: Settings.RESIZE_HANDLE_HOVER_DIMENSION_PX,
  };
  public static readonly suggestedAnchorDetectionSize: ISize = {
    width: 100,
    height: 100,
  };
  public static readonly defaultAnchorColor: string = "#f0f";
  public static readonly inactiveAnchorColor: string =
    Settings.DARK_THEME_SECOND_COLOR;

  public static readonly DEFAULT_ANCHOR_COLOR: string = "#f0f";
  public static readonly ACTIVE_ANCHOR_COLOR: string = Settings.SECONDARY_COLOR;
  public static readonly INACTIVE_ANCHOR_COLOR: string =
    Settings.DARK_THEME_SECOND_COLOR;

  public static readonly DEFAULT_LINE_COLOR: string = "#bbbbbb";
  public static readonly ACTIVE_LINE_COLOR: string = Settings.PRIMARY_COLOR;
  public static readonly INACTIVE_LINE_COLOR: string = "#ffffff";
}

```

Path: src/settings/Settings.ts
```ts
import {PopupWindowType} from '../data/enums/PopupWindowType';

export class Settings {
    public static readonly GITHUB_URL: string = 'https://github.com/SkalskiP';
    public static readonly MEDIUM_URL: string = 'https://medium.com/@piotr.skalski92';
    public static readonly TWITCH_URL: string = 'https://www.twitch.tv/skalskip';
    public static readonly YOUTUBE_URL: string = 'https://www.youtube.com/watch?v=AWjKfjDGiYE';

    public static readonly TOP_NAVIGATION_BAR_HEIGHT_PX: number = 35;
    public static readonly EDITOR_BOTTOM_NAVIGATION_BAR_HEIGHT_PX: number = 40 + 1;
    public static readonly EDITOR_TOP_NAVIGATION_BAR_HEIGHT_PX: number = 40 + 1;
    public static readonly SIDE_NAVIGATION_BAR_WIDTH_CLOSED_PX: number = 23 + 1;
    public static readonly SIDE_NAVIGATION_BAR_WIDTH_OPEN_PX: number = Settings.SIDE_NAVIGATION_BAR_WIDTH_CLOSED_PX + 300 + 1;
    public static readonly TOOLKIT_TAB_HEIGHT_PX: number = 40;
    public static readonly TOOLBOX_PANEL_WIDTH_PX: number = 50 + 1;
    public static readonly MAX_DROPDOWN_OPTION_LENGTH: number = 20;

    public static readonly EDITOR_MIN_WIDTH: number = 900;
    public static readonly EDITOR_MIN_HEIGHT: number = 500;

    public static readonly PRIMARY_COLOR: string = '#2af598';
    public static readonly SECONDARY_COLOR: string = '#009efd';

    public static readonly DARK_THEME_FIRST_COLOR: string = '#171717';
    public static readonly DARK_THEME_SECOND_COLOR: string = '#282828';
    public static readonly DARK_THEME_THIRD_COLOR: string = '#4c4c4c';
    public static readonly DARK_THEME_FORTH_COLOR: string = '#262c2f';

    public static readonly CROSS_HAIR_THICKNESS_PX: number = 1;
    public static readonly CROSS_HAIR_COLOR: string = '#fff';

    public static readonly RESIZE_HANDLE_DIMENSION_PX: number = 8;
    public static readonly RESIZE_HANDLE_HOVER_DIMENSION_PX = 16;

    public static readonly CLOSEABLE_POPUPS: PopupWindowType[] = [
        PopupWindowType.IMPORT_IMAGES,
        PopupWindowType.EXPORT_ANNOTATIONS,
        PopupWindowType.IMPORT_ANNOTATIONS,
        PopupWindowType.EXIT_PROJECT,
        PopupWindowType.UPDATE_LABEL,
        PopupWindowType.LOAD_AI_MODEL,
        PopupWindowType.LOAD_YOLO_V5_MODEL
    ];

    public static readonly LABEL_COLORS_PALETTE = [
        '#ff3838',
        '#ff9d97',
        '#ff701f',
        '#ffb21d',
        '#cff231',
        '#48f90a',
        '#92cc17',
        '#3ddb86',
        '#1a9334',
        '#00d4bb',
        '#2c99a8',
        '#00c2ff',
        '#344593',
        '#6473ff',
        '#0018ec',
        '#8438ff',
        '#520085',
        '#cb38ff',
        '#ff95c8',
        '#ff37c7'
    ];

    public static readonly CSV_SEPARATOR = ','
    public static readonly RECT_LABELS_EXPORT_CSV_COLUMN_NAMES = [
        'label_name',
        'bbox_x',
        'bbox_y',
        'bbox_width',
        'bbox_height',
        'image_name',
        'image_width',
        'image_height'
    ].join(Settings.CSV_SEPARATOR)
}

```

Path: src/settings/ViewPointSettings.ts
```ts
export class ViewPointSettings {
    public static readonly CANVAS_MIN_MARGIN_PX: number = 20;
    public static readonly MIN_ZOOM: number = 1;
    public static readonly MAX_ZOOM: number = 4;
    public static readonly ZOOM_STEP: number = 0.1;
    public static readonly TRANSLATION_STEP_PX: number = 20;
}
```

Path: src/staticModels/EditorModel.ts
```ts
import { PrimaryEditorRenderEngine } from "../logic/render/PrimaryEditorRenderEngine";
import { BaseRenderEngine } from "../logic/render/BaseRenderEngine";
import { IRect } from "../interfaces/IRect";
import { IPoint } from "../interfaces/IPoint";
import { ISize } from "../interfaces/ISize";
import Scrollbars from "react-custom-scrollbars-2";
import { ViewPortHelper } from "../logic/helpers/ViewPortHelper";

export class EditorModel {
    public static editor: HTMLDivElement;
    public static canvas: HTMLCanvasElement;
    public static mousePositionIndicator: HTMLDivElement;
    public static cursor: HTMLDivElement;
    public static viewPortScrollbars: Scrollbars;
    public static image: HTMLImageElement;

    public static primaryRenderingEngine: PrimaryEditorRenderEngine;
    public static supportRenderingEngine: BaseRenderEngine;

    public static viewPortHelper: ViewPortHelper;

    public static isLoading: boolean = false;
    public static viewPortActionsDisabled: boolean = false;
    public static mousePositionOnViewPortContent: IPoint;
    public static viewPortSize: ISize;

    // x and y describe the dimension of the margin that remains constant regardless of the scale of the image
    // width and height describes the render image size for 100% scale
    public static defaultRenderImageRect: IRect;
}
```

Path: src/staticModels/PlatformModel.ts
```ts
import {MobileDeviceData} from "../data/MobileDeviceData";

export class PlatformModel {
    public static mobileDeviceData: MobileDeviceData;
    public static isMac: boolean;
    public static isSafari: boolean;
    public static isFirefox: boolean;
}
```

Path: src/__test__/custom-test-env.js
```js
const Environment = require('jest-environment-jsdom');

/**
 * A custom environment to set the TextEncoder that is required by TensorFlow.js.
 */
module.exports = class CustomTestEnvironment extends Environment {
    async setup() {
        await super.setup();
        const { TextEncoder } = require('util');
        this.global.TextEncoder = TextEncoder;
    }
}
```

Path: src/logic/initializer/AppInitializer.ts
```ts
import {updateWindowSize} from '../../store/general/actionCreators';
import {ContextManager} from '../context/ContextManager';
import {store} from '../../index';
import {PlatformUtil} from '../../utils/PlatformUtil';
import {PlatformModel} from '../../staticModels/PlatformModel';
import {EventType} from '../../data/enums/EventType';
import {GeneralSelector} from '../../store/selectors/GeneralSelector';
import {EnvironmentUtil} from '../../utils/EnvironmentUtil';

export class AppInitializer {
    public static inti():void {
        AppInitializer.handleResize();
        AppInitializer.detectDeviceParams();
        AppInitializer.handleAccidentalPageExit();
        window.addEventListener(EventType.RESIZE, AppInitializer.handleResize);
        window.addEventListener(EventType.MOUSE_WHEEL, AppInitializer.disableGenericScrollZoom,{passive:false});
        window.addEventListener(EventType.KEY_DOWN, AppInitializer.disableUnwantedKeyBoardBehaviour);
        window.addEventListener(EventType.KEY_PRESS, AppInitializer.disableUnwantedKeyBoardBehaviour);
        ContextManager.init();
    }

    private static handleAccidentalPageExit = () => {
        window.onbeforeunload = (event) => {
            const projectType = GeneralSelector.getProjectType();
            if (projectType != null && EnvironmentUtil.isProd()) {
                event.preventDefault();
                event.returnValue = '';
            }
        }
    };

    private static handleResize = () => {
        store.dispatch(updateWindowSize({
            width: window.innerWidth,
            height: window.innerHeight
        }));
    };

    private static disableUnwantedKeyBoardBehaviour = (event: KeyboardEvent) => {
        if (['=', '+', '-'].includes(event.key)) {
            if (event.ctrlKey || (PlatformModel.isMac && event.metaKey)) {
                event.preventDefault();
            }
        }
    };

    private static disableGenericScrollZoom = (event: MouseEvent) => {
        if (event.ctrlKey || (PlatformModel.isMac && event.metaKey)) {
            event.preventDefault();
        }
    };

    private static detectDeviceParams = () => {
        const userAgent: string = window.navigator.userAgent;
        PlatformModel.mobileDeviceData = PlatformUtil.getMobileDeviceData(userAgent);
        PlatformModel.isMac = PlatformUtil.isMac(userAgent);
        PlatformModel.isSafari = PlatformUtil.isSafari(userAgent);
        PlatformModel.isFirefox = PlatformUtil.isFirefox(userAgent);
    };
}
```

Path: src/logic/context/BaseContext.ts
```ts
import {HotKeyAction} from "../../data/HotKeyAction";

export class BaseContext {
    public static actions: HotKeyAction[] = [];

    public static getActions(): HotKeyAction[] {
        return this.actions;
    }
}
```

Path: src/logic/context/ContextManager.ts
```ts
import {ContextType} from "../../data/enums/ContextType";
import {HotKeyAction} from "../../data/HotKeyAction";
import {store} from "../../index";
import {updateActiveContext} from "../../store/general/actionCreators";
import {xor, isEmpty} from "lodash";
import {EditorContext} from "./EditorContext";
import {PopupContext} from "./PopupContext";
import {GeneralSelector} from "../../store/selectors/GeneralSelector";
import {EventType} from "../../data/enums/EventType";

export class ContextManager {
    private static activeCombo: string[] = [];
    private static actions: HotKeyAction[] = [];
    private static contextHistory: ContextType[] = [];

    public static getActiveCombo(): string[] {
        return ContextManager.activeCombo;
    }

    public static init(): void {
        window.addEventListener(EventType.KEY_DOWN, ContextManager.onDown);
        window.addEventListener(EventType.KEY_UP, ContextManager.onUp);
        window.addEventListener(EventType.FOCUS, ContextManager.onFocus);
    }

    public static switchCtx(context: ContextType): void {
        const activeCtx: ContextType = GeneralSelector.getActiveContext();

        if (activeCtx !== context) {
            ContextManager.contextHistory.push(activeCtx);
            ContextManager.updateCtx(context);
        }
    }

    private static updateCtx(context: ContextType): void {
        store.dispatch(updateActiveContext(context));
        switch (context) {
            case ContextType.EDITOR:
                ContextManager.actions = EditorContext.getActions();
                break;
            case ContextType.POPUP:
                ContextManager.actions = PopupContext.getActions();
                break;
            default:
                ContextManager.actions = [];
        }
    }

    public static restoreCtx(): void {
        ContextManager.updateCtx(ContextManager.contextHistory.pop());
    }

    private static onDown(event: KeyboardEvent): void {
        const keyCode: string = ContextManager.getKeyCodeFromEvent(event);
        if (!ContextManager.isInCombo(keyCode)) {
            ContextManager.addToCombo(keyCode);
        }
        ContextManager.execute(event);
    }

    private static onUp(event: KeyboardEvent): void {
        const keyCode: string = ContextManager.getKeyCodeFromEvent(event);
        ContextManager.removeFromCombo(keyCode);
    }

    public static onFocus() {
        ContextManager.activeCombo = [];
    }

    private static execute(event: KeyboardEvent): void {
        for (let i = 0; i < ContextManager.actions.length; i++) {
            const hotKey: HotKeyAction = ContextManager.actions[i];
            if (ContextManager.matchCombo(ContextManager.activeCombo, hotKey.keyCombo)) {
                hotKey.action(event);
            }
        }
    }

    private static isInCombo(keyCode: string): boolean {
        return ContextManager.activeCombo.indexOf(keyCode) >= 0;
    }

    private static addToCombo(keyCode: string): void {
        ContextManager.activeCombo.push(keyCode);
    }

    private static removeFromCombo(keyCode: string): void {
        const index: number = ContextManager.activeCombo.indexOf(keyCode);
        if (index >= 0) {
            ContextManager.activeCombo.splice(index, 1);
        }
    }

    private static getKeyCodeFromEvent(event: KeyboardEvent): string {
        return event.key;
    }

    private static matchCombo(combo1: string[], combo2: string[]): boolean {
        return isEmpty(xor(combo1, combo2))
    }
}
```

Path: src/logic/context/EditorContext.ts
```ts
import {HotKeyAction} from "../../data/HotKeyAction";
import {EditorModel} from "../../staticModels/EditorModel";
import {LabelType} from "../../data/enums/LabelType";
import {EditorData} from "../../data/EditorData";
import {EditorActions} from "../actions/EditorActions";
import {PolygonRenderEngine} from "../render/PolygonRenderEngine";
import {BaseContext} from "./BaseContext";
import {ImageActions} from "../actions/ImageActions";
import {ViewPortActions} from "../actions/ViewPortActions";
import {Direction} from "../../data/enums/Direction";
import {PlatformUtil} from "../../utils/PlatformUtil";
import {LabelActions} from "../actions/LabelActions";
import {LineRenderEngine} from "../render/LineRenderEngine";

export class EditorContext extends BaseContext {
    public static actions: HotKeyAction[] = [
        {
            keyCombo: ["Enter"],
            action: (event: KeyboardEvent) => {
                if (EditorModel.supportRenderingEngine && EditorModel.supportRenderingEngine.labelType === LabelType.POLYGON) {
                    const editorData: EditorData = EditorActions.getEditorData();
                    (EditorModel.supportRenderingEngine as PolygonRenderEngine).addLabelAndFinishCreation(editorData);
                }
                EditorActions.fullRender();
            }
        },
        {
            keyCombo: ["Escape"],
            action: (event: KeyboardEvent) => {
                if (EditorModel.supportRenderingEngine) {
                    switch (EditorModel.supportRenderingEngine.labelType) {
                        case LabelType.POLYGON:
                            (EditorModel.supportRenderingEngine as PolygonRenderEngine).cancelLabelCreation();
                            break;
                        case LabelType.LINE:
                            (EditorModel.supportRenderingEngine as LineRenderEngine).cancelLabelCreation();
                            break;
                    }
                }
                EditorActions.fullRender();
            }
        },
        {
            keyCombo: PlatformUtil.isMac(window.navigator.userAgent) ? ["Alt", "ArrowLeft"] : ["Control", "ArrowLeft"],
            action: (event: KeyboardEvent) => {
                ImageActions.getPreviousImage()
            }
        },
        {
            keyCombo: PlatformUtil.isMac(window.navigator.userAgent) ? ["Alt", "ArrowRight"] : ["Control", "ArrowRight"],
            action: (event: KeyboardEvent) => {
                ImageActions.getNextImage();
            }
        },
        {
            keyCombo: PlatformUtil.isMac(window.navigator.userAgent) ? ["Alt", "+"] : ["Control", "+"],
            action: (event: KeyboardEvent) => {
                ViewPortActions.zoomIn();
            }
        },
        {
            keyCombo: PlatformUtil.isMac(window.navigator.userAgent) ? ["Alt", "-"] : ["Control", "-"],
            action: (event: KeyboardEvent) => {
                ViewPortActions.zoomOut();
            }
        },
        {
            keyCombo: ["ArrowRight"],
            action: (event: KeyboardEvent) => {
                event.preventDefault();
                ViewPortActions.translateViewPortPosition(Direction.RIGHT);
            }
        },
        {
            keyCombo: ["ArrowLeft"],
            action: (event: KeyboardEvent) => {
                event.preventDefault();
                ViewPortActions.translateViewPortPosition(Direction.LEFT);
            }
        },
        {
            keyCombo: ["ArrowUp"],
            action: (event: KeyboardEvent) => {
                event.preventDefault();
                ViewPortActions.translateViewPortPosition(Direction.BOTTOM);
            }
        },
        {
            keyCombo: ["ArrowDown"],
            action: (event: KeyboardEvent) => {
                event.preventDefault();
                ViewPortActions.translateViewPortPosition(Direction.TOP);
            }
        },
        {
            keyCombo: PlatformUtil.isMac(window.navigator.userAgent) ? ["Backspace"] : ["Delete"],
            action: (event: KeyboardEvent) => {
                LabelActions.deleteActiveLabel();
            }
        },
        {
            keyCombo: PlatformUtil.isMac(window.navigator.userAgent) ? ["Alt", "0"] : ["Control", "0"],
            action: (event: KeyboardEvent) => {
                ImageActions.setActiveLabelOnActiveImage(0);
                EditorActions.fullRender();
            }
        },
        {
            keyCombo: PlatformUtil.isMac(window.navigator.userAgent) ? ["Alt", "1"] : ["Control", "1"],
            action: (event: KeyboardEvent) => {
                ImageActions.setActiveLabelOnActiveImage(1);
                EditorActions.fullRender();
            }
        },
        {
            keyCombo: PlatformUtil.isMac(window.navigator.userAgent) ? ["Alt", "2"] : ["Control", "2"],
            action: (event: KeyboardEvent) => {
                ImageActions.setActiveLabelOnActiveImage(2);
                EditorActions.fullRender();
            }
        },
        {
            keyCombo: PlatformUtil.isMac(window.navigator.userAgent) ? ["Alt", "3"] : ["Control", "3"],
            action: (event: KeyboardEvent) => {
                ImageActions.setActiveLabelOnActiveImage(3);
                EditorActions.fullRender();
            }
        },
        {
            keyCombo: PlatformUtil.isMac(window.navigator.userAgent) ? ["Alt", "4"] : ["Control", "4"],
            action: (event: KeyboardEvent) => {
                ImageActions.setActiveLabelOnActiveImage(4);
                EditorActions.fullRender();
            }
        },
        {
            keyCombo: PlatformUtil.isMac(window.navigator.userAgent) ? ["Alt", "5"] : ["Control", "5"],
            action: (event: KeyboardEvent) => {
                ImageActions.setActiveLabelOnActiveImage(5);
                EditorActions.fullRender();
            }
        },
        {
            keyCombo: PlatformUtil.isMac(window.navigator.userAgent) ? ["Alt", "6"] : ["Control", "6"],
            action: (event: KeyboardEvent) => {
                ImageActions.setActiveLabelOnActiveImage(6);
                EditorActions.fullRender();
            }
        },
        {
            keyCombo: PlatformUtil.isMac(window.navigator.userAgent) ? ["Alt", "7"] : ["Control", "7"],
            action: (event: KeyboardEvent) => {
                ImageActions.setActiveLabelOnActiveImage(7);
                EditorActions.fullRender();
            }
        },
        {
            keyCombo: PlatformUtil.isMac(window.navigator.userAgent) ? ["Alt", "8"] : ["Control", "8"],
            action: (event: KeyboardEvent) => {
                ImageActions.setActiveLabelOnActiveImage(8);
                EditorActions.fullRender();
            }
        },
        {
            keyCombo: PlatformUtil.isMac(window.navigator.userAgent) ? ["Alt", "9"] : ["Control", "9"],
            action: (event: KeyboardEvent) => {
                ImageActions.setActiveLabelOnActiveImage(9);
                EditorActions.fullRender();
            }
        }
    ];
}
```

Path: src/logic/context/PopupContext.ts
```ts
import {HotKeyAction} from '../../data/HotKeyAction';
import {PopupWindowType} from '../../data/enums/PopupWindowType';
import {GeneralSelector} from '../../store/selectors/GeneralSelector';
import {BaseContext} from './BaseContext';
import {PopupActions} from '../actions/PopupActions';
import {Settings} from '../../settings/Settings';

export class PopupContext extends BaseContext {
    public static actions: HotKeyAction[] = [
        {
            keyCombo: ['Escape'],
            action: (event: KeyboardEvent) => {
                const popupType: PopupWindowType = GeneralSelector.getActivePopupType();
                const canBeClosed: boolean = Settings.CLOSEABLE_POPUPS.includes(popupType);
                if (canBeClosed) {
                    PopupActions.close();
                }
            }
        }
    ];
}

```

Path: src/logic/render/BaseRenderEngine.ts
```ts
import {EditorData} from '../../data/EditorData';
import {MouseEventUtil} from '../../utils/MouseEventUtil';
import {EventType} from '../../data/enums/EventType';
import {LabelType} from '../../data/enums/LabelType';
import {GeneralSelector} from '../../store/selectors/GeneralSelector';
import {RenderEngineSettings} from '../../settings/RenderEngineSettings';
import {LabelName} from '../../store/labels/types';
import {LabelsSelector} from '../../store/selectors/LabelsSelector';

export abstract class BaseRenderEngine {
    protected readonly canvas: HTMLCanvasElement;
    public labelType: LabelType;

    protected constructor(canvas: HTMLCanvasElement) {
        this.canvas = canvas;
    }

    public update(data: EditorData): void {
        if (!!data.event) {
            switch (MouseEventUtil.getEventType(data.event)) {
                case EventType.MOUSE_MOVE:
                    this.mouseMoveHandler(data);
                    break;
                case EventType.MOUSE_UP:
                    this.mouseUpHandler(data);
                    break;
                case EventType.MOUSE_DOWN:
                    this.mouseDownHandler(data);
                    break;
                default:
                    break;
            }
        }
    }

    protected abstract mouseDownHandler(data: EditorData): void;
    protected abstract mouseMoveHandler(data: EditorData): void;
    protected abstract mouseUpHandler(data: EditorData): void;

    abstract render(data: EditorData): void;

    abstract isInProgress(): boolean;

    protected static resolveLabelLineColor(labelId: string, isActive: boolean): string {
        const perClassColor: boolean = GeneralSelector.getEnablePerClassColorationStatus();
        if (perClassColor) {
            const labelName: LabelName | null = LabelsSelector.getLabelNameById(labelId);
            return labelName ? labelName.color : RenderEngineSettings.DEFAULT_LINE_COLOR;
        } else {
            return isActive ? RenderEngineSettings.ACTIVE_LINE_COLOR : RenderEngineSettings.INACTIVE_LINE_COLOR;
        }
    }

    protected static resolveLabelAnchorColor(isActive: boolean): string {
        const perClassColor: boolean = GeneralSelector.getEnablePerClassColorationStatus();
        if (perClassColor) {
            return RenderEngineSettings.DEFAULT_ANCHOR_COLOR;
        } else {
            return isActive ? RenderEngineSettings.ACTIVE_ANCHOR_COLOR : RenderEngineSettings.INACTIVE_ANCHOR_COLOR;
        }
    }
}

```

Path: src/logic/render/LineRenderEngine.ts
```ts
import {BaseRenderEngine} from './BaseRenderEngine';
import {RenderEngineSettings} from '../../settings/RenderEngineSettings';
import {LabelType} from '../../data/enums/LabelType';
import {EditorData} from '../../data/EditorData';
import {RenderEngineUtil} from '../../utils/RenderEngineUtil';
import {ImageData, LabelLine} from '../../store/labels/types';
import {IPoint} from '../../interfaces/IPoint';
import {RectUtil} from '../../utils/RectUtil';
import {store} from '../../index';
import {
    updateActiveLabelId,
    updateFirstLabelCreatedFlag,
    updateHighlightedLabelId,
    updateImageDataById
} from '../../store/labels/actionCreators';
import {EditorActions} from '../actions/EditorActions';
import {LabelsSelector} from '../../store/selectors/LabelsSelector';
import {DrawUtil} from '../../utils/DrawUtil';
import {GeneralSelector} from '../../store/selectors/GeneralSelector';
import { v4 as uuidv4 } from 'uuid';
import {ILine} from '../../interfaces/ILine';
import {LineUtil} from '../../utils/LineUtil';
import {updateCustomCursorStyle} from '../../store/general/actionCreators';
import {CustomCursorStyle} from '../../data/enums/CustomCursorStyle';
import {LineAnchorType} from '../../data/enums/LineAnchorType';
import {Settings} from '../../settings/Settings';

export class LineRenderEngine extends BaseRenderEngine {

    // =================================================================================================================
    // STATE
    // =================================================================================================================

    private lineCreationStartPoint: IPoint;
    private lineUpdateAnchorType: LineAnchorType;

    public constructor(canvas: HTMLCanvasElement) {
        super(canvas);
        this.labelType = LabelType.LINE;
    }

    // =================================================================================================================
    // EVENT HANDLERS
    // =================================================================================================================

    public mouseDownHandler(data: EditorData): void {
        const isMouseOverImage: boolean = RenderEngineUtil.isMouseOverImage(data);
        const isMouseOverCanvas: boolean = RenderEngineUtil.isMouseOverCanvas(data);
        const anchorTypeUnderMouse = this.getAnchorTypeUnderMouse(data);
        const labelLineUnderMouse: LabelLine = this.getLineUnderMouse(data);

        if (isMouseOverCanvas) {
            if (!!anchorTypeUnderMouse && !this.isResizeInProgress()) {
                this.startExistingLabelUpdate(labelLineUnderMouse.id, anchorTypeUnderMouse)
            } else if (labelLineUnderMouse !== null) {
                store.dispatch(updateActiveLabelId(labelLineUnderMouse.id));
            } else if (!this.isInProgress() && isMouseOverImage) {
                this.startNewLabelCreation(data)
            } else if (this.isInProgress()) {
                this.finishNewLabelCreation(data);
            }
        }
    }

    public mouseUpHandler(data: EditorData): void {
        if (this.isResizeInProgress()) {
            this.endExistingLabelUpdate(data)
        }
    }

    public mouseMoveHandler(data: EditorData): void {
        const isOverImage: boolean = RenderEngineUtil.isMouseOverImage(data);
        if (isOverImage) {
            const labelLine: LabelLine = this.getLineUnderMouse(data);
            if (!!labelLine) {
                if (LabelsSelector.getHighlightedLabelId() !== labelLine.id) {
                    store.dispatch(updateHighlightedLabelId(labelLine.id))
                }
            } else {
                if (LabelsSelector.getHighlightedLabelId() !== null) {
                    store.dispatch(updateHighlightedLabelId(null));
                }
            }
        }
    }

    // =================================================================================================================
    // RENDERING
    // =================================================================================================================

    public render(data: EditorData): void {
        this.drawExistingLabels(data);
        this.drawActivelyCreatedLabel(data)
        this.drawActivelyResizeLabel(data)
        this.updateCursorStyle(data);
    }

    private drawExistingLabels(data: EditorData) {
        const activeLabelId: string = LabelsSelector.getActiveLabelId();
        const highlightedLabelId: string = LabelsSelector.getHighlightedLabelId();
        const imageData: ImageData = LabelsSelector.getActiveImageData();
        imageData.labelLines.forEach((labelLine: LabelLine) => {
            if (labelLine.isVisible) {
                const isActive: boolean = labelLine.id === activeLabelId || labelLine.id === highlightedLabelId;
                const lineOnCanvas = RenderEngineUtil.transferLineFromImageToViewPortContent(labelLine.line, data)
                if (!(labelLine.id === activeLabelId && this.isResizeInProgress())) {
                    this.drawLine(labelLine.labelId, lineOnCanvas, isActive)
                }
            }
        });
    }

    private drawActivelyCreatedLabel(data: EditorData) {
        if (this.isInProgress()) {
            const line = {start: this.lineCreationStartPoint, end: data.mousePositionOnViewPortContent}
            DrawUtil.drawLine(this.canvas, line.start, line.end, RenderEngineSettings.lineActiveColor, RenderEngineSettings.LINE_THICKNESS);
            DrawUtil.drawCircleWithFill(this.canvas, this.lineCreationStartPoint, Settings.RESIZE_HANDLE_DIMENSION_PX/2, RenderEngineSettings.defaultAnchorColor)
        }
    }

    private drawActivelyResizeLabel(data: EditorData) {
        const activeLabelLine: LabelLine = LabelsSelector.getActiveLineLabel();
        if (!!activeLabelLine && this.isResizeInProgress()) {
            const snappedMousePosition: IPoint =
                RectUtil.snapPointToRect(data.mousePositionOnViewPortContent, data.viewPortContentImageRect);
            const lineOnCanvas = RenderEngineUtil.transferLineFromImageToViewPortContent(activeLabelLine.line, data)
            const lineToDraw = {
                start: this.lineUpdateAnchorType === LineAnchorType.START ? snappedMousePosition : lineOnCanvas.start,
                end: this.lineUpdateAnchorType === LineAnchorType.END ? snappedMousePosition : lineOnCanvas.end
            }
            this.drawLine(activeLabelLine.labelId, lineToDraw, true)
        }
    }

    private updateCursorStyle(data: EditorData) {
        if (!!this.canvas && !!data.mousePositionOnViewPortContent && !GeneralSelector.getImageDragModeStatus()) {
            const isMouseOverCanvas: boolean = RenderEngineUtil.isMouseOverCanvas(data);
            if (isMouseOverCanvas) {
                const anchorTypeUnderMouse = this.getAnchorTypeUnderMouse(data);
                if (!this.isInProgress() && !!anchorTypeUnderMouse) {
                    store.dispatch(updateCustomCursorStyle(CustomCursorStyle.MOVE));
                } else if (this.isResizeInProgress()) {
                    store.dispatch(updateCustomCursorStyle(CustomCursorStyle.MOVE));
                } else {
                    RenderEngineUtil.wrapDefaultCursorStyleInCancel(data);
                }
                this.canvas.style.cursor = 'none';
            } else {
                this.canvas.style.cursor = 'default';
            }
        }
    }

    private drawLine(labelId: string, line: ILine, isActive: boolean) {
        const lineColor: string = BaseRenderEngine.resolveLabelLineColor(labelId, isActive)
        const anchorColor = BaseRenderEngine.resolveLabelAnchorColor(isActive)
        const standardizedLine: ILine = {
            start: RenderEngineUtil.setPointBetweenPixels(line.start),
            end: RenderEngineUtil.setPointBetweenPixels(line.end)
        }
        DrawUtil.drawLine(this.canvas, standardizedLine.start, standardizedLine.end, lineColor, RenderEngineSettings.LINE_THICKNESS);
        if (isActive) {

            LineUtil
                .getPoints(line)
                .forEach((point: IPoint) => DrawUtil.drawCircleWithFill(this.canvas, point,
                    Settings.RESIZE_HANDLE_DIMENSION_PX/2, anchorColor))
        }
    }

    // =================================================================================================================
    // VALIDATORS
    // =================================================================================================================

    public isInProgress(): boolean {
        return !!this.lineCreationStartPoint
    }

    public isResizeInProgress(): boolean {
        return !!this.lineUpdateAnchorType;
    }

    // =================================================================================================================
    // CREATION
    // =================================================================================================================

    private startNewLabelCreation = (data: EditorData) => {
        this.lineCreationStartPoint = RenderEngineUtil.setPointBetweenPixels(data.mousePositionOnViewPortContent)
        EditorActions.setViewPortActionsDisabledStatus(true);
    }

    private finishNewLabelCreation = (data: EditorData) => {
        const mousePositionOnCanvasSnapped: IPoint = RectUtil.snapPointToRect(
            data.mousePositionOnViewPortContent, data.viewPortContentImageRect
        );
        const lineOnCanvas = {start: this.lineCreationStartPoint, end: mousePositionOnCanvasSnapped}
        const lineOnImage = RenderEngineUtil.transferLineFromViewPortContentToImage(lineOnCanvas, data);
        const activeLabelId = LabelsSelector.getActiveLabelNameId();
        const imageData: ImageData = LabelsSelector.getActiveImageData();
        const labelLine: LabelLine = {
            id: uuidv4(),
            labelId: activeLabelId,
            line: lineOnImage,
            isVisible: true
        };
        imageData.labelLines.push(labelLine);
        store.dispatch(updateImageDataById(imageData.id, imageData));
        store.dispatch(updateFirstLabelCreatedFlag(true));
        store.dispatch(updateActiveLabelId(labelLine.id));
        this.lineCreationStartPoint = null
        EditorActions.setViewPortActionsDisabledStatus(false);
    };

    public cancelLabelCreation() {
        this.lineCreationStartPoint = null
        EditorActions.setViewPortActionsDisabledStatus(false);
    }

    // =================================================================================================================
    // UPDATE
    // =================================================================================================================

    private startExistingLabelUpdate(labelId: string, anchorType: LineAnchorType) {
        store.dispatch(updateActiveLabelId(labelId));
        this.lineUpdateAnchorType = anchorType;
        EditorActions.setViewPortActionsDisabledStatus(true);
    }

    private endExistingLabelUpdate(data: EditorData) {
        this.applyUpdateToLineLabel(data);
        this.lineUpdateAnchorType = null;
        EditorActions.setViewPortActionsDisabledStatus(false);
    }

    private applyUpdateToLineLabel(data: EditorData) {
        const imageData: ImageData = LabelsSelector.getActiveImageData();
        const activeLabel: LabelLine = LabelsSelector.getActiveLineLabel();
        imageData.labelLines = imageData.labelLines.map((lineLabel: LabelLine) => {
            if (lineLabel.id !== activeLabel.id) {
                return lineLabel
            } else {
                const snappedMousePosition: IPoint =
                    RectUtil.snapPointToRect(data.mousePositionOnViewPortContent, data.viewPortContentImageRect);
                const mousePositionOnImage = RenderEngineUtil.transferPointFromViewPortContentToImage(
                    snappedMousePosition, data
                );
                return {
                    ...lineLabel,
                    line: {
                        start: this.lineUpdateAnchorType === LineAnchorType.START ? mousePositionOnImage : lineLabel.line.start,
                        end: this.lineUpdateAnchorType === LineAnchorType.END ? mousePositionOnImage : lineLabel.line.end
                    }
                }
            }
        });

        store.dispatch(updateImageDataById(imageData.id, imageData));
        store.dispatch(updateActiveLabelId(activeLabel.id));
    }

    // =================================================================================================================
    // GETTERS
    // =================================================================================================================

    private getLineUnderMouse(data: EditorData): LabelLine | null {
        const mouseOnCanvas = data.mousePositionOnViewPortContent;
        if (!mouseOnCanvas) return null;

        const labelLines: LabelLine[] = LabelsSelector
            .getActiveImageData()
            .labelLines
            .filter((labelLine: LabelLine) => labelLine.isVisible);
        const radius = RenderEngineSettings.anchorHoverSize.width / 2;

        for (const labelLine of labelLines) {
            const lineOnCanvas: ILine = RenderEngineUtil.transferLineFromImageToViewPortContent(labelLine.line, data);
            if (RenderEngineUtil.isMouseOverLine(mouseOnCanvas, lineOnCanvas, radius)) return labelLine;
        }
        return null;
    }

    private getAnchorTypeUnderMouse(data: EditorData): LineAnchorType | null {
        const mouseOnCanvas = data.mousePositionOnViewPortContent;
        if (!mouseOnCanvas) return null;

        const labelLines: LabelLine[] = LabelsSelector
            .getActiveImageData()
            .labelLines
            .filter((labelLine: LabelLine) => labelLine.isVisible);
        const radius = RenderEngineSettings.anchorHoverSize.width / 2;

        for (const labelLine of labelLines) {
            const lineOnCanvas: ILine = RenderEngineUtil.transferLineFromImageToViewPortContent(labelLine.line, data);
            if (RenderEngineUtil.isMouseOverAnchor(mouseOnCanvas, lineOnCanvas.start, radius)) {
                return LineAnchorType.START
            }
            if (RenderEngineUtil.isMouseOverAnchor(mouseOnCanvas, lineOnCanvas.end, radius)) {
                return LineAnchorType.END
            }
        }
        return null;
    }
}

```

Path: src/logic/render/PointRenderEngine.ts
```ts
import {IRect} from '../../interfaces/IRect';
import {RenderEngineSettings} from '../../settings/RenderEngineSettings';
import {IPoint} from '../../interfaces/IPoint';
import {CanvasUtil} from '../../utils/CanvasUtil';
import {store} from '../../index';
import {ImageData, LabelPoint} from '../../store/labels/types';
import {
    updateActiveLabelId,
    updateFirstLabelCreatedFlag,
    updateHighlightedLabelId,
    updateImageDataById
} from '../../store/labels/actionCreators';
import {RectUtil} from '../../utils/RectUtil';
import {DrawUtil} from '../../utils/DrawUtil';
import {updateCustomCursorStyle} from '../../store/general/actionCreators';
import {CustomCursorStyle} from '../../data/enums/CustomCursorStyle';
import {LabelsSelector} from '../../store/selectors/LabelsSelector';
import {EditorData} from '../../data/EditorData';
import {BaseRenderEngine} from './BaseRenderEngine';
import {RenderEngineUtil} from '../../utils/RenderEngineUtil';
import {LabelType} from '../../data/enums/LabelType';
import {EditorActions} from '../actions/EditorActions';
import {EditorModel} from '../../staticModels/EditorModel';
import {GeneralSelector} from '../../store/selectors/GeneralSelector';
import {LabelStatus} from '../../data/enums/LabelStatus';
import {Settings} from '../../settings/Settings';
import {LabelUtil} from '../../utils/LabelUtil';

export class PointRenderEngine extends BaseRenderEngine {

    // =================================================================================================================
    // STATE
    // =================================================================================================================

    public constructor(canvas: HTMLCanvasElement) {
        super(canvas);
        this.labelType = LabelType.POINT;
    }

    // =================================================================================================================
    // EVENT HANDLERS
    // =================================================================================================================

    public mouseDownHandler(data: EditorData): void {
        const isMouseOverImage: boolean = RenderEngineUtil.isMouseOverImage(data);
        const isMouseOverCanvas: boolean = RenderEngineUtil.isMouseOverCanvas(data);

        if (isMouseOverCanvas) {
            const labelPoint: LabelPoint = this.getLabelPointUnderMouse(data.mousePositionOnViewPortContent, data);
            if (!!labelPoint) {
                const pointOnCanvas: IPoint = RenderEngineUtil.transferPointFromImageToViewPortContent(labelPoint.point, data);
                const pointBetweenPixels = RenderEngineUtil.setPointBetweenPixels(pointOnCanvas);
                const handleRect: IRect = RectUtil.getRectWithCenterAndSize(pointBetweenPixels, RenderEngineSettings.anchorHoverSize);
                if (RectUtil.isPointInside(handleRect, data.mousePositionOnViewPortContent)) {
                    store.dispatch(updateActiveLabelId(labelPoint.id));
                    EditorActions.setViewPortActionsDisabledStatus(true);
                    return;
                } else {
                    store.dispatch(updateActiveLabelId(null));
                    const pointOnImage: IPoint = RenderEngineUtil.transferPointFromViewPortContentToImage(data.mousePositionOnViewPortContent, data);
                    this.addPointLabel(pointOnImage);
                }
            } else if (isMouseOverImage) {
                const pointOnImage: IPoint = RenderEngineUtil.transferPointFromViewPortContentToImage(data.mousePositionOnViewPortContent, data);
                this.addPointLabel(pointOnImage);
            }
        }
    }

    public mouseUpHandler(data: EditorData): void {
        if (this.isInProgress()) {
            const activeLabelPoint: LabelPoint = LabelsSelector.getActivePointLabel();
            const pointSnapped: IPoint = RectUtil.snapPointToRect(data.mousePositionOnViewPortContent, data.viewPortContentImageRect);
            const pointOnImage: IPoint = RenderEngineUtil.transferPointFromViewPortContentToImage(pointSnapped, data);
            const imageData = LabelsSelector.getActiveImageData();

            imageData.labelPoints = imageData.labelPoints.map((labelPoint: LabelPoint) => {
                if (labelPoint.id === activeLabelPoint.id) {
                    return {
                        ...labelPoint,
                        point: pointOnImage
                    };
                }
                return labelPoint;
            });
            store.dispatch(updateImageDataById(imageData.id, imageData));
        }
        EditorActions.setViewPortActionsDisabledStatus(false);
    }

    public mouseMoveHandler(data: EditorData): void {
        const isOverImage: boolean = RenderEngineUtil.isMouseOverImage(data);
        if (isOverImage) {
            const labelPoint: LabelPoint = this.getLabelPointUnderMouse(data.mousePositionOnViewPortContent, data);
            if (!!labelPoint) {
                if (LabelsSelector.getHighlightedLabelId() !== labelPoint.id) {
                    store.dispatch(updateHighlightedLabelId(labelPoint.id))
                }
            } else {
                if (LabelsSelector.getHighlightedLabelId() !== null) {
                    store.dispatch(updateHighlightedLabelId(null))
                }
            }
        }
    }

    // =================================================================================================================
    // RENDERING
    // =================================================================================================================

    public render(data: EditorData): void {
        const activeLabelId: string = LabelsSelector.getActiveLabelId();
        const highlightedLabelId: string = LabelsSelector.getHighlightedLabelId();
        const imageData: ImageData = LabelsSelector.getActiveImageData();
        if (imageData) {
            imageData.labelPoints.forEach((labelPoint: LabelPoint) => {
                if (labelPoint.isVisible) {
                    if (labelPoint.id === activeLabelId) {
                        if (this.isInProgress()) {
                            const pointSnapped: IPoint = RectUtil.snapPointToRect(data.mousePositionOnViewPortContent, data.viewPortContentImageRect);
                            const pointBetweenPixels: IPoint = RenderEngineUtil.setPointBetweenPixels(pointSnapped);
                            const anchorColor: string = BaseRenderEngine.resolveLabelAnchorColor(true);
                            DrawUtil.drawCircleWithFill(this.canvas, pointBetweenPixels, Settings.RESIZE_HANDLE_DIMENSION_PX/2, anchorColor)
                        } else {
                            this.renderPoint(labelPoint, true, data);
                        }
                    } else {
                        this.renderPoint(labelPoint, labelPoint.id === activeLabelId || labelPoint.id === highlightedLabelId, data);
                    }
                }
            });
        }
        this.updateCursorStyle(data);
    }

    private renderPoint(labelPoint: LabelPoint, isActive: boolean, data: EditorData) {
        const pointOnImage: IPoint = RenderEngineUtil.transferPointFromImageToViewPortContent(labelPoint.point, data);
        const pointBetweenPixels = RenderEngineUtil.setPointBetweenPixels(pointOnImage);
        const anchorColor: string = BaseRenderEngine.resolveLabelAnchorColor(isActive);
        DrawUtil.drawCircleWithFill(this.canvas, pointBetweenPixels, Settings.RESIZE_HANDLE_DIMENSION_PX/2, anchorColor)
    }

    private updateCursorStyle(data: EditorData) {
        if (!!this.canvas && !!data.mousePositionOnViewPortContent && !GeneralSelector.getImageDragModeStatus()) {
            const labelPoint: LabelPoint = this.getLabelPointUnderMouse(data.mousePositionOnViewPortContent, data);
            if (!!labelPoint && labelPoint.status === LabelStatus.ACCEPTED) {
                const pointOnCanvas: IPoint = RenderEngineUtil.transferPointFromImageToViewPortContent(labelPoint.point, data);
                const pointBetweenPixels = RenderEngineUtil.setPointBetweenPixels(pointOnCanvas);
                const handleRect: IRect = RectUtil.getRectWithCenterAndSize(pointBetweenPixels, RenderEngineSettings.anchorHoverSize);
                if (RectUtil.isPointInside(handleRect, data.mousePositionOnViewPortContent)) {
                    store.dispatch(updateCustomCursorStyle(CustomCursorStyle.MOVE));
                    return;
                }
            } else if (this.isInProgress()) {
                store.dispatch(updateCustomCursorStyle(CustomCursorStyle.MOVE));
                return;
            }

            if (RectUtil.isPointInside({x: 0, y: 0, ...CanvasUtil.getSize(this.canvas)}, data.mousePositionOnViewPortContent)) {
                RenderEngineUtil.wrapDefaultCursorStyleInCancel(data);
                this.canvas.style.cursor = 'none';
            } else {
                this.canvas.style.cursor = 'default';
            }
        }
    }

    // =================================================================================================================
    // HELPERS
    // =================================================================================================================

    public isInProgress(): boolean {
        return EditorModel.viewPortActionsDisabled;
    }

    private getLabelPointUnderMouse(mousePosition: IPoint, data: EditorData): LabelPoint {
        const labelPoints: LabelPoint[] = LabelsSelector
            .getActiveImageData()
            .labelPoints
            .filter((labelPoint: LabelPoint) => labelPoint.isVisible);
        for (const labelPoint of labelPoints) {
            const pointOnCanvas: IPoint = RenderEngineUtil.transferPointFromImageToViewPortContent(labelPoint.point, data);
            const handleRect: IRect = RectUtil.getRectWithCenterAndSize(pointOnCanvas, RenderEngineSettings.anchorHoverSize);
            if (RectUtil.isPointInside(handleRect, mousePosition)) {
                return labelPoint;
            }
        }
        return null;
    }

    private addPointLabel = (point: IPoint) => {
        const activeLabelId = LabelsSelector.getActiveLabelNameId();
        const imageData: ImageData = LabelsSelector.getActiveImageData();
        const labelPoint: LabelPoint = LabelUtil.createLabelPoint(activeLabelId, point);
        imageData.labelPoints.push(labelPoint);
        store.dispatch(updateImageDataById(imageData.id, imageData));
        store.dispatch(updateFirstLabelCreatedFlag(true));
        store.dispatch(updateActiveLabelId(labelPoint.id));
    };
}

```

Path: src/logic/render/PolygonRenderEngine.ts
```ts
import {store} from '../../index';
import {RectUtil} from '../../utils/RectUtil';
import {updateCustomCursorStyle} from '../../store/general/actionCreators';
import {CustomCursorStyle} from '../../data/enums/CustomCursorStyle';
import {EditorData} from '../../data/EditorData';
import {BaseRenderEngine} from './BaseRenderEngine';
import {RenderEngineSettings} from '../../settings/RenderEngineSettings';
import {IPoint} from '../../interfaces/IPoint';
import {ILine} from '../../interfaces/ILine';
import {DrawUtil} from '../../utils/DrawUtil';
import {IRect} from '../../interfaces/IRect';
import {ImageData, LabelPolygon} from '../../store/labels/types';
import {LabelsSelector} from '../../store/selectors/LabelsSelector';
import {
    updateActiveLabelId,
    updateFirstLabelCreatedFlag,
    updateHighlightedLabelId,
    updateImageDataById
} from '../../store/labels/actionCreators';
import {LineUtil} from '../../utils/LineUtil';
import {MouseEventUtil} from '../../utils/MouseEventUtil';
import {EventType} from '../../data/enums/EventType';
import {RenderEngineUtil} from '../../utils/RenderEngineUtil';
import {LabelType} from '../../data/enums/LabelType';
import {EditorActions} from '../actions/EditorActions';
import {GeneralSelector} from '../../store/selectors/GeneralSelector';
import {Settings} from '../../settings/Settings';
import {LabelUtil} from '../../utils/LabelUtil';
import {PolygonUtil} from '../../utils/PolygonUtil';

export class PolygonRenderEngine extends BaseRenderEngine {

    // =================================================================================================================
    // STATE
    // =================================================================================================================

    private activePath: src/IPoint[] = [];
    private resizeAnchorIndex: number = null;
    private suggestedAnchorPositionOnCanvas: IPoint = null;
    private suggestedAnchorIndexInPolygon: number = null;

    public constructor(canvas: HTMLCanvasElement) {
        super(canvas);
        this.labelType = LabelType.POLYGON;
    }

    // =================================================================================================================
    // EVENT HANDLERS
    // =================================================================================================================

    public update(data: EditorData): void {
        if (!!data.event) {
            switch (MouseEventUtil.getEventType(data.event)) {
                case EventType.MOUSE_MOVE:
                    this.mouseMoveHandler(data);
                    break;
                case EventType.MOUSE_UP:
                    this.mouseUpHandler(data);
                    break;
                case EventType.MOUSE_DOWN:
                    this.mouseDownHandler(data);
                    break;
                default:
                    break;
            }
        }
    }

    public mouseDownHandler(data: EditorData): void {
        const isMouseOverCanvas: boolean = RenderEngineUtil.isMouseOverCanvas(data);
        if (isMouseOverCanvas) {
            if (this.isCreationInProgress()) {
                const isMouseOverStartAnchor: boolean = this.isMouseOverAnchor(
                    data.mousePositionOnViewPortContent, this.activePath[0]);
                if (isMouseOverStartAnchor) {
                    this.addLabelAndFinishCreation(data);
                } else  {
                    this.updateActivelyCreatedLabel(data);
                }
            } else {
                const polygonUnderMouse: LabelPolygon = this.getPolygonUnderMouse(data);
                if (!!polygonUnderMouse) {
                    const anchorIndex: number = polygonUnderMouse.vertices.reduce(
                        (indexUnderMouse: number, anchor: IPoint, index: number) => {
                        if (indexUnderMouse === null) {
                            const anchorOnCanvas: IPoint = RenderEngineUtil.transferPointFromImageToViewPortContent(anchor, data);
                            if (this.isMouseOverAnchor(data.mousePositionOnViewPortContent, anchorOnCanvas)) {
                                return index;
                            }
                        }
                        return indexUnderMouse;
                    }, null);

                    if (anchorIndex !== null) {
                        this.startExistingLabelResize(data, polygonUnderMouse.id, anchorIndex);
                    } else {
                        store.dispatch(updateActiveLabelId(polygonUnderMouse.id));
                        const isMouseOverNewAnchor: boolean = this.isMouseOverAnchor(data.mousePositionOnViewPortContent, this.suggestedAnchorPositionOnCanvas);
                        if (isMouseOverNewAnchor) {
                            this.addSuggestedAnchorToPolygonLabel(data);
                        }
                    }
                } else {
                    this.updateActivelyCreatedLabel(data);
                }
            }
        }
    }

    public mouseUpHandler(data: EditorData): void {
        if (this.isResizeInProgress())
            this.endExistingLabelResize(data);
    }

    public mouseMoveHandler(data: EditorData): void {
        if (!!data.viewPortContentImageRect && !!data.mousePositionOnViewPortContent) {
            const isOverImage: boolean = RenderEngineUtil.isMouseOverImage(data);
            if (isOverImage && !this.isCreationInProgress()) {
                const labelPolygon: LabelPolygon = this.getPolygonUnderMouse(data);
                if (!!labelPolygon && !this.isResizeInProgress()) {
                    if (LabelsSelector.getHighlightedLabelId() !== labelPolygon.id) {
                        store.dispatch(updateHighlightedLabelId(labelPolygon.id))
                    }
                    const pathOnCanvas: IPoint[] = RenderEngineUtil.transferPolygonFromImageToViewPortContent(labelPolygon.vertices, data);
                    const linesOnCanvas: ILine[] = PolygonUtil.getEdges(pathOnCanvas);

                    for (let j = 0; j < linesOnCanvas.length; j++) {
                        const mouseOverLine = RenderEngineUtil.isMouseOverLine(
                            data.mousePositionOnViewPortContent,
                            linesOnCanvas[j],
                            RenderEngineSettings.anchorHoverSize.width / 2
                        )
                        if (mouseOverLine) {
                            this.suggestedAnchorPositionOnCanvas = LineUtil.getCenter(linesOnCanvas[j]);
                            this.suggestedAnchorIndexInPolygon = j + 1;
                            break;
                        }
                    }
                } else {
                    if (LabelsSelector.getHighlightedLabelId() !== null) {
                        store.dispatch(updateHighlightedLabelId(null));
                        this.discardSuggestedPoint();
                    }
                }
            }
        }
    }

    // =================================================================================================================
    // RENDERING
    // =================================================================================================================

    public render(data: EditorData): void {
        const imageData: ImageData = LabelsSelector.getActiveImageData();
        if (imageData) {
            this.drawExistingLabels(data);
            this.drawActivelyCreatedLabel(data);
            this.drawActivelyResizeLabel(data);
            this.updateCursorStyle(data);
            this.drawSuggestedAnchor(data);
        }
    }

    private updateCursorStyle(data: EditorData) {
        if (!!this.canvas && !!data.mousePositionOnViewPortContent && !GeneralSelector.getImageDragModeStatus()) {
            const isMouseOverCanvas: boolean = RenderEngineUtil.isMouseOverCanvas(data);
            if (isMouseOverCanvas) {
                if (this.isCreationInProgress()) {
                    const isMouseOverStartAnchor: boolean = this.isMouseOverAnchor(data.mousePositionOnViewPortContent, this.activePath[0]);
                    if (isMouseOverStartAnchor && this.activePath.length > 2)
                        store.dispatch(updateCustomCursorStyle(CustomCursorStyle.CLOSE));
                    else
                        store.dispatch(updateCustomCursorStyle(CustomCursorStyle.DEFAULT));
                } else {
                    const anchorUnderMouse: IPoint = this.getAnchorUnderMouse(data);
                    const isMouseOverNewAnchor: boolean = this.isMouseOverAnchor(data.mousePositionOnViewPortContent, this.suggestedAnchorPositionOnCanvas);
                    if (!!isMouseOverNewAnchor) {
                        store.dispatch(updateCustomCursorStyle(CustomCursorStyle.ADD));
                    } else if (this.isResizeInProgress()) {
                        store.dispatch(updateCustomCursorStyle(CustomCursorStyle.MOVE));
                    } else if (!!anchorUnderMouse) {
                        store.dispatch(updateCustomCursorStyle(CustomCursorStyle.MOVE));
                    } else {
                        RenderEngineUtil.wrapDefaultCursorStyleInCancel(data);
                    }
                }
                this.canvas.style.cursor = 'none';
            } else {
                this.canvas.style.cursor = 'default';
            }
        }
    }

    private drawActivelyCreatedLabel(data: EditorData) {
        const standardizedPoints: IPoint[] = this.activePath.map((point: IPoint) => RenderEngineUtil.setPointBetweenPixels(point));
        const path = standardizedPoints.concat(data.mousePositionOnViewPortContent);
        const lines: ILine[] = PolygonUtil.getEdges(path, false);
        const lineColor: string = BaseRenderEngine.resolveLabelLineColor(null, true)
        const anchorColor: string = BaseRenderEngine.resolveLabelAnchorColor(true)
        DrawUtil.drawPolygonWithFill(this.canvas, path, DrawUtil.hexToRGB(lineColor, 0.2));
        lines.forEach((line: ILine) => {
            DrawUtil.drawLine(this.canvas, line.start, line.end, lineColor, RenderEngineSettings.LINE_THICKNESS);
        });
        standardizedPoints.forEach((point: IPoint) => {
            DrawUtil.drawCircleWithFill(this.canvas, point, Settings.RESIZE_HANDLE_DIMENSION_PX/2, anchorColor);
        })
    }

    private drawActivelyResizeLabel(data: EditorData) {
        const activeLabelPolygon: LabelPolygon = LabelsSelector.getActivePolygonLabel();
        if (!!activeLabelPolygon && this.isResizeInProgress()) {
            const snappedMousePosition: IPoint = RectUtil.snapPointToRect(data.mousePositionOnViewPortContent, data.viewPortContentImageRect);
            const polygonOnCanvas: IPoint[] = activeLabelPolygon.vertices.map((point: IPoint, index: number) => {
                return index === this.resizeAnchorIndex ? snappedMousePosition : RenderEngineUtil.transferPointFromImageToViewPortContent(point, data);
            });
            this.drawPolygon(activeLabelPolygon.labelId, polygonOnCanvas, true);
        }
    }

    private drawExistingLabels(data: EditorData) {
        const activeLabelId: string = LabelsSelector.getActiveLabelId();
        const highlightedLabelId: string = LabelsSelector.getHighlightedLabelId();
        const imageData: ImageData = LabelsSelector.getActiveImageData();
        imageData.labelPolygons.forEach((labelPolygon: LabelPolygon) => {
            if (labelPolygon.isVisible) {
                const isActive: boolean = labelPolygon.id === activeLabelId || labelPolygon.id === highlightedLabelId;
                const pathOnCanvas: IPoint[] = RenderEngineUtil.transferPolygonFromImageToViewPortContent(labelPolygon.vertices, data);
                if (!(labelPolygon.id === activeLabelId && this.isResizeInProgress())) {
                    this.drawPolygon(labelPolygon.labelId, pathOnCanvas, isActive);
                }
            }
        });
    }

    private drawPolygon(labelId: string | null, polygon: IPoint[], isActive: boolean) {
        const lineColor: string = BaseRenderEngine.resolveLabelLineColor(labelId, true)
        const anchorColor: string = BaseRenderEngine.resolveLabelAnchorColor(true)
        const standardizedPoints: IPoint[] = polygon.map((point: IPoint) => RenderEngineUtil.setPointBetweenPixels(point));
        if (isActive) {
            DrawUtil.drawPolygonWithFill(this.canvas, standardizedPoints, DrawUtil.hexToRGB(lineColor, 0.2));
        }
        DrawUtil.drawPolygon(this.canvas, standardizedPoints, lineColor, RenderEngineSettings.LINE_THICKNESS);
        if (isActive) {
            standardizedPoints.forEach((point: IPoint) => {
                DrawUtil.drawCircleWithFill(this.canvas, point, Settings.RESIZE_HANDLE_DIMENSION_PX/2, anchorColor);
            })
        }
    }

    private drawSuggestedAnchor(data: EditorData) {
        const anchorColor: string = BaseRenderEngine.resolveLabelAnchorColor(true)
        if (this.suggestedAnchorPositionOnCanvas) {
            const suggestedAnchorRect: IRect = RectUtil
                .getRectWithCenterAndSize(this.suggestedAnchorPositionOnCanvas, RenderEngineSettings.suggestedAnchorDetectionSize);
            const isMouseOverSuggestedAnchor: boolean = RectUtil.isPointInside(suggestedAnchorRect, data.mousePositionOnViewPortContent);

            if (isMouseOverSuggestedAnchor) {
                DrawUtil.drawCircleWithFill(
                    this.canvas, this.suggestedAnchorPositionOnCanvas, Settings.RESIZE_HANDLE_DIMENSION_PX/2, anchorColor);
            }
        }
    }

    // =================================================================================================================
    // CREATION
    // =================================================================================================================

    private updateActivelyCreatedLabel(data: EditorData) {
        if (this.isCreationInProgress()) {
            const mousePositionSnapped: IPoint = RectUtil.snapPointToRect(data.mousePositionOnViewPortContent, data.viewPortContentImageRect);
            this.activePath.push(mousePositionSnapped);
        } else {
            const isMouseOverImage: boolean = RectUtil.isPointInside(data.viewPortContentImageRect, data.mousePositionOnViewPortContent);
            if (isMouseOverImage) {
                EditorActions.setViewPortActionsDisabledStatus(true);
                this.activePath.push(data.mousePositionOnViewPortContent);
                store.dispatch(updateActiveLabelId(null));
            }
        }
    }

    public cancelLabelCreation() {
        this.activePath = [];
        EditorActions.setViewPortActionsDisabledStatus(false);
    }

    private finishLabelCreation() {
        this.activePath = [];
        EditorActions.setViewPortActionsDisabledStatus(false);
    }

    public addLabelAndFinishCreation(data: EditorData) {
        if (this.isCreationInProgress() && this.activePath.length > 2) {
            const polygonOnImage: IPoint[] = RenderEngineUtil.transferPolygonFromViewPortContentToImage(this.activePath, data);
            this.addPolygonLabel(polygonOnImage);
            this.finishLabelCreation();
        }
    }

    private addPolygonLabel(polygon: IPoint[]) {
        const activeLabelId = LabelsSelector.getActiveLabelNameId();
        const imageData: ImageData = LabelsSelector.getActiveImageData();
        const labelPolygon: LabelPolygon = LabelUtil.createLabelPolygon(activeLabelId, polygon);
        imageData.labelPolygons.push(labelPolygon);
        store.dispatch(updateImageDataById(imageData.id, imageData));
        store.dispatch(updateFirstLabelCreatedFlag(true));
        store.dispatch(updateActiveLabelId(labelPolygon.id));
    };

    // =================================================================================================================
    // TRANSFER
    // =================================================================================================================

    private startExistingLabelResize(data: EditorData, labelId: string, anchorIndex: number) {
        store.dispatch(updateActiveLabelId(labelId));
        this.resizeAnchorIndex = anchorIndex;
        EditorActions.setViewPortActionsDisabledStatus(true);
    }

    private endExistingLabelResize(data: EditorData) {
        this.applyResizeToPolygonLabel(data);
        this.resizeAnchorIndex = null;
        EditorActions.setViewPortActionsDisabledStatus(false);
    }

    private applyResizeToPolygonLabel(data: EditorData) {
        const imageData: ImageData = LabelsSelector.getActiveImageData();
        const activeLabel: LabelPolygon = LabelsSelector.getActivePolygonLabel();
        imageData.labelPolygons = imageData.labelPolygons.map((polygon: LabelPolygon) => {
            if (polygon.id !== activeLabel.id) {
                return polygon
            } else {
                return {
                    ...polygon,
                    vertices: polygon.vertices.map((value: IPoint, index: number) => {
                        if (index !== this.resizeAnchorIndex) {
                            return value;
                        } else {
                            const snappedMousePosition: IPoint =
                                RectUtil.snapPointToRect(data.mousePositionOnViewPortContent, data.viewPortContentImageRect);
                            return RenderEngineUtil.transferPointFromViewPortContentToImage(snappedMousePosition, data);
                        }
                    })
                }
            }
        });
        store.dispatch(updateImageDataById(imageData.id, imageData));
        store.dispatch(updateActiveLabelId(activeLabel.id));
    }

    private discardSuggestedPoint(): void {
        this.suggestedAnchorIndexInPolygon = null;
        this.suggestedAnchorPositionOnCanvas = null;
    }

    // =================================================================================================================
    // UPDATE
    // =================================================================================================================

    private addSuggestedAnchorToPolygonLabel(data: EditorData) {
        const imageData: ImageData = LabelsSelector.getActiveImageData();
        const activeLabel: LabelPolygon = LabelsSelector.getActivePolygonLabel();
        const newAnchorPositionOnImage: IPoint =
            RenderEngineUtil.transferPointFromViewPortContentToImage(this.suggestedAnchorPositionOnCanvas, data);
        const insert = (arr, index, newItem) => [...arr.slice(0, index), newItem, ...arr.slice(index)];

        const newImageData: ImageData = {
            ...imageData,
            labelPolygons: imageData.labelPolygons.map((polygon: LabelPolygon) => {
                if (polygon.id !== activeLabel.id) {
                    return polygon
                } else {
                    return {
                        ...polygon,
                        vertices: insert(polygon.vertices, this.suggestedAnchorIndexInPolygon, newAnchorPositionOnImage)
                    }
                }
            })
        };

        store.dispatch(updateImageDataById(newImageData.id, newImageData));
        this.startExistingLabelResize(data, activeLabel.id, this.suggestedAnchorIndexInPolygon);
        this.discardSuggestedPoint();
    }

    // =================================================================================================================
    // VALIDATORS
    // =================================================================================================================

    public isInProgress(): boolean {
        return this.isCreationInProgress() || this.isResizeInProgress();
    }

    private isCreationInProgress(): boolean {
        return this.activePath !== null && this.activePath.length !== 0;
    }

    private isResizeInProgress(): boolean {
        return this.resizeAnchorIndex !== null;
    }

    private isMouseOverAnchor(mouse: IPoint, anchor: IPoint): boolean {
        if (!mouse || !anchor) return null;
        return RectUtil.isPointInside(RectUtil.getRectWithCenterAndSize(anchor, RenderEngineSettings.anchorSize), mouse);
    }

    // =================================================================================================================
    // GETTERS
    // =================================================================================================================

    private getPolygonUnderMouse(data: EditorData): LabelPolygon | null {
        const mouseOnCanvas = data.mousePositionOnViewPortContent;
        if (!mouseOnCanvas) return null;

        const labelPolygons: LabelPolygon[] = LabelsSelector
            .getActiveImageData()
            .labelPolygons
            .filter((labelPolygon: LabelPolygon) => labelPolygon.isVisible);
        const radius = RenderEngineSettings.anchorHoverSize.width / 2;

        for (const labelPolygon of labelPolygons) {
            const verticesOnCanvas = RenderEngineUtil
                .transferPolygonFromImageToViewPortContent(labelPolygon.vertices, data);
            if (RenderEngineUtil.isMouseOverPolygon(mouseOnCanvas, verticesOnCanvas, radius)) {
                return labelPolygon;
            }
        }
        return null;
    }

    private getAnchorUnderMouse(data: EditorData): IPoint | null {
        const mouseOnCanvas = data.mousePositionOnViewPortContent;
        if (!mouseOnCanvas) return null;

        const labelPolygons: LabelPolygon[] = LabelsSelector
            .getActiveImageData()
            .labelPolygons
            .filter((labelPolygon: LabelPolygon) => labelPolygon.isVisible);
        const radius = RenderEngineSettings.anchorHoverSize.width / 2;

        for (const labelPolygon of labelPolygons) {
            const verticesOnCanvas = RenderEngineUtil
                .transferPolygonFromImageToViewPortContent(labelPolygon.vertices, data);
            for (const vertexOnCanvas of verticesOnCanvas) {
                if (RenderEngineUtil.isMouseOverAnchor(mouseOnCanvas, vertexOnCanvas, radius)) return vertexOnCanvas;
            }
        }
        return null;
    }
}

```

Path: src/logic/render/PrimaryEditorRenderEngine.ts
```ts
import {IRect} from '../../interfaces/IRect';
import {BaseRenderEngine} from './BaseRenderEngine';
import {EditorData} from '../../data/EditorData';
import {EditorModel} from '../../staticModels/EditorModel';
import {ViewPortActions} from '../actions/ViewPortActions';
import {DrawUtil} from '../../utils/DrawUtil';
import {RenderEngineUtil} from '../../utils/RenderEngineUtil';
import {RenderEngineSettings} from '../../settings/RenderEngineSettings';
import {IPoint} from '../../interfaces/IPoint';
import {GeneralSelector} from '../../store/selectors/GeneralSelector';
import {ProjectType} from '../../data/enums/ProjectType';
import {PopupWindowType} from '../../data/enums/PopupWindowType';

export class PrimaryEditorRenderEngine extends BaseRenderEngine {

    public constructor(canvas: HTMLCanvasElement) {
        super(canvas);
    }

    // =================================================================================================================
    // EVENT HANDLERS
    // =================================================================================================================

    public mouseMoveHandler(data: EditorData): void {}
    public mouseDownHandler(data: EditorData): void {}
    public mouseUpHandler(data: EditorData): void {}

    // =================================================================================================================
    // RENDERING
    // =================================================================================================================

    public render(data: EditorData): void {
        this.drawImage(EditorModel.image, ViewPortActions.calculateViewPortContentImageRect());
        this.renderCrossHair(data);
    }

    public renderCrossHair(data: EditorData): void {
        if (!this.shouldRenderCrossHair(data)) return;

        const mouse = RenderEngineUtil.setPointBetweenPixels(data.mousePositionOnViewPortContent);
        const drawLine = (startPoint: IPoint, endPoint: IPoint) => {
            DrawUtil.drawLine(this.canvas, startPoint, endPoint, RenderEngineSettings.CROSS_HAIR_LINE_COLOR, 2)
        }
        drawLine(
            {x: mouse.x, y: 0},
            {x: mouse.x - 1, y: mouse.y - RenderEngineSettings.crossHairPadding}
        )
        drawLine(
            {x: mouse.x, y: mouse.y + RenderEngineSettings.crossHairPadding},
            {x: mouse.x - 1, y: data.viewPortContentSize.height}
        )
        drawLine(
            {x: 0, y: mouse.y},
            {x: mouse.x - RenderEngineSettings.crossHairPadding, y: mouse.y - 1}
        )
        drawLine(
            {x: mouse.x + RenderEngineSettings.crossHairPadding, y: mouse.y},
            {x: data.viewPortContentSize.width, y: mouse.y - 1}
        )
    }

    public shouldRenderCrossHair(data: EditorData): boolean {
        const isCrossHairVisible = GeneralSelector.getCrossHairVisibleStatus();
        const isImageInDragMode = GeneralSelector.getImageDragModeStatus();
        const projectType: ProjectType = GeneralSelector.getProjectType();
        const activePopupType: PopupWindowType = GeneralSelector.getActivePopupType();
        const isMouseOverCanvas: boolean = RenderEngineUtil.isMouseOverCanvas(data);
        const isCustomCursorBlocked =  GeneralSelector.getPreventCustomCursorStatus();

        return [
            !!this.canvas,
            isCrossHairVisible,
            !isImageInDragMode,
            projectType !== ProjectType.IMAGE_RECOGNITION,
            !activePopupType,
            isMouseOverCanvas,
            !isCustomCursorBlocked
        ].every(Boolean)
    }

    public drawImage(image: HTMLImageElement, imageRect: IRect) {
        if (!!image && !!this.canvas) {
            const ctx = this.canvas.getContext('2d');
            ctx.drawImage(image, imageRect.x, imageRect.y, imageRect.width, imageRect.height);
        }
    }

    isInProgress(): boolean {
        return false;
    }
}

```

Path: src/logic/render/RectRenderEngine.ts
```ts
import {IPoint} from '../../interfaces/IPoint';
import {IRect} from '../../interfaces/IRect';
import {RectUtil} from '../../utils/RectUtil';
import {DrawUtil} from '../../utils/DrawUtil';
import {store} from '../..';
import {ImageData, LabelRect} from '../../store/labels/types';
import {
    updateActiveLabelId,
    updateFirstLabelCreatedFlag,
    updateHighlightedLabelId,
    updateImageDataById
} from '../../store/labels/actionCreators';
import {PointUtil} from '../../utils/PointUtil';
import {RectAnchor} from '../../data/RectAnchor';
import {RenderEngineSettings} from '../../settings/RenderEngineSettings';
import {updateCustomCursorStyle} from '../../store/general/actionCreators';
import {CustomCursorStyle} from '../../data/enums/CustomCursorStyle';
import {LabelsSelector} from '../../store/selectors/LabelsSelector';
import {EditorData} from '../../data/EditorData';
import {BaseRenderEngine} from './BaseRenderEngine';
import {RenderEngineUtil} from '../../utils/RenderEngineUtil';
import {LabelType} from '../../data/enums/LabelType';
import {EditorActions} from '../actions/EditorActions';
import {GeneralSelector} from '../../store/selectors/GeneralSelector';
import {LabelStatus} from '../../data/enums/LabelStatus';
import {LabelUtil} from '../../utils/LabelUtil';

export class RectRenderEngine extends BaseRenderEngine {

    // =================================================================================================================
    // STATE
    // =================================================================================================================

    private startCreateRectPoint: IPoint;
    private startResizeRectAnchor: RectAnchor;

    public constructor(canvas: HTMLCanvasElement) {
        super(canvas);
        this.labelType = LabelType.RECT;
    }

    // =================================================================================================================
    // EVENT HANDLERS
    // =================================================================================================================

    public mouseDownHandler = (data: EditorData) => {
        const isMouseOverImage: boolean = RenderEngineUtil.isMouseOverImage(data);
        const isMouseOverCanvas: boolean = RenderEngineUtil.isMouseOverCanvas(data);
        if (isMouseOverCanvas) {
            const rectUnderMouse: LabelRect = this.getRectUnderMouse(data);
            if (!!rectUnderMouse) {
                const rect: IRect = this.calculateRectRelativeToActiveImage(rectUnderMouse.rect, data);
                const anchorUnderMouse: RectAnchor = this.getAnchorUnderMouseByRect(rect, data.mousePositionOnViewPortContent, data.viewPortContentImageRect);
                if (!!anchorUnderMouse && rectUnderMouse.status === LabelStatus.ACCEPTED) {
                    store.dispatch(updateActiveLabelId(rectUnderMouse.id));
                    this.startRectResize(anchorUnderMouse);
                } else {
                    if (!!LabelsSelector.getHighlightedLabelId())
                        store.dispatch(updateActiveLabelId(LabelsSelector.getHighlightedLabelId()));
                    else
                        this.startRectCreation(data.mousePositionOnViewPortContent);
                }
            } else if (isMouseOverImage) {

                this.startRectCreation(data.mousePositionOnViewPortContent);
            }
        }
    };

    public mouseUpHandler = (data: EditorData) => {
        if (!!data.viewPortContentImageRect) {
            const mousePositionSnapped: IPoint = RectUtil.snapPointToRect(data.mousePositionOnViewPortContent, data.viewPortContentImageRect);
            const activeLabelRect: LabelRect = LabelsSelector.getActiveRectLabel();

            if (!!this.startCreateRectPoint && !PointUtil.equals(this.startCreateRectPoint, mousePositionSnapped)) {

                const minX: number = Math.min(this.startCreateRectPoint.x, mousePositionSnapped.x);
                const minY: number = Math.min(this.startCreateRectPoint.y, mousePositionSnapped.y);
                const maxX: number = Math.max(this.startCreateRectPoint.x, mousePositionSnapped.x);
                const maxY: number = Math.max(this.startCreateRectPoint.y, mousePositionSnapped.y);

                const rect = {x: minX, y: minY, width: maxX - minX, height: maxY - minY};
                this.addRectLabel(RenderEngineUtil.transferRectFromImageToViewPortContent(rect, data));
            }

            if (!!this.startResizeRectAnchor && !!activeLabelRect) {
                const rect: IRect = this.calculateRectRelativeToActiveImage(activeLabelRect.rect, data);
                const startAnchorPosition: IPoint = PointUtil.add(this.startResizeRectAnchor.position,
                    data.viewPortContentImageRect);
                const delta: IPoint = PointUtil.subtract(mousePositionSnapped, startAnchorPosition);
                const resizeRect: IRect = RectUtil.resizeRect(rect, this.startResizeRectAnchor.type, delta);
                const scale: number = RenderEngineUtil.calculateImageScale(data);
                const scaledRect: IRect = RectUtil.scaleRect(resizeRect, scale);

                const imageData = LabelsSelector.getActiveImageData();
                imageData.labelRects = imageData.labelRects.map((labelRect: LabelRect) => {
                    if (labelRect.id === activeLabelRect.id) {
                        return {
                            ...labelRect,
                            rect: scaledRect
                        };
                    }
                    return labelRect;
                });
                store.dispatch(updateImageDataById(imageData.id, imageData));
            }
        }
        this.endRectTransformation()
    };

    public mouseMoveHandler = (data: EditorData) => {
        if (!!data.viewPortContentImageRect && !!data.mousePositionOnViewPortContent) {
            const isOverImage: boolean = RenderEngineUtil.isMouseOverImage(data);
            if (isOverImage && !this.startResizeRectAnchor) {
                const labelRect: LabelRect = this.getRectUnderMouse(data);
                if (!!labelRect && !this.isInProgress()) {
                    if (LabelsSelector.getHighlightedLabelId() !== labelRect.id) {
                        store.dispatch(updateHighlightedLabelId(labelRect.id))
                    }
                } else {
                    if (LabelsSelector.getHighlightedLabelId() !== null) {
                        store.dispatch(updateHighlightedLabelId(null))
                    }
                }
            }
        }
    };

    // =================================================================================================================
    // RENDERING
    // =================================================================================================================

    public render(data: EditorData) {
        const activeLabelId: string = LabelsSelector.getActiveLabelId();
        const imageData: ImageData = LabelsSelector.getActiveImageData();
        if (imageData) {
            imageData.labelRects.forEach((labelRect: LabelRect) => {
                if (labelRect.isVisible) {
                    if (labelRect.status === LabelStatus.ACCEPTED && labelRect.id === activeLabelId) {
                        this.drawActiveRect(labelRect, data)
                    } else {
                        this.drawInactiveRect(labelRect, data);
                    }
                }
            });
            this.drawCurrentlyCreatedRect(data.mousePositionOnViewPortContent, data.viewPortContentImageRect);
            this.updateCursorStyle(data);
        }
    }

    private drawCurrentlyCreatedRect(mousePosition: IPoint, imageRect: IRect) {
        if (!!this.startCreateRectPoint) {
            const mousePositionSnapped: IPoint = RectUtil.snapPointToRect(mousePosition, imageRect);
            const activeRect: IRect = {
                x: this.startCreateRectPoint.x,
                y: this.startCreateRectPoint.y,
                width: mousePositionSnapped.x - this.startCreateRectPoint.x,
                height: mousePositionSnapped.y - this.startCreateRectPoint.y
            };
            const activeRectBetweenPixels = RenderEngineUtil.setRectBetweenPixels(activeRect);
            const lineColor: string = BaseRenderEngine.resolveLabelLineColor(null, true)
            DrawUtil.drawRect(this.canvas, activeRectBetweenPixels, lineColor, RenderEngineSettings.LINE_THICKNESS);
        }
    }

    private drawInactiveRect(labelRect: LabelRect, data: EditorData) {
        const rectOnImage: IRect = RenderEngineUtil.transferRectFromViewPortContentToImage(labelRect.rect, data)
        const highlightedLabelId: string = LabelsSelector.getHighlightedLabelId()
        const displayAsActive: boolean = labelRect.status === LabelStatus.ACCEPTED && labelRect.id === highlightedLabelId;
        const lineColor: string = BaseRenderEngine.resolveLabelLineColor(labelRect.labelId, displayAsActive)
        const anchorColor: string = BaseRenderEngine.resolveLabelAnchorColor(displayAsActive);
        this.renderRect(rectOnImage, displayAsActive, lineColor, anchorColor);
    }

    private drawActiveRect(labelRect: LabelRect, data: EditorData) {
        let rect: IRect = this.calculateRectRelativeToActiveImage(labelRect.rect, data);
        if (!!this.startResizeRectAnchor) {
            const startAnchorPosition: IPoint = PointUtil.add(this.startResizeRectAnchor.position, data.viewPortContentImageRect);
            const endAnchorPositionSnapped: IPoint = RectUtil.snapPointToRect(data.mousePositionOnViewPortContent, data.viewPortContentImageRect);
            const delta = PointUtil.subtract(endAnchorPositionSnapped, startAnchorPosition);
            rect = RectUtil.resizeRect(rect, this.startResizeRectAnchor.type, delta);
        }
        const rectOnImage: IRect = RectUtil.translate(rect, data.viewPortContentImageRect);
        const lineColor: string = BaseRenderEngine.resolveLabelLineColor(labelRect.labelId, true)
        const anchorColor: string = BaseRenderEngine.resolveLabelAnchorColor(true);
        this.renderRect(rectOnImage, true, lineColor, anchorColor);
    }

    private renderRect(rectOnImage: IRect, isActive: boolean, lineColor: string, anchorColor: string) {
        const rectBetweenPixels = RenderEngineUtil.setRectBetweenPixels(rectOnImage);
        DrawUtil.drawRectWithFill(this.canvas, rectBetweenPixels, DrawUtil.hexToRGB(lineColor, 0.2));
        DrawUtil.drawRect(this.canvas, rectBetweenPixels, lineColor, RenderEngineSettings.LINE_THICKNESS);
        if (isActive) {
            const handleCenters: IPoint[] = RectUtil.mapRectToAnchors(rectOnImage).map((rectAnchor: RectAnchor) => rectAnchor.position);
            handleCenters.forEach((center: IPoint) => {
                const handleRect: IRect = RectUtil.getRectWithCenterAndSize(center, RenderEngineSettings.anchorSize);
                const handleRectBetweenPixels: IRect = RenderEngineUtil.setRectBetweenPixels(handleRect);
                DrawUtil.drawRectWithFill(this.canvas, handleRectBetweenPixels, anchorColor);
            })
        }
    }

    private updateCursorStyle(data: EditorData) {
        if (!!this.canvas && !!data.mousePositionOnViewPortContent && !GeneralSelector.getImageDragModeStatus()) {
            const rectUnderMouse: LabelRect = this.getRectUnderMouse(data);
            const rectAnchorUnderMouse: RectAnchor = this.getAnchorUnderMouse(data);
            if ((!!rectAnchorUnderMouse && rectUnderMouse && rectUnderMouse.status === LabelStatus.ACCEPTED) || !!this.startResizeRectAnchor) {
                store.dispatch(updateCustomCursorStyle(CustomCursorStyle.MOVE));
                return;
            }
            else if (RenderEngineUtil.isMouseOverCanvas(data)) {
                if (!RenderEngineUtil.isMouseOverImage(data) && !!this.startCreateRectPoint)
                    store.dispatch(updateCustomCursorStyle(CustomCursorStyle.MOVE));
                else
                    RenderEngineUtil.wrapDefaultCursorStyleInCancel(data);
                this.canvas.style.cursor = 'none';
            } else {
                this.canvas.style.cursor = 'default';
            }
        }
    }

    // =================================================================================================================
    // HELPERS
    // =================================================================================================================

    public isInProgress(): boolean {
        return !!this.startCreateRectPoint || !!this.startResizeRectAnchor;
    }

    private calculateRectRelativeToActiveImage(rect: IRect, data: EditorData):IRect {
        const scale: number = RenderEngineUtil.calculateImageScale(data);
        return RectUtil.scaleRect(rect, 1/scale);
    }

    private addRectLabel = (rect: IRect) => {
        const activeLabelId = LabelsSelector.getActiveLabelNameId();
        const imageData: ImageData = LabelsSelector.getActiveImageData();
        const labelRect: LabelRect = LabelUtil.createLabelRect(activeLabelId, rect);
        imageData.labelRects.push(labelRect);
        store.dispatch(updateImageDataById(imageData.id, imageData));
        store.dispatch(updateFirstLabelCreatedFlag(true));
        store.dispatch(updateActiveLabelId(labelRect.id));
    };

    private getRectUnderMouse(data: EditorData): LabelRect {
        const activeRectLabel: LabelRect = LabelsSelector.getActiveRectLabel();
        if (!!activeRectLabel && activeRectLabel.isVisible && this.isMouseOverRectEdges(activeRectLabel.rect, data)) {
            return activeRectLabel;
        }

        const labelRects: LabelRect[] = LabelsSelector.getActiveImageData().labelRects;
        for (const labelRect of labelRects) {
            if (labelRect.isVisible && this.isMouseOverRectEdges(labelRect.rect, data)) {
                return labelRect;
            }
        }
        return null;
    }

    private isMouseOverRectEdges(rect: IRect, data: EditorData): boolean {
        const rectOnImage: IRect = RectUtil.translate(
            this.calculateRectRelativeToActiveImage(rect, data), data.viewPortContentImageRect);

        const outerRectDelta: IPoint = {
            x: RenderEngineSettings.anchorHoverSize.width / 2,
            y: RenderEngineSettings.anchorHoverSize.height / 2
        };
        const outerRect: IRect = RectUtil.expand(rectOnImage, outerRectDelta);

        const innerRectDelta: IPoint = {
            x: - RenderEngineSettings.anchorHoverSize.width / 2,
            y: - RenderEngineSettings.anchorHoverSize.height / 2
        };
        const innerRect: IRect = RectUtil.expand(rectOnImage, innerRectDelta);

        return (RectUtil.isPointInside(outerRect, data.mousePositionOnViewPortContent) &&
            !RectUtil.isPointInside(innerRect, data.mousePositionOnViewPortContent));
    }

    private getAnchorUnderMouseByRect(rect: IRect, mousePosition: IPoint, imageRect: IRect): RectAnchor {
        const rectAnchors: RectAnchor[] = RectUtil.mapRectToAnchors(rect);
        for (let i = 0; i < rectAnchors.length; i++) {
            const anchorRect: IRect = RectUtil.translate(RectUtil.getRectWithCenterAndSize(rectAnchors[i].position, RenderEngineSettings.anchorHoverSize), imageRect);
            if (!!mousePosition && RectUtil.isPointInside(anchorRect, mousePosition)) {
                return rectAnchors[i];
            }
        }
        return null;
    }

    private getAnchorUnderMouse(data: EditorData): RectAnchor {
        const labelRects: LabelRect[] = LabelsSelector.getActiveImageData().labelRects;
        for (let i = 0; i < labelRects.length; i++) {
            const rect: IRect = this.calculateRectRelativeToActiveImage(labelRects[i].rect, data);
            const rectAnchor = this.getAnchorUnderMouseByRect(rect, data.mousePositionOnViewPortContent, data.viewPortContentImageRect);
            if (!!rectAnchor) return rectAnchor;
        }
        return null;
    }

    private startRectCreation(mousePosition: IPoint) {
        this.startCreateRectPoint = mousePosition;
        store.dispatch(updateActiveLabelId(null));
        EditorActions.setViewPortActionsDisabledStatus(true);
    }

    private startRectResize(activatedAnchor: RectAnchor) {
        this.startResizeRectAnchor = activatedAnchor;
        EditorActions.setViewPortActionsDisabledStatus(true);
    }

    private endRectTransformation() {
        this.startCreateRectPoint = null;
        this.startResizeRectAnchor = null;
        EditorActions.setViewPortActionsDisabledStatus(false);
    }
}

```

Path: src/logic/__tests__/actions/AIActions.test.ts
```ts
import {AIActions} from "../../actions/AIActions";

describe('AIActions excludeRejectedLabelNames method', () => {
    it('should return list with correct values', () => {
        // GIVEN
        const suggestedLabels: string[] = [
            "label_1",
            "label_2",
            "label_3",
            "label_4",
        ];

        const rejectedLabels: string[] = [
            "label_3",
            "label_4",
            "label_5",
        ];

        // WHEN
        const excludedLabels: string[] = AIActions.excludeRejectedLabelNames(suggestedLabels, rejectedLabels);

        // THEN
        const expectedLabels: string[] = [
            "label_1",
            "label_2",
        ];
        expect(excludedLabels.toString()).toBe(expectedLabels.toString());
    });
});
```

Path: src/logic/__tests__/actions/AIObjectDetectionActions.test.ts
```ts

import {LabelName} from '../../../store/labels/types';
import {DetectedObject} from '@tensorflow-models/coco-ssd';
import {AISSDObjectDetectionActions} from '../../actions/AISSDObjectDetectionActions';

describe('AIObjectDetectionActions extractNewSuggestedLabelNames method', () => {
    const mockLabelNames: LabelName[] = [
        {
            id: 'id_1',
            name: 'label_1',
            color: '#000000'
        },
        {
            id: 'id_2',
            name: 'label_2',
            color: '#000000'
        },
        {
            id: 'id_3',
            name: 'label_3',
            color: '#000000'
        }
    ];

    it('should return list with correct values', () => {
        // GIVEN
        const labelNames: LabelName[] = mockLabelNames;
        const predictions: DetectedObject[] = [
            {
                bbox: [1, 2, 3 , 4],
                class: 'label_3',
                score: 0
            },
            {
                bbox: [1, 2, 3 , 4],
                class: 'label_4',
                score: 0
            },
            {
                bbox: [1, 2, 3 , 4],
                class: 'label_5',
                score: 0
            }
        ];

        // WHEN
        const suggestedLabels: string[] = AISSDObjectDetectionActions
            .extractNewSuggestedLabelNames(labelNames, predictions);

        // THEN
        expect(suggestedLabels.toString()).toBe(['label_4', 'label_5'].toString());
    });

    it('should return empty list', () => {
        // GIVEN
        const labelNames: LabelName[] = mockLabelNames;
        const predictions: DetectedObject[] = [
            {
                bbox: [1, 2, 3 , 4],
                class: 'label_3',
                score: 0
            },
            {
                bbox: [1, 2, 3 , 4],
                class: 'label_1',
                score: 0
            }
        ];

        // WHEN
        const suggestedLabels: string[] = AISSDObjectDetectionActions
            .extractNewSuggestedLabelNames(labelNames, predictions);

        // THEN
        expect(suggestedLabels.toString()).toBe([].toString());
    });
});

```

Path: src/logic/__tests__/export/RectLabelExport.test.ts
```ts

import {LabelName, LabelRect} from '../../../store/labels/types';
import {LabelStatus} from '../../../data/enums/LabelStatus';
import {ISize} from '../../../interfaces/ISize';
import {RectLabelsExporter} from '../../export/RectLabelsExporter';

const imageSize: ISize = {
    width: 1920,
    height: 1080
}
const labelNames: LabelName[] = [
    {
        id: 'label-000',
        name: 'label-name-000',
        color: '#000000'
    },
    {
        id: 'label-001',
        name: 'label-name-001',
        color: '#000000'
    },
    {
        id: 'label-002',
        name: 'label-name-002',
        color: '#000000'
    },
    {
        id: 'label-003',
        name: 'label-name-003',
        color: '#000000'
    },
]
const imageName: string = 'image-name.png'

describe('RectLabelsExporter wrapRectLabelIntoYOLO method', () => {
    it('should produce correct single label entry given issue #171 example 1', () => {
        // given
        const labelRect: LabelRect = {
            id: 'label-rect-000',
            labelId: 'label-002',
            rect: {
                x: 444,
                y: 998,
                width: 90,
                height: 82
            },
            isVisible: true,
            isCreatedByAI: false,
            status: LabelStatus.ACCEPTED,
            suggestedLabel: 'label-000'
        }

        // when
        const result = RectLabelsExporter.wrapRectLabelIntoYOLO(labelRect, labelNames, imageSize)

        // then
        const [
            resultClassIdx,
            resultX,
            resultY,
            resultWidth,
            resultHeight
        ] = result.split(' ').map((value: string) => parseFloat(value))
        expect(resultClassIdx).toBe(2)
        expect(resultX + resultWidth / 2 <= 1).toBeTruthy()
        expect(resultX - resultWidth / 2 >= 0).toBeTruthy()
        expect(resultY + resultHeight / 2 <= 1).toBeTruthy()
        expect(resultY - resultHeight / 2 >= 0).toBeTruthy()
    })

    it('should produce correct single label entry given issue #171 example 2', () => {
        // given
        const labelRect: LabelRect = {
            id: 'label-rect-000',
            labelId: 'label-002',
            rect: {
                x: 1828,
                y: 710,
                width: 92,
                height: 104
            },
            isVisible: true,
            isCreatedByAI: false,
            status: LabelStatus.ACCEPTED,
            suggestedLabel: 'label-000'
        }

        // when
        const result = RectLabelsExporter.wrapRectLabelIntoYOLO(labelRect, labelNames, imageSize)

        // then
        const [
            resultClassIdx,
            resultX,
            resultY,
            resultWidth,
            resultHeight
        ] = result.split(' ').map((value: string) => parseFloat(value))
        expect(resultClassIdx).toBe(2)
        expect(resultX + resultWidth / 2 <= 1).toBeTruthy()
        expect(resultX - resultWidth / 2 >= 0).toBeTruthy()
        expect(resultY + resultHeight / 2 <= 1).toBeTruthy()
        expect(resultY - resultHeight / 2 >= 0).toBeTruthy()
    })

    it('should produce correct single label entry given issue #171 example 3', () => {
        // given
        const labelRect: LabelRect = {
            id: 'label-rect-000',
            labelId: 'label-002',
            rect: {
                x: 0,
                y: 138,
                width: 80,
                height: 70
            },
            isVisible: true,
            isCreatedByAI: false,
            status: LabelStatus.ACCEPTED,
            suggestedLabel: 'label-000'
        }

        // when
        const result = RectLabelsExporter.wrapRectLabelIntoYOLO(labelRect, labelNames, imageSize)

        // then
        const [
            resultClassIdx,
            resultX,
            resultY,
            resultWidth,
            resultHeight
        ] = result.split(' ').map((value: string) => parseFloat(value))
        expect(resultClassIdx).toBe(2)
        expect(resultX + resultWidth / 2 <= 1).toBeTruthy()
        expect(resultX - resultWidth / 2 >= 0).toBeTruthy()
        expect(resultY + resultHeight / 2 <= 1).toBeTruthy()
        expect(resultY - resultHeight / 2 >= 0).toBeTruthy()
    })
})

describe('RectLabelsExporter wrapRectLabelIntoCSV method', () => {
    it('should produce correct single label', () => {
        // given
        const labelRect: LabelRect = {
            id: 'label-rect-000',
            labelId: 'label-002',
            rect: {
                x: 444,
                y: 998,
                width: 90,
                height: 82
            },
            isVisible: true,
            isCreatedByAI: false,
            status: LabelStatus.ACCEPTED,
            suggestedLabel: 'label-000'
        }

        // when
        const result = RectLabelsExporter.wrapRectLabelIntoCSV(labelRect, labelNames, imageSize, imageName)

        // then
        const [
            resultClassIdx,
            resultBoxX,
            resultBoxY,
            resultBoxWidth,
            resultBoxHeight,
            resultImageName,
            resultImageWidth,
            resultImageHeight,
        ] = result.split(',')
        expect(resultClassIdx).toBe('label-name-002')
        expect(parseFloat(resultBoxX)).toBe(444)
        expect(parseFloat(resultBoxY)).toBe(998)
        expect(parseFloat(resultBoxWidth)).toBe(90)
        expect(parseFloat(resultBoxHeight)).toBe(82)
        expect(resultImageName).toBe(imageName)
        expect(parseFloat(resultImageWidth)).toBe(1920)
        expect(parseFloat(resultImageHeight)).toBe(1080)
    })
})

```

Path: src/logic/__tests__/export/polygon/COCOExporter.test.ts
```ts

import { COCOCategory, COCOInfo } from "../../../../data/labels/COCO";
import { COCOExporter } from "../../../export/polygon/COCOExporter";
import { LabelName } from "../../../../store/labels/types";

describe('COCOExporter produces correct COCO label', () => {
    it('should produce correct info component', () => {
        const givenDescription = "lorem ipsum";
        const expectedCOCOInfo: COCOInfo = {
            "description": "lorem ipsum"
        };
        expect(COCOExporter.getInfoComponent(givenDescription)).toEqual(expectedCOCOInfo);
    });

    it('should produce correct categories component', () => {
        const givenLabelNames: LabelName[] = [
            {
                "id": "id_1",
                "name": "label_1"
            },
            {
                "id": "id_2",
                "name": "label_2"
            },
            {
                "id": "id_3",
                "name": "label_3"
            }
        ];
        const expectedCOCOCategories: COCOCategory[] = [
            {
                "id": 1,
                "name": "label_1"
            },
            {
                "id": 2,
                "name": "label_2"
            },
            {
                "id": 3,
                "name": "label_3"
            }
        ];
        expect(COCOExporter.getCategoriesComponent(givenLabelNames)).toEqual(expectedCOCOCategories);
    });
});
```

Path: src/logic/__tests__/export/polygon/VGGExporter.test.ts
```ts
import {IPoint} from '../../../../interfaces/IPoint';
import {VGGPolygon, VGGRegionsData} from '../../../../data/labels/VGG';
import {ImageData, LabelName} from '../../../../store/labels/types';
import {VGGExporter} from '../../../export/polygon/VGGExporter';

describe('VGGExporter mapPolygonToVGG method', () => {
    it('should return correct VGGPolygon object', () => {
        const givenPath: src/IPoint[] = [
            {x: 1, y: 1},
            {x: 5, y: 1},
            {x: 6, y: 10},
            {x: 0, y: 10},
        ];

        const expectedPolygon: VGGPolygon = {
            name: 'polygon',
            all_points_x: [1, 5, 6, 0, 1],
            all_points_y: [1, 1, 10, 10, 1]
        };
        expect(VGGExporter.mapPolygonToVGG(givenPath)).toEqual(expectedPolygon);
    });

    it('should return null', () => {
        const givenPath: src/IPoint[] = [];
        expect(VGGExporter.mapPolygonToVGG(givenPath)).toBeNull();
    });
});

describe('VGGExporter mapImageDataToVGG method', () => {
    it('should return null', () => {
        const givenImageData: ImageData = {
            id: '1',
            loadStatus: false,
            labelPoints: [],
            labelRects: [],
            labelPolygons: [],
            labelLines: [],
            labelNameIds: [],
            fileData: {} as File,
            isVisitedByYOLOObjectDetector: false,
            isVisitedBySSDObjectDetector: false,
            isVisitedByPoseDetector: true,
            isVisitedByRoboflowAPI: false
        };
        expect(VGGExporter.mapImageDataToVGG(givenImageData, [])).toBeNull();
    });

    it('should return valid VGGRegionsData', () => {
        const givenImageData: ImageData = {
            id: '1',
            loadStatus: true,
            labelPoints: [],
            labelRects: [],
            labelPolygons: [
                {
                    id: '1',
                    labelId: 'label_1',
                    vertices: [
                        {x: 1, y: 1},
                        {x: 5, y: 1},
                        {x: 6, y: 10},
                        {x: 0, y: 10}
                    ],
                    isVisible: true
                },
                {
                    id: '2',
                    labelId: 'label_2',
                    vertices: [
                        {x: 1, y: 1},
                        {x: 5, y: 1},
                        {x: 6, y: 10},
                        {x: 10, y: 10},
                        {x: 0, y: 10}
                    ],
                    isVisible: true
                }
            ],
            labelLines: [],
            labelNameIds: [],
            fileData: {} as File,
            isVisitedByYOLOObjectDetector: false,
            isVisitedBySSDObjectDetector: false,
            isVisitedByPoseDetector: true,
            isVisitedByRoboflowAPI: false
        };

        const givenLabelNames: LabelName[] = [
            {
                id: 'label_1',
                name: 'banana',
                color: '#ffffff'
            },
            {
                id: 'label_2',
                name: 'kiwi',
                color: '#ffffff'
            }
        ];

        const expectedVGGRegionData: VGGRegionsData = {
            '0': {
                shape_attributes: {
                    name: 'polygon',
                    all_points_x: [1, 5, 6, 0, 1],
                    all_points_y: [1, 1, 10, 10, 1]
                },
                region_attributes: {
                    label: 'banana'
                }
            },
            '1': {
                shape_attributes: {
                    name: 'polygon',
                    all_points_x: [1, 5, 6, 10, 0, 1],
                    all_points_y: [1, 1, 10, 10, 10, 1]
                },
                region_attributes: {
                    label: 'kiwi'
                }
            }
        };
        expect(VGGExporter.mapImageDataToVGG(givenImageData, givenLabelNames)).toEqual(expectedVGGRegionData);
    });

    it('should return valid VGGRegionsData', () => {
        const givenImageData: ImageData = {
            id: '1',
            loadStatus: true,
            labelPoints: [],
            labelRects: [],
            labelPolygons: [
                {
                    id: '1',
                    labelId: 'label_1',
                    vertices: [
                        {x: 1, y: 1},
                        {x: 5, y: 1},
                        {x: 6, y: 10},
                        {x: 0, y: 10}
                    ],
                    isVisible: true
                },
                {
                    id: '2',
                    labelId: null,
                    vertices: [
                        {x: 1, y: 1},
                        {x: 5, y: 1},
                        {x: 6, y: 10},
                        {x: 10, y: 10},
                        {x: 0, y: 10}
                    ],
                    isVisible: true
                }
            ],
            labelLines: [],
            labelNameIds: [],
            fileData: {} as File,
            isVisitedByYOLOObjectDetector: false,
            isVisitedBySSDObjectDetector: false,
            isVisitedByPoseDetector: true,
            isVisitedByRoboflowAPI: false
        };

        const givenLabelNames: LabelName[] = [
            {
                id: 'label_1',
                name: 'banana',
                color: '#ffffff'
            },
            {
                id: 'label_2',
                name: 'kiwi',
                color: '#ffffff'
            }
        ];

        const expectedVGGRegionData: VGGRegionsData = {
            '0': {
                shape_attributes: {
                    name: 'polygon',
                    all_points_x: [1, 5, 6, 0, 1],
                    all_points_y: [1, 1, 10, 10, 1]
                },
                region_attributes: {
                    label: 'banana'
                }
            }
        };
        expect(VGGExporter.mapImageDataToVGG(givenImageData, givenLabelNames)).toEqual(expectedVGGRegionData);
    });
});

```

Path: src/logic/__tests__/import/coco/COCOUtils.tests.ts
```ts
import {COCOUtils} from "../../../import/coco/COCOUtils";
import {isEqual} from "lodash";

describe('COCOUtils bbox2rect method', () => {
    it('should return valid IRect', () => {
        // given
        const x = 10, y = 20, width= 30, height = 40;
        const bbox: [number, number, number, number] = [x, y, width, height]

        // when
        const result = COCOUtils.bbox2rect(bbox);

        // then
        const expectedResult = {
            x: x,
            y: y,
            width: width,
            height: height
        }
        expect(result).toEqual(expectedResult);
    });
});

describe('COCOUtils segmentation2vertices method', () => {
    it('should return valid array of polygon vertices', () => {
        // given
        const p1x = 10, p1y = 20, p2x = 30, p2y = 40, p3x = 50, p3y = 60;
        const segmentation: number[][] = [[p1x, p1y, p2x, p2y, p3x, p3y]];

        // when
        const result = COCOUtils.segmentation2vertices(segmentation);

        // then
        const expectedResult = [[
            {x: p1x, y: p1y},
            {x: p2x, y: p2y},
            {x: p3x, y: p3y}
        ]]
        expect(isEqual(result, expectedResult)).toBe(true);
    });
});
```

Path: src/logic/__tests__/import/voc/VOCImporter.tests.ts
```ts

import { ImageData, LabelName, LabelRect} from '../../../../store/labels/types';
import { AcceptedFileType } from '../../../../data/enums/AcceptedFileType';
import { v4 as uuidv4 } from 'uuid';
import { VOCImporter } from '../../../import/voc/VOCImporter';
import { isEqual } from 'lodash';

const getDummyImageData = (fileName: string): ImageData => {
    return {
        id: uuidv4(),
        fileData: new File([''], fileName, { type: AcceptedFileType.IMAGE }),
        loadStatus: true,
        labelRects: [],
        labelPoints: [],
        labelLines: [],
        labelPolygons: [],
        labelNameIds: [],
        isVisitedByYOLOObjectDetector: false,
        isVisitedBySSDObjectDetector: false,
        isVisitedByPoseDetector: false,
        isVisitedByRoboflowAPI: false
    };
};

const getDummyFileData = (fileName: string): File => {
    return new File([''], fileName, { type: AcceptedFileType.TEXT });
};

class TestableVOCImporter extends VOCImporter {
    public static testableParseAnnotationsFromFileString(document: Document, labelNames: Record<string, LabelName>)
    :[LabelRect[], Record<string, LabelName>] {
        return TestableVOCImporter.parseAnnotationsFromFileString(document, labelNames);
    }
}

const parser = new DOMParser();
const validTestDocument = parser.parseFromString(
    `
    <annotation>
        <filename>test1.jpeg</filename>
        <path>\\some-test-path\\test1.jpeg</path>
        <size>
            <width>100</width>
            <height>200</height>
            <depth>3</depth>
        </size>
        <segmented>0</segmented>
        <object>
            <name>annotation1</name>
            <pose>Unspecified</pose>
            <truncated>0</truncated>
            <difficult>0</difficult>
            <bndbox>
                <xmin>10</xmin>
                <ymin>20</ymin>
                <xmax>30</xmax>
                <ymax>50</ymax>
            </bndbox>
        </object>
        <object>
            <name>annotation2</name>
            <pose>Unspecified</pose>
            <truncated>0</truncated>
            <difficult>0</difficult>
            <bndbox>
                <xmin>20</xmin>
                <ymin>30</ymin>
                <xmax>30</xmax>
                <ymax>50</ymax>
            </bndbox>
        </object>
    </annotation>
    `,
    'application/xml'
);

describe('VOCImporter parseAnnotationsFromFileString method', () => {
    it('should return correctly for multiple annotations', () => {
        // given
        const emptyRecordSet: Record<string, LabelName> = {};

        // when
        const [annotations, newRecordSet] = TestableVOCImporter.testableParseAnnotationsFromFileString(validTestDocument, emptyRecordSet);

        // then
        expect(Object.keys(emptyRecordSet).length).toBe(0);
        expect(newRecordSet).toEqual(expect.objectContaining({
            'annotation1': expect.objectContaining({ name: 'annotation1'}),
            'annotation2': expect.objectContaining({ name: 'annotation2'}),
        }))
        expect(annotations).toEqual([
            expect.objectContaining({
                rect: {
                    x: 10,
                    y: 20,
                    height: 30,
                    width: 20
                },
                labelId: newRecordSet['annotation1'].id
            }),
            expect.objectContaining({
                rect: {
                    x: 20,
                    y: 30,
                    height: 20,
                    width: 10
                },
                labelId: newRecordSet['annotation2'].id
            })
        ]);
    });

    it('should reuse existing labels', () => {
        // given
        const existingRecordSet: Record<string, LabelName> = {
            'annotation2': {
                id: 'foobar',
                name: 'annotation2'
            }
        };

        // when
        const [annotations, newRecordSet] = TestableVOCImporter.testableParseAnnotationsFromFileString(validTestDocument, existingRecordSet);

        // then
        expect(Object.keys(existingRecordSet).length).toBe(1);
        expect(newRecordSet).toEqual(expect.objectContaining({
            'annotation1': expect.objectContaining({ name: 'annotation1' }),
            'annotation2': expect.objectContaining({ name: 'annotation2', id: 'foobar' }),
        }));
        expect(annotations.length).toBe(2);
        expect(annotations).toEqual(expect.arrayContaining([
            expect.objectContaining({
                labelId: 'foobar'
            })
        ]));
    });
});

```

Path: src/logic/__tests__/import/yolo/YOLOImporter.test.ts
```ts

import { ImageData } from '../../../../store/labels/types';
import { AcceptedFileType } from '../../../../data/enums/AcceptedFileType';
import { v4 as uuidv4 } from 'uuid';
import { YOLOImporter } from '../../../import/yolo/YOLOImporter';
import { isEqual } from 'lodash';

const getDummyImageData = (fileName: string): ImageData => {
    return {
        id: uuidv4(),
        fileData: new File([''], fileName, { type: AcceptedFileType.IMAGE }),
        loadStatus: true,
        labelRects: [],
        labelPoints: [],
        labelLines: [],
        labelPolygons: [],
        labelNameIds: [],
        isVisitedByYOLOObjectDetector: false,
        isVisitedBySSDObjectDetector: false,
        isVisitedByPoseDetector: false,
        isVisitedByRoboflowAPI: false
    };
};

const getDummyFileData = (fileName: string): File => {
    return new File([''], fileName, { type: AcceptedFileType.TEXT });
};

describe('YOLOImporter filterFilesData method', () => {
    it('should return correct fileData partition', () => {
        // given
        const imageFileNames = [
            '00000.png',
            '00001.png',
            '00002.png',
            '00003.png',
            '00004.png'
        ];
        const imagesData: ImageData[] = imageFileNames.map((fileName: string) => getDummyImageData(fileName));
        const annotationFileNames = [
            '00002.txt',
            '00003.txt',
            '00004.txt',
            '00005.txt',
            '00006.txt'
        ];
        const annotationFiles: File[] = annotationFileNames.map((fileName: string) => getDummyFileData(fileName));
        const labelFileNames = [
            'labels.txt'
        ];
        const labelFiles: File[] = labelFileNames.map((fileName: string) => getDummyFileData(fileName));
        const filesData: File[] = [...annotationFiles, ...labelFiles];
        const expectedAnnotationFileNames = [
            '00002.txt',
            '00003.txt',
            '00004.txt'
        ];

        // when
        const result = YOLOImporter.filterFilesData(filesData, imagesData);

        // then
        const resultNames = result.annotationFiles.map((item: File) => item.name);
        expect(result.labelNameFile.name).toEqual('labels.txt');
        expect(result.annotationFiles.length).toEqual(3);
        expect(isEqual(resultNames, expectedAnnotationFileNames)).toBe(true);
    });
});

```

Path: src/logic/__tests__/import/yolo/YOLOUtils.test.ts
```ts
import { YOLOUtils } from '../../../import/yolo/YOLOUtils';
import { isEqual } from 'lodash';
import { LabelName, LabelRect } from '../../../../store/labels/types';
import { AnnotationsParsingError, LabelNamesNotUniqueError } from '../../../import/yolo/YOLOErrors';
import { v4 as uuidv4 } from 'uuid';
import { ISize } from '../../../../interfaces/ISize';
import { IRect } from '../../../../interfaces/IRect';

describe('YOLOUtils parseLabelsFile method', () => {
    it('should return list of label names', () => {
        // given
        const content = 'orange\napple\nbanana\ncarrot';

        // when
        const result = YOLOUtils.parseLabelsNamesFromString(content);

        // then
        const expectedNames = ['orange', 'apple', 'banana', 'carrot'];
        const resultNames = result.map((item: LabelName) => item.name);
        expect(result.length).toEqual(4);
        expect(isEqual(resultNames, expectedNames)).toBe(true);
    });

    it('should return list of label names without white characters', () => {
        // given
        const content = 'orange \napple \nbanana    \ncarrot';

        // when
        const result = YOLOUtils.parseLabelsNamesFromString(content);

        // then
        const expectedNames = ['orange', 'apple', 'banana', 'carrot'];
        const resultNames = result.map((item: LabelName) => item.name);
        expect(result.length).toEqual(4);
        expect(isEqual(resultNames, expectedNames)).toBe(true);
    });

    it('should return list of label names without empty strings', () => {
        // given
        const content = 'orange\n\napple\nbanana\n\ncarrot';

        // when
        const result = YOLOUtils.parseLabelsNamesFromString(content);

        // then
        const expectedNames = ['orange', 'apple', 'banana', 'carrot'];
        const resultNames = result.map((item: LabelName) => item.name);
        expect(result.length).toEqual(4);
        expect(isEqual(resultNames, expectedNames)).toBe(true);
    });

    it('should throw exception about labels not being unique', () => {
        // given
        const content = 'orange\napple\nbanana\napple';

        // then
        expect(() => { YOLOUtils.parseLabelsNamesFromString(content); }).toThrowError(new LabelNamesNotUniqueError());
    });
});

describe('YOLOUtils validateYOLOAnnotationComponents method', () => {
    it('should return false when incorrect number of components given', () => {
        // given
        const components: string[] = ['2', '0.342238', '0.054099', '0.069556'];

        // when
        const result = YOLOUtils.validateYOLOAnnotationComponents(components, 3);

        // then
        expect(result).toBe(false);
    });

    it('should return false when label name index higher than number of label names', () => {
        // given
        const components: string[] = ['2', '0.342238', '0.054099', '0.069556', '0.108199'];

        // when
        const result = YOLOUtils.validateYOLOAnnotationComponents(components, 1);

        // then
        expect(result).toBe(false);
    });

    it('should return false when one of coordinates values have value higher than one', () => {
        // given
        const components: string[] = ['2', '0.342238', '1.054099', '0.069556', '0.108199'];

        // when
        const result = YOLOUtils.validateYOLOAnnotationComponents(components, 3);

        // then
        expect(result).toBe(false);
    });

    it('should return false when one of coordinates values have value smaller than zero', () => {
        // given
        const components: string[] = ['2', '0.342238', '-0.054099', '0.069556', '0.108199'];

        // when
        const result = YOLOUtils.validateYOLOAnnotationComponents(components, 3);

        // then
        expect(result).toBe(false);
    });

    it('should return true', () => {
        // given
        const components: string[] = ['2', '0.342238', '0.054099', '0.069556', '0.108199'];

        // when
        const result = YOLOUtils.validateYOLOAnnotationComponents(components, 3);

        // then
        expect(result).toBe(true);
    });

    it('should return true', () => {
        // given
        const components: string[] = ['6', '0.557911', '0.924187', '0.000673', '0.000000'];

        // when
        const result = YOLOUtils.validateYOLOAnnotationComponents(components, 10);

        // then
        expect(result).toBe(true);
    });
});

describe('YOLOUtils parseYOLOAnnotationFromString method', () => {
    it('should return correct LabelRect', () => {
        // given
        const rawAnnotation: string = '1 0.300000 0.200000 0.300000 0.200000';
        const labelId: string = uuidv4();
        const labelNames: LabelName[] = [
            {
                id: uuidv4(),
                name: 'orange',
                color: '#000000'
            },
            {
                id: labelId,
                name: 'apple',
                color: '#000000'
            },
            {
                id: uuidv4(),
                name: 'banana',
                color: '#000000'
            }
        ];
        const imageSize: ISize = { width: 1000, height: 1000 };
        const imageName: string = '0000.png';

        // when
        const result: LabelRect = YOLOUtils.parseYOLOAnnotationFromString(
            rawAnnotation, labelNames, imageSize, imageName
        );

        // then
        const rect: IRect = { x: 150, y: 100, width: 300, height: 200 };
        expect(result.labelId).toBe(labelId);
        expect(JSON.stringify(result.rect)).toBe(JSON.stringify(rect));
    });

    it('should throw AnnotationsParsingError', () => {
        // given
        const rawAnnotation: string = '4 0.340000 0.540000 0.060000 0.100000';
        const labelId: string = uuidv4();
        const labelNames: LabelName[] = [
            {
                id: uuidv4(),
                name: 'orange',
                color: '#000000'
            },
            {
                id: labelId,
                name: 'apple',
                color: '#000000'
            },
            {
                id: uuidv4(),
                name: 'banana',
                color: '#000000'
            }
        ];
        const imageSize: ISize = { width: 1000, height: 1000 };
        const imageName: string = '0000.png';

        // when
        function wrapper() {
            return YOLOUtils.parseYOLOAnnotationFromString(rawAnnotation, labelNames, imageSize, imageName);
        }
        expect(wrapper).toThrowError(new AnnotationsParsingError(imageName));
    });
});

describe('YOLOUtils parseYOLOAnnotationsFromString method', () => {
    it('should return correct array of LabelRect', () => {
        // given
        const rawAnnotations: string = '1 0.200000 0.200000 0.200000 0.200000\n0 0.300000 0.200000 0.300000 0.200000\n2 0.200000 0.300000 0.200000 0.300000';
        const labelId: string = uuidv4();
        const labelNames: LabelName[] = [
            {
                id: uuidv4(),
                name: 'orange',
                color: '#000000'
            },
            {
                id: uuidv4(),
                name: 'apple',
                color: '#000000'
            },
            {
                id: labelId,
                name: 'banana',
                color: '#000000'
            }
        ];
        const imageSize: ISize = { width: 1000, height: 1000 };
        const imageName: string = '0000.png';

        // when
        const result: LabelRect[] = YOLOUtils.parseYOLOAnnotationsFromString(
            rawAnnotations, labelNames, imageSize, imageName
        );

        // then
        const rect: IRect = { x: 100, y: 150, width: 200, height: 300 };
        expect(result.length).toBe(3);
        expect(result[2].labelId).toBe(labelId);
        expect(JSON.stringify(result[2].rect)).toBe(JSON.stringify(rect));
    });

    it('should throw AnnotationsParsingError', () => {
        // given
        const rawAnnotations: string = '1 0.200000 0.200000 0.200000 0.200000\n0 0.300000 0.200000 0.300000 0.200000\n4 0.200000 0.300000 0.200000 0.300000';
        const labelId: string = uuidv4();
        const labelNames: LabelName[] = [
            {
                id: uuidv4(),
                name: 'orange',
                color: '#000000'
            },
            {
                id: uuidv4(),
                name: 'apple',
                color: '#000000'
            },
            {
                id: labelId,
                name: 'banana',
                color: '#000000'
            }
        ];
        const imageSize: ISize = { width: 1000, height: 1000 };
        const imageName: string = '0000.png';

        // when
        function wrapper() {
            return YOLOUtils.parseYOLOAnnotationsFromString(rawAnnotations, labelNames, imageSize, imageName);
        }
        expect(wrapper).toThrowError(new AnnotationsParsingError(imageName));
    });
});

```

Path: src/logic/actions/AIActions.ts
```ts
import {LabelType} from '../../data/enums/LabelType';
import {LabelsSelector} from '../../store/selectors/LabelsSelector';
import {AISSDObjectDetectionActions} from './AISSDObjectDetectionActions';
import {AIPoseDetectionActions} from './AIPoseDetectionActions';
import {ImageData} from '../../store/labels/types';
import {AISelector} from '../../store/selectors/AISelector';
import {AIYOLOObjectDetectionActions} from './AIYOLOObjectDetectionActions';
import { AIRoboflowAPIObjectDetectionActions } from './AIRoboflowAPIObjectDetectionActions';

export class AIActions {
    public static excludeRejectedLabelNames(suggestedLabels: string[], rejectedLabels: string[]): string[] {
        return suggestedLabels.reduce((acc: string[], label: string) => {
            if (!rejectedLabels.includes(label)) {
                acc.push(label)
            }
            return acc;
        }, [])
    }

    public static detect(imageId: string, image: HTMLImageElement): void {
        const imageData =  LabelsSelector.getImageDataById(imageId)
        const activeLabelType: LabelType = LabelsSelector.getActiveLabelType();
        const isAIYOLOObjectDetectorModelLoaded = AISelector.isAIYOLOObjectDetectorModelLoaded();
        const isAISSDObjectDetectorModelLoaded = AISelector.isAISSDObjectDetectorModelLoaded();
        const isRoboflowAPIModelLoaded = AISelector.isRoboflowAPIModelLoaded();
        switch (activeLabelType) {
            case LabelType.RECT:
                if (isAISSDObjectDetectorModelLoaded) {
                    AISSDObjectDetectionActions.detectRects(imageId, image);
                }
                if (isAIYOLOObjectDetectorModelLoaded) {
                    AIYOLOObjectDetectionActions.detectRects(imageId, image);
                }
                if (isRoboflowAPIModelLoaded) {
                    AIRoboflowAPIObjectDetectionActions.detectRects(imageData)
                }
                break;
            case LabelType.POINT:
                AIPoseDetectionActions.detectPoses(imageId, image);
                break;
        }
    }

    public static rejectAllSuggestedLabels(imageData: ImageData) {
        const activeLabelType: LabelType = LabelsSelector.getActiveLabelType();
        const isAIYOLOObjectDetectorModelLoaded = AISelector.isAIYOLOObjectDetectorModelLoaded();
        const isAISSDObjectDetectorModelLoaded = AISelector.isAISSDObjectDetectorModelLoaded();
        const isRoboflowAPIModelLoaded = AISelector.isRoboflowAPIModelLoaded();
        switch (activeLabelType) {
            case LabelType.RECT:
                if (isAISSDObjectDetectorModelLoaded) {
                    AISSDObjectDetectionActions.rejectAllSuggestedRectLabels(imageData);
                }
                if (isAIYOLOObjectDetectorModelLoaded) {
                    AIYOLOObjectDetectionActions.rejectAllSuggestedRectLabels(imageData);
                }
                if (isRoboflowAPIModelLoaded) {
                    AIRoboflowAPIObjectDetectionActions.rejectAllSuggestedRectLabels(imageData)
                }
                break;
            case LabelType.POINT:
                AIPoseDetectionActions.rejectAllSuggestedPointLabels(imageData);
                break;
        }
    }

    public static acceptAllSuggestedLabels(imageData: ImageData) {
        const activeLabelType: LabelType = LabelsSelector.getActiveLabelType();
        const isAIYOLOObjectDetectorModelLoaded = AISelector.isAIYOLOObjectDetectorModelLoaded();
        const isAISSDObjectDetectorModelLoaded = AISelector.isAISSDObjectDetectorModelLoaded();
        const isRoboflowAPIModelLoaded = AISelector.isRoboflowAPIModelLoaded();
        switch (activeLabelType) {
            case LabelType.RECT:
                if (isAISSDObjectDetectorModelLoaded) {
                    AISSDObjectDetectionActions.acceptAllSuggestedRectLabels(imageData);
                }
                if (isAIYOLOObjectDetectorModelLoaded) {
                    AIYOLOObjectDetectionActions.acceptAllSuggestedRectLabels(imageData);
                }
                if (isRoboflowAPIModelLoaded) {
                    AIRoboflowAPIObjectDetectionActions.acceptAllSuggestedRectLabels(imageData)
                }
                break;
            case LabelType.POINT:
                AIPoseDetectionActions.acceptAllSuggestedPointLabels(imageData);
                break;
        }
    }
}

```

Path: src/logic/actions/AIPoseDetectionActions.ts
```ts
import {PoseDetector} from '../../ai/PoseDetector';
import {Keypoint, Pose} from '@tensorflow-models/posenet';
import {ImageData, LabelName, LabelPoint} from '../../store/labels/types';
import {LabelsSelector} from '../../store/selectors/LabelsSelector';
import {ImageRepository} from '../imageRepository/ImageRepository';
import {LabelStatus} from '../../data/enums/LabelStatus';
import { v4 as uuidv4 } from 'uuid';
import {store} from '../../index';
import {updateImageDataById} from '../../store/labels/actionCreators';
import {findLast} from 'lodash';
import {AISelector} from '../../store/selectors/AISelector';
import {AIActions} from './AIActions';
import {updateSuggestedLabelList} from '../../store/ai/actionCreators';
import {updateActivePopupType} from '../../store/general/actionCreators';
import {PopupWindowType} from '../../data/enums/PopupWindowType';
import {NumberUtil} from '../../utils/NumberUtil';

export class AIPoseDetectionActions {
    public static detectPoseForActiveImage(): void {
        const activeImageData: ImageData = LabelsSelector.getActiveImageData();
        AIPoseDetectionActions.detectPoses(activeImageData.id, ImageRepository.getById(activeImageData.id))
    }

    public static detectPoses(imageId: string, image: HTMLImageElement): void {
        if (LabelsSelector.getImageDataById(imageId).isVisitedByPoseDetector
            || !AISelector.isAIPoseDetectorModelLoaded())
            return;

        store.dispatch(updateActivePopupType(PopupWindowType.LOADER));
        PoseDetector.predict(image, (poses: Pose[]) => {
            const suggestedLabelNames = AIPoseDetectionActions
                .extractNewSuggestedLabelNames(LabelsSelector.getLabelNames(), poses);
            const rejectedLabelNames = AISelector.getRejectedSuggestedLabelList();
            const newlySuggestedNames = AIActions.excludeRejectedLabelNames(suggestedLabelNames, rejectedLabelNames);
            if (newlySuggestedNames.length > 0) {
                store.dispatch(updateSuggestedLabelList(newlySuggestedNames));
                store.dispatch(updateActivePopupType(PopupWindowType.SUGGEST_LABEL_NAMES));
            } else {
                store.dispatch(updateActivePopupType(null));
            }
            AIPoseDetectionActions.savePosePredictions(imageId, poses, image);
        })
    }

    public static savePosePredictions(imageId: string, predictions: Pose[], image: HTMLImageElement) {
        const imageData: ImageData = LabelsSelector.getImageDataById(imageId);
        const predictedLabels: LabelPoint[] = AIPoseDetectionActions
            .mapPredictionsToPointLabels(predictions)
            .filter((labelPoint: LabelPoint) => NumberUtil.isValueInRange(labelPoint.point.x, 0, image.width))
            .filter((labelPoint: LabelPoint) => NumberUtil.isValueInRange(labelPoint.point.y, 0, image.height))
        const nextImageData: ImageData = {
            ...imageData,
            labelPoints: imageData.labelPoints.concat(predictedLabels),
            isVisitedByPoseDetector: true
        };
        store.dispatch(updateImageDataById(imageData.id, nextImageData));
    }

    private static mapPredictionsToPointLabels(predictions: Pose[]): LabelPoint[] {
        return predictions
            .map((prediction: Pose) => {
                return prediction.keypoints
                    .map((keypoint: Keypoint) => {
                        return {
                            id: uuidv4(),
                            labelIndex: null,
                            labelId: null,
                            point: {
                                x: keypoint.position.x,
                                y: keypoint.position.y
                            },
                            isVisible: true,
                            isCreatedByAI: true,
                            status: LabelStatus.UNDECIDED,
                            suggestedLabel: keypoint.part
                        }
                    })
            })
            .reduce((acc: LabelPoint[], item: LabelPoint[]) => {
                return acc.concat(item);
            }, [])
    }

    public static extractNewSuggestedLabelNames(labels: LabelName[], predictions: Pose[]): string[] {
        return predictions
            .map((pose: Pose) => pose.keypoints)
            .reduce((acc: Keypoint[], item: Keypoint[]) => {
                return acc.concat(item);
            }, [])
            .map((keypoint: Keypoint) => keypoint.part)
            .reduce((acc: string[], name: string) => {
                if (!acc.includes(name) && !findLast(labels, {name})) {
                    acc.push(name)
                }
                return acc;
            }, [])
    }

    public static acceptAllSuggestedPointLabels(imageData: ImageData) {
        const newImageData: ImageData = {
            ...imageData,
            labelPoints: imageData.labelPoints.map((labelPoint: LabelPoint) => {
                const labelName: LabelName = findLast(LabelsSelector.getLabelNames(), {name: labelPoint.suggestedLabel});
                return {
                    ...labelPoint,
                    status: LabelStatus.ACCEPTED,
                    labelId: !!labelName ? labelName.id : labelPoint.labelId
                }
            })
        };
        store.dispatch(updateImageDataById(newImageData.id, newImageData));
    }

    public static rejectAllSuggestedPointLabels(imageData: ImageData) {
        const newImageData: ImageData = {
            ...imageData,
            labelPoints: imageData.labelPoints.filter((labelPoint: LabelPoint) => labelPoint.status === LabelStatus.ACCEPTED)
        };
        store.dispatch(updateImageDataById(newImageData.id, newImageData));
    }
}

```

Path: src/logic/actions/AIRoboflowAPIObjectDetectionActions.ts
```ts
import { ImageData, LabelName, LabelRect } from '../../store/labels/types';
import { v4 as uuidv4 } from 'uuid';
import { LabelStatus } from '../../data/enums/LabelStatus';
import { DetectedObject, RoboflowAPIObjectDetector } from '../../ai/RoboflowAPIObjectDetector';
import { findLast } from 'lodash';
import { LabelsSelector } from '../../store/selectors/LabelsSelector';
import { store } from '../../index';
import { updateImageDataById } from '../../store/labels/actionCreators';
import { AISelector } from '../../store/selectors/AISelector';
import { updateActivePopupType } from '../../store/general/actionCreators';
import { PopupWindowType } from '../../data/enums/PopupWindowType';
import { AIActions } from './AIActions';
import { updateSuggestedLabelList } from '../../store/ai/actionCreators';

export class AIRoboflowAPIObjectDetectionActions {
    public static detectRects(imageData: ImageData): void {
        if (imageData.isVisitedByRoboflowAPI || !AISelector.isRoboflowAPIModelLoaded())
            return;

        store.dispatch(updateActivePopupType(PopupWindowType.LOADER));
        RoboflowAPIObjectDetector.predict(imageData, (predictions: DetectedObject[]) => {
            const suggestedLabelNames = AIRoboflowAPIObjectDetectionActions
                .extractNewSuggestedLabelNames(LabelsSelector.getLabelNames(), predictions);
            const rejectedLabelNames = AISelector.getRejectedSuggestedLabelList();

            const newlySuggestedNames = AIActions.excludeRejectedLabelNames(suggestedLabelNames, rejectedLabelNames);
            if (newlySuggestedNames.length > 0) {
                store.dispatch(updateSuggestedLabelList(newlySuggestedNames));
                store.dispatch(updateActivePopupType(PopupWindowType.SUGGEST_LABEL_NAMES));
            } else {
                store.dispatch(updateActivePopupType(null));
            }
            AIRoboflowAPIObjectDetectionActions.saveRectPredictions(imageData, predictions);
        })
    }

    public static saveRectPredictions(imageData: ImageData, predictions: DetectedObject[]) {
        const predictedLabels: LabelRect[] = AIRoboflowAPIObjectDetectionActions.mapPredictionsToRectLabels(predictions);
        const nextImageData: ImageData = {
            ...imageData,
            labelRects: imageData.labelRects.concat(predictedLabels),
            isVisitedByRoboflowAPI: true
        };
        store.dispatch(updateImageDataById(imageData.id, nextImageData));
    }

    private static mapPredictionsToRectLabels(predictions: DetectedObject[]): LabelRect[] {
        return predictions.map((prediction: DetectedObject) => {
            return {
                id: uuidv4(),
                labelIndex: null,
                labelId: null,
                rect: {
                    x: prediction.x,
                    y: prediction.y,
                    width: prediction.width,
                    height: prediction.height,
                },
                isVisible: true,
                isCreatedByAI: true,
                status: LabelStatus.UNDECIDED,
                suggestedLabel: prediction.class
            }
        })
    }

    public static extractNewSuggestedLabelNames(labels: LabelName[], predictions: DetectedObject[]): string[] {
        return predictions.reduce((acc: string[], prediction: DetectedObject) => {
            if (!acc.includes(prediction.class) && !findLast(labels, {name: prediction.class})) {
                acc.push(prediction.class)
            }
            return acc;
        }, [])
    }

    public static acceptAllSuggestedRectLabels(imageData: ImageData) {
        const newImageData: ImageData = {
            ...imageData,
            labelRects: imageData.labelRects.map((labelRect: LabelRect) => {
                const labelName: LabelName = findLast(LabelsSelector.getLabelNames(), {name: labelRect.suggestedLabel});
                return {
                    ...labelRect,
                    status: LabelStatus.ACCEPTED,
                    labelId: !!labelName ? labelName.id : labelRect.labelId
                }
            })
        };
        store.dispatch(updateImageDataById(newImageData.id, newImageData));
    }

    public static rejectAllSuggestedRectLabels(imageData: ImageData) {
        const newImageData: ImageData = {
            ...imageData,
            labelRects: imageData.labelRects.filter((labelRect: LabelRect) => labelRect.status === LabelStatus.ACCEPTED)
        };
        store.dispatch(updateImageDataById(newImageData.id, newImageData));
    }
}
```

Path: src/logic/actions/AISSDObjectDetectionActions.ts
```ts
import {DetectedObject} from '@tensorflow-models/coco-ssd';
import {ImageData, LabelName, LabelRect} from '../../store/labels/types';
import {LabelsSelector} from '../../store/selectors/LabelsSelector';
import { v4 as uuidv4 } from 'uuid';
import {store} from '../../index';
import {updateImageDataById} from '../../store/labels/actionCreators';
import {SSDObjectDetector} from '../../ai/SSDObjectDetector';
import {ImageRepository} from '../imageRepository/ImageRepository';
import {LabelStatus} from '../../data/enums/LabelStatus';
import {findLast} from 'lodash';
import {updateSuggestedLabelList} from '../../store/ai/actionCreators';
import {PopupWindowType} from '../../data/enums/PopupWindowType';
import {updateActivePopupType} from '../../store/general/actionCreators';
import {AISelector} from '../../store/selectors/AISelector';
import {AIActions} from './AIActions';

export class AISSDObjectDetectionActions {
    public static detectRectsForActiveImage(): void {
        const activeImageData: ImageData = LabelsSelector.getActiveImageData();
        AISSDObjectDetectionActions.detectRects(activeImageData.id, ImageRepository.getById(activeImageData.id))
    }

    public static detectRects(imageId: string, image: HTMLImageElement): void {
        if (LabelsSelector.getImageDataById(imageId).isVisitedBySSDObjectDetector
            || !AISelector.isAISSDObjectDetectorModelLoaded())
            return;

        store.dispatch(updateActivePopupType(PopupWindowType.LOADER));
        SSDObjectDetector.predict(image, (predictions: DetectedObject[]) => {
            const suggestedLabelNames = AISSDObjectDetectionActions
                .extractNewSuggestedLabelNames(LabelsSelector.getLabelNames(), predictions);
            const rejectedLabelNames = AISelector.getRejectedSuggestedLabelList();
            const newlySuggestedNames = AIActions.excludeRejectedLabelNames(suggestedLabelNames, rejectedLabelNames);
            if (newlySuggestedNames.length > 0) {
                store.dispatch(updateSuggestedLabelList(newlySuggestedNames));
                store.dispatch(updateActivePopupType(PopupWindowType.SUGGEST_LABEL_NAMES));
            } else {
                store.dispatch(updateActivePopupType(null));
            }
            AISSDObjectDetectionActions.saveRectPredictions(imageId, predictions);
        })
    }

    public static saveRectPredictions(imageId: string, predictions: DetectedObject[]) {
        const imageData: ImageData = LabelsSelector.getImageDataById(imageId);
        const predictedLabels: LabelRect[] = AISSDObjectDetectionActions.mapPredictionsToRectLabels(predictions);
        const nextImageData: ImageData = {
            ...imageData,
            labelRects: imageData.labelRects.concat(predictedLabels),
            isVisitedBySSDObjectDetector: true
        };
        store.dispatch(updateImageDataById(imageData.id, nextImageData));
    }

    private static mapPredictionsToRectLabels(predictions: DetectedObject[]): LabelRect[] {
        return predictions.map((prediction: DetectedObject) => {
            return {
                id: uuidv4(),
                labelIndex: null,
                labelId: null,
                rect: {
                    x: prediction.bbox[0],
                    y: prediction.bbox[1],
                    width: prediction.bbox[2],
                    height: prediction.bbox[3],
                },
                isVisible: true,
                isCreatedByAI: true,
                status: LabelStatus.UNDECIDED,
                suggestedLabel: prediction.class
            }
        })
    }

    public static extractNewSuggestedLabelNames(labels: LabelName[], predictions: DetectedObject[]): string[] {
        return predictions.reduce((acc: string[], prediction: DetectedObject) => {
            if (!acc.includes(prediction.class) && !findLast(labels, {name: prediction.class})) {
                acc.push(prediction.class)
            }
            return acc;
        }, [])
    }

    public static acceptAllSuggestedRectLabels(imageData: ImageData) {
        const newImageData: ImageData = {
            ...imageData,
            labelRects: imageData.labelRects.map((labelRect: LabelRect) => {
                const labelName: LabelName = findLast(LabelsSelector.getLabelNames(), {name: labelRect.suggestedLabel});
                return {
                    ...labelRect,
                    status: LabelStatus.ACCEPTED,
                    labelId: !!labelName ? labelName.id : labelRect.labelId
                }
            })
        };
        store.dispatch(updateImageDataById(newImageData.id, newImageData));
    }

    public static rejectAllSuggestedRectLabels(imageData: ImageData) {
        const newImageData: ImageData = {
            ...imageData,
            labelRects: imageData.labelRects.filter((labelRect: LabelRect) => labelRect.status === LabelStatus.ACCEPTED)
        };
        store.dispatch(updateImageDataById(newImageData.id, newImageData));
    }
}

```

Path: src/logic/actions/AIYOLOObjectDetectionActions.ts
```ts
import {ImageData, LabelName, LabelRect} from '../../store/labels/types';
import {LabelsSelector} from '../../store/selectors/LabelsSelector';
import {ImageRepository} from '../imageRepository/ImageRepository';
import {AISelector} from '../../store/selectors/AISelector';
import {DetectedObject} from 'yolov5js';
import {findLast} from 'lodash';
import {v4 as uuidv4} from 'uuid';
import {LabelStatus} from '../../data/enums/LabelStatus';
import {store} from '../../index';
import {updateImageDataById} from '../../store/labels/actionCreators';
import {updateActivePopupType} from '../../store/general/actionCreators';
import {PopupWindowType} from '../../data/enums/PopupWindowType';
import {AIActions} from './AIActions';
import {updateSuggestedLabelList} from '../../store/ai/actionCreators';
import {YOLOV5ObjectDetector} from '../../ai/YOLOV5ObjectDetector';

export class AIYOLOObjectDetectionActions {
    public static detectRectsForActiveImage(): void {
        const activeImageData: ImageData = LabelsSelector.getActiveImageData();
        AIYOLOObjectDetectionActions.detectRects(activeImageData.id, ImageRepository.getById(activeImageData.id))
    }

    public static detectRects(imageId: string, image: HTMLImageElement): void {
        if (LabelsSelector.getImageDataById(imageId).isVisitedByYOLOObjectDetector
            || !AISelector.isAIYOLOObjectDetectorModelLoaded())
            return;

        store.dispatch(updateActivePopupType(PopupWindowType.LOADER));
        YOLOV5ObjectDetector.predict(image, (predictions: DetectedObject[]) => {
            const suggestedLabelNames = AIYOLOObjectDetectionActions
                .extractNewSuggestedLabelNames(LabelsSelector.getLabelNames(), predictions);
            const rejectedLabelNames = AISelector.getRejectedSuggestedLabelList();
            const newlySuggestedNames = AIActions.excludeRejectedLabelNames(suggestedLabelNames, rejectedLabelNames);
            if (newlySuggestedNames.length > 0) {
                store.dispatch(updateSuggestedLabelList(newlySuggestedNames));
                store.dispatch(updateActivePopupType(PopupWindowType.SUGGEST_LABEL_NAMES));
            } else {
                store.dispatch(updateActivePopupType(null));
            }
            AIYOLOObjectDetectionActions.saveRectPredictions(imageId, predictions);
        })
    }

    public static saveRectPredictions(imageId: string, predictions: DetectedObject[]) {
        const imageData: ImageData = LabelsSelector.getImageDataById(imageId);
        const predictedLabels: LabelRect[] = AIYOLOObjectDetectionActions.mapPredictionsToRectLabels(predictions);
        const nextImageData: ImageData = {
            ...imageData,
            labelRects: imageData.labelRects.concat(predictedLabels),
            isVisitedByYOLOObjectDetector: true
        };
        store.dispatch(updateImageDataById(imageData.id, nextImageData));
    }

    private static mapPredictionsToRectLabels(predictions: DetectedObject[]): LabelRect[] {
        return predictions.map((prediction: DetectedObject) => {
            return {
                id: uuidv4(),
                labelIndex: null,
                labelId: null,
                rect: {
                    x: prediction.x,
                    y: prediction.y,
                    width: prediction.width,
                    height: prediction.height,
                },
                isVisible: true,
                isCreatedByAI: true,
                status: LabelStatus.UNDECIDED,
                suggestedLabel: prediction.class
            }
        })
    }

    public static extractNewSuggestedLabelNames(labels: LabelName[], predictions: DetectedObject[]): string[] {
        return predictions.reduce((acc: string[], prediction: DetectedObject) => {
            if (!acc.includes(prediction.class) && !findLast(labels, {name: prediction.class})) {
                acc.push(prediction.class)
            }
            return acc;
        }, [])
    }

    public static acceptAllSuggestedRectLabels(imageData: ImageData) {
        const newImageData: ImageData = {
            ...imageData,
            labelRects: imageData.labelRects.map((labelRect: LabelRect) => {
                const labelName: LabelName = findLast(LabelsSelector.getLabelNames(), {name: labelRect.suggestedLabel});
                return {
                    ...labelRect,
                    status: LabelStatus.ACCEPTED,
                    labelId: !!labelName ? labelName.id : labelRect.labelId
                }
            })
        };
        store.dispatch(updateImageDataById(newImageData.id, newImageData));
    }

    public static rejectAllSuggestedRectLabels(imageData: ImageData) {
        const newImageData: ImageData = {
            ...imageData,
            labelRects: imageData.labelRects.filter((labelRect: LabelRect) => labelRect.status === LabelStatus.ACCEPTED)
        };
        store.dispatch(updateImageDataById(newImageData.id, newImageData));
    }
}

```

Path: src/logic/actions/EditorActions.ts
```ts
import {LabelType} from "../../data/enums/LabelType";
import {EditorModel} from "../../staticModels/EditorModel";
import {RectRenderEngine} from "../render/RectRenderEngine";
import {PointRenderEngine} from "../render/PointRenderEngine";
import {PolygonRenderEngine} from "../render/PolygonRenderEngine";
import {IRect} from "../../interfaces/IRect";
import {RectUtil} from "../../utils/RectUtil";
import {EditorData} from "../../data/EditorData";
import {CanvasUtil} from "../../utils/CanvasUtil";
import React from "react";
import {IPoint} from "../../interfaces/IPoint";
import {DrawUtil} from "../../utils/DrawUtil";
import {PrimaryEditorRenderEngine} from "../render/PrimaryEditorRenderEngine";
import {ContextManager} from "../context/ContextManager";
import {PointUtil} from "../../utils/PointUtil";
import {ViewPortActions} from "./ViewPortActions";
import {ISize} from "../../interfaces/ISize";
import {ImageUtil} from "../../utils/ImageUtil";
import {GeneralSelector} from "../../store/selectors/GeneralSelector";
import {ViewPortHelper} from "../helpers/ViewPortHelper";
import {CustomCursorStyle} from "../../data/enums/CustomCursorStyle";
import {LineRenderEngine} from "../render/LineRenderEngine";

export class EditorActions {

    // =================================================================================================================
    // RENDER ENGINES
    // =================================================================================================================

    public static mountSupportRenderingEngine(activeLabelType: LabelType) {
        switch (activeLabelType) {
            case LabelType.RECT:
                EditorModel.supportRenderingEngine = new RectRenderEngine(EditorModel.canvas);
                break;
            case LabelType.POINT:
                EditorModel.supportRenderingEngine = new PointRenderEngine(EditorModel.canvas);
                break;
            case LabelType.LINE:
                EditorModel.supportRenderingEngine = new LineRenderEngine(EditorModel.canvas);
                break;
            case LabelType.POLYGON:
                EditorModel.supportRenderingEngine = new PolygonRenderEngine(EditorModel.canvas);
                break;
            default:
                EditorModel.supportRenderingEngine = null;
                break;
        }
    };

    public static swapSupportRenderingEngine(activeLabelType: LabelType) {
        EditorActions.mountSupportRenderingEngine(activeLabelType);
    };

    public static mountRenderEnginesAndHelpers(activeLabelType: LabelType) {
        EditorModel.viewPortHelper = new ViewPortHelper();
        EditorModel.primaryRenderingEngine = new PrimaryEditorRenderEngine(EditorModel.canvas);
        EditorActions.mountSupportRenderingEngine(activeLabelType);
    }

    // =================================================================================================================
    // RENDER
    // =================================================================================================================

    public static fullRender() {
        DrawUtil.clearCanvas(EditorModel.canvas);
        EditorModel.primaryRenderingEngine.render(EditorActions.getEditorData());
        EditorModel.supportRenderingEngine && EditorModel.supportRenderingEngine.render(EditorActions.getEditorData());
    }

    // =================================================================================================================
    // SETTERS
    // =================================================================================================================

    public static setLoadingStatus(status: boolean) {
        EditorModel.isLoading = status;
    }
    public static setActiveImage(image: HTMLImageElement) {
        EditorModel.image = image;
    }

    public static setViewPortActionsDisabledStatus(status: boolean) {
        EditorModel.viewPortActionsDisabled = status;
    }

    // =================================================================================================================
    // GETTERS
    // =================================================================================================================

    public static getEditorData(event?: Event): EditorData {
        return {
            mousePositionOnViewPortContent: EditorModel.mousePositionOnViewPortContent,
            viewPortContentSize: CanvasUtil.getSize(EditorModel.canvas),
            activeKeyCombo: ContextManager.getActiveCombo(),
            event: event,
            zoom: GeneralSelector.getZoom(),
            viewPortSize: EditorModel.viewPortSize,
            defaultRenderImageRect: EditorModel.defaultRenderImageRect,
            viewPortContentImageRect: ViewPortActions.calculateViewPortContentImageRect(),
            realImageSize: ImageUtil.getSize(EditorModel.image),
            absoluteViewPortContentScrollPosition: ViewPortActions.getAbsoluteScrollPosition()
        }
    }

    // =================================================================================================================
    // HELPERS
    // =================================================================================================================

    public static updateMousePositionIndicator(event: React.MouseEvent<HTMLCanvasElement,¬†MouseEvent> | MouseEvent) {
        if (!EditorModel.image || !EditorModel.canvas) {
            EditorModel.mousePositionIndicator.style.display = "none";
            EditorModel.cursor.style.display = "none";
            return;
        }

        const mousePositionOverViewPortContent: IPoint = CanvasUtil.getMousePositionOnCanvasFromEvent(event, EditorModel.canvas);
        const viewPortContentScrollPosition: IPoint = ViewPortActions.getAbsoluteScrollPosition();
        const viewPortContentImageRect: IRect = ViewPortActions.calculateViewPortContentImageRect();
        const mousePositionOverViewPort: IPoint = PointUtil.subtract(mousePositionOverViewPortContent, viewPortContentScrollPosition);
        const isMouseOverImage: boolean = RectUtil.isPointInside(viewPortContentImageRect, mousePositionOverViewPortContent);
        const isMouseOverViewPort: boolean = RectUtil.isPointInside({x: 0, y: 0, ...EditorModel.viewPortSize}, mousePositionOverViewPort);

        if (isMouseOverViewPort && !GeneralSelector.getPreventCustomCursorStatus()) {
            EditorModel.cursor.style.left = mousePositionOverViewPort.x + "px";
            EditorModel.cursor.style.top = mousePositionOverViewPort.y + "px";
            EditorModel.cursor.style.display = "block";

            if (isMouseOverImage && ![CustomCursorStyle.GRAB, CustomCursorStyle.GRABBING].includes(GeneralSelector.getCustomCursorStyle())) {
                const imageSize: ISize = ImageUtil.getSize(EditorModel.image);
                const scale: number = imageSize.width / viewPortContentImageRect.width;
                const mousePositionOverImage: IPoint = PointUtil.multiply(
                    PointUtil.subtract(mousePositionOverViewPortContent, viewPortContentImageRect), scale);
                const text: string = "x: " + Math.round(mousePositionOverImage.x) + ", y: " + Math.round(mousePositionOverImage.y);

                EditorModel.mousePositionIndicator.innerHTML = text;
                EditorModel.mousePositionIndicator.style.left = (mousePositionOverViewPort.x + 15) + "px";
                EditorModel.mousePositionIndicator.style.top = (mousePositionOverViewPort.y + 15) + "px";
                EditorModel.mousePositionIndicator.style.display = "block";
            } else {
                EditorModel.mousePositionIndicator.style.display = "none";
            }
        } else {
            EditorModel.cursor.style.display = "none";
            EditorModel.mousePositionIndicator.style.display = "none";
        }
    };
}
```

Path: src/logic/actions/ImageActions.ts
```ts
import { LabelsSelector } from "../../store/selectors/LabelsSelector";
import { store } from "../../index";
import {
  updateActiveImageIndex,
  updateActiveLabelId,
  updateActiveLabelNameId,
  updateImageDataById,
} from "../../store/labels/actionCreators";
import { ViewPortActions } from "./ViewPortActions";
import { EditorModel } from "../../staticModels/EditorModel";
import { LabelType } from "../../data/enums/LabelType";
import {
  ImageData,
  LabelLine,
  LabelPoint,
  LabelPolygon,
  LabelRect,
} from "../../store/labels/types";
import { LabelStatus } from "../../data/enums/LabelStatus";
import { remove } from "lodash";

export class ImageActions {
  public static getPreviousImage(): void {
    const currentImageIndex: number = LabelsSelector.getActiveImageIndex();
    ImageActions.getImageByIndex(currentImageIndex - 1);
  }

  public static getNextImage(): void {
    const currentImageIndex: number = LabelsSelector.getActiveImageIndex();
    ImageActions.getImageByIndex(currentImageIndex + 1);
  }

  public static getImageByIndex(index: number): void {
    if (EditorModel.viewPortActionsDisabled) return;

    const imageCount: number = LabelsSelector.getImagesData().length;

    if (index < 0 || index > imageCount - 1) {
      return;
    } else {
      ViewPortActions.setZoom(1);
      store.dispatch(updateActiveImageIndex(index));
      store.dispatch(updateActiveLabelId(null));
    }
  }

  public static setActiveLabelOnActiveImage(labelIndex: number): void {
    const labelNames = LabelsSelector.getLabelNames();
    if (labelNames.length < labelIndex + 1) {
      return;
    }

    const imageData: ImageData = LabelsSelector.getActiveImageData();
    store.dispatch(
      updateImageDataById(
        imageData.id,
        ImageActions.mapNewImageData(imageData, labelIndex)
      )
    );
    store.dispatch(updateActiveLabelNameId(labelNames[1].id));
  }

  private static mapNewImageData(
    imageData: ImageData,
    labelIndex: number
  ): ImageData {
    const labelType: LabelType = LabelsSelector.getActiveLabelType();
    const labelNames = LabelsSelector.getLabelNames();
    let newImageData: ImageData = {
      ...imageData,
    };
    switch (labelType) {
      case LabelType.POINT:
        const point = LabelsSelector.getActivePointLabel();
        newImageData.labelPoints = imageData.labelPoints.map(
          (labelPoint: LabelPoint) => {
            if (labelPoint.id === point.id) {
              return {
                ...labelPoint,
                labelId: labelNames[labelIndex].id,
                status: LabelStatus.ACCEPTED,
              };
            }
            return labelPoint;
          }
        );
        store.dispatch(updateActiveLabelId(point.id));
        break;
      case LabelType.LINE:
        const line = LabelsSelector.getActiveLineLabel();
        newImageData.labelLines = imageData.labelLines.map(
          (labelLine: LabelLine) => {
            if (labelLine.id === line.id) {
              return {
                ...labelLine,
                labelId: labelNames[labelIndex].id,
                status: LabelStatus.ACCEPTED,
              };
            }
            return labelLine;
          }
        );
        store.dispatch(updateActiveLabelId(line.id));
        break;
      case LabelType.RECT:
        const rect = LabelsSelector.getActiveRectLabel();
        newImageData.labelRects = imageData.labelRects.map(
          (labelRectangle: LabelRect) => {
            if (labelRectangle.id === rect.id) {
              return {
                ...labelRectangle,
                labelId: labelNames[labelIndex].id,
                status: LabelStatus.ACCEPTED,
              };
            }
            return labelRectangle;
          }
        );
        store.dispatch(updateActiveLabelId(rect.id));
        break;
      case LabelType.POLYGON:
        const polygon = LabelsSelector.getActivePolygonLabel();
        newImageData.labelPolygons = imageData.labelPolygons.map(
          (labelPolygon: LabelPolygon) => {
            if (labelPolygon.id === polygon.id) {
              return {
                ...labelPolygon,
                labelId: labelNames[labelIndex].id,
                status: LabelStatus.ACCEPTED,
              };
            }
            return labelPolygon;
          }
        );
        store.dispatch(updateActiveLabelId(polygon.id));
        break;
      case LabelType.IMAGE_RECOGNITION:
        const labelId: string = labelNames[labelIndex].id;
        if (imageData.labelNameIds.includes(labelId)) {
          newImageData.labelNameIds = remove(
            imageData.labelNameIds,
            (element: string) => element !== labelId
          );
        } else {
          newImageData.labelNameIds = imageData.labelNameIds.concat(labelId);
        }
        break;
    }

    return newImageData;
  }
}

```

Path: src/logic/actions/LabelActions.ts
```ts
import {LabelsSelector} from '../../store/selectors/LabelsSelector';
import {ImageData, LabelLine, LabelName, LabelPoint, LabelPolygon, LabelRect} from '../../store/labels/types';
import {filter} from 'lodash';
import {store} from '../../index';
import {updateImageData, updateImageDataById} from '../../store/labels/actionCreators';
import {LabelType} from '../../data/enums/LabelType';
import {LabelUtil} from '../../utils/LabelUtil';

export class LabelActions {
    public static deleteActiveLabel() {
        const activeImageData: ImageData = LabelsSelector.getActiveImageData();
        const activeLabelId: string = LabelsSelector.getActiveLabelId();
        LabelActions.deleteImageLabelById(activeImageData.id, activeLabelId);
    }

    public static deleteImageLabelById(imageId: string, labelId: string) {
        switch (LabelsSelector.getActiveLabelType()) {
            case LabelType.POINT:
                LabelActions.deletePointLabelById(imageId, labelId);
                break;
            case LabelType.RECT:
                LabelActions.deleteRectLabelById(imageId, labelId);
                break;
            case LabelType.POLYGON:
                LabelActions.deletePolygonLabelById(imageId, labelId);
                break;
        }
    }

    public static deleteRectLabelById(imageId: string, labelRectId: string) {
        const imageData: ImageData = LabelsSelector.getImageDataById(imageId);
        const newImageData = {
            ...imageData,
            labelRects: filter(imageData.labelRects, (currentLabel: LabelRect) => {
                return currentLabel.id !== labelRectId;
            })
        };
        store.dispatch(updateImageDataById(imageData.id, newImageData));
    }

    public static deletePointLabelById(imageId: string, labelPointId: string) {
        const imageData: ImageData = LabelsSelector.getImageDataById(imageId);
        const newImageData = {
            ...imageData,
            labelPoints: filter(imageData.labelPoints, (currentLabel: LabelPoint) => {
                return currentLabel.id !== labelPointId;
            })
        };
        store.dispatch(updateImageDataById(imageData.id, newImageData));
    }

    public static deleteLineLabelById(imageId: string, labelLineId: string) {
        const imageData: ImageData = LabelsSelector.getImageDataById(imageId);
        const newImageData = {
            ...imageData,
            labelLines: filter(imageData.labelLines, (currentLabel: LabelLine) => {
                return currentLabel.id !== labelLineId;
            })
        };
        store.dispatch(updateImageDataById(imageData.id, newImageData));
    }

    public static deletePolygonLabelById(imageId: string, labelPolygonId: string) {
        const imageData: ImageData = LabelsSelector.getImageDataById(imageId);
        const newImageData = {
            ...imageData,
            labelPolygons: filter(imageData.labelPolygons, (currentLabel: LabelPolygon) => {
                return currentLabel.id !== labelPolygonId;
            })
        };
        store.dispatch(updateImageDataById(imageData.id, newImageData));
    }

    public static toggleLabelVisibilityById(imageId: string, labelId: string) {
        const imageData: ImageData = LabelsSelector.getImageDataById(imageId);
        const newImageData = {
            ...imageData,
            labelPoints: imageData.labelPoints.map((labelPoint: LabelPoint) => {
                return labelPoint.id === labelId ? LabelUtil.toggleAnnotationVisibility(labelPoint) : labelPoint
            }),
            labelRects: imageData.labelRects.map((labelRect: LabelRect) => {
                return labelRect.id === labelId ? LabelUtil.toggleAnnotationVisibility(labelRect) : labelRect
            }),
            labelPolygons: imageData.labelPolygons.map((labelPolygon: LabelPolygon) => {
                return labelPolygon.id === labelId ? LabelUtil.toggleAnnotationVisibility(labelPolygon) : labelPolygon
            }),
            labelLines: imageData.labelLines.map((labelLine: LabelLine) => {
                return labelLine.id === labelId ? LabelUtil.toggleAnnotationVisibility(labelLine) : labelLine
            }),
        };
        store.dispatch(updateImageDataById(imageData.id, newImageData));
    }

    public static removeLabelNames(labelNamesIds: string[]) {
        const imagesData: ImageData[] = LabelsSelector.getImagesData();
        const newImagesData: ImageData[] = imagesData.map((imageData: ImageData) => {
            return LabelActions.removeLabelNamesFromImageData(imageData, labelNamesIds);
        });
        store.dispatch(updateImageData(newImagesData))
    }

    private static removeLabelNamesFromImageData(imageData: ImageData, labelNamesIds: string[]): ImageData {
        return {
            ...imageData,
            labelRects: imageData.labelRects.map((labelRect: LabelRect) => {
                if (labelNamesIds.includes(labelRect.id)) {
                    return {
                        ...labelRect,
                        id: null
                    }
                } else {
                    return labelRect
                }
            }),
            labelPoints: imageData.labelPoints.map((labelPoint: LabelPoint) => {
                if (labelNamesIds.includes(labelPoint.id)) {
                    return {
                        ...labelPoint,
                        id: null
                    }
                } else {
                    return labelPoint
                }
            }),
            labelPolygons: imageData.labelPolygons.map((labelPolygon: LabelPolygon) => {
                if (labelNamesIds.includes(labelPolygon.id)) {
                    return {
                        ...labelPolygon,
                        id: null
                    }
                } else {
                    return labelPolygon
                }
            }),
            labelNameIds: imageData.labelNameIds.filter((labelNameId: string) => {
                return !labelNamesIds.includes(labelNameId)
            })
        }
    }

    public static labelExistsInLabelNames(label: string): boolean {
        const labelNames: LabelName[] = LabelsSelector.getLabelNames();
        return labelNames
            .map((labelName: LabelName) => labelName.name)
            .includes(label)
    }
}

```

Path: src/logic/actions/PopupActions.ts
```ts
import {ContextManager} from '../context/ContextManager';
import {store} from '../../index';
import {updateActivePopupType} from '../../store/general/actionCreators';

export class PopupActions {
    public static close() {
        store.dispatch(updateActivePopupType(null));
        ContextManager.restoreCtx();
    }
}
```

Path: src/logic/actions/ViewPortActions.ts
```ts
import {EditorModel} from '../../staticModels/EditorModel';
import {NumberUtil} from '../../utils/NumberUtil';
import {ViewPointSettings} from '../../settings/ViewPointSettings';
import {ISize} from '../../interfaces/ISize';
import {IRect} from '../../interfaces/IRect';
import {ImageUtil} from '../../utils/ImageUtil';
import {RectUtil} from '../../utils/RectUtil';
import {IPoint} from '../../interfaces/IPoint';
import {PointUtil} from '../../utils/PointUtil';
import {SizeUtil} from '../../utils/SizeUtil';
import {EditorActions} from './EditorActions';
import {Direction} from '../../data/enums/Direction';
import {DirectionUtil} from '../../utils/DirectionUtil';
import {GeneralSelector} from '../../store/selectors/GeneralSelector';
import {store} from '../../index';
import {updateZoom} from '../../store/general/actionCreators';

export class ViewPortActions {
    public static updateViewPortSize() {
        if (!!EditorModel.editor) {
            EditorModel.viewPortSize = {
                width: EditorModel.editor.offsetWidth,
                height: EditorModel.editor.offsetHeight
            }
        }
    }

    public static updateDefaultViewPortImageRect() {
        if (!!EditorModel.viewPortSize && !!EditorModel.image) {
            const minMargin: IPoint = {
                x: ViewPointSettings.CANVAS_MIN_MARGIN_PX,
                y: ViewPointSettings.CANVAS_MIN_MARGIN_PX
            };
            const realImageRect: IRect = {x: 0, y: 0, ...ImageUtil.getSize(EditorModel.image)};
            const viewPortWithMarginRect: IRect = {x: 0, y: 0, ...EditorModel.viewPortSize};
            const viewPortWithoutMarginRect: IRect = RectUtil
                .expand(viewPortWithMarginRect, PointUtil.multiply(minMargin, -1));
            EditorModel.defaultRenderImageRect = RectUtil
                .fitInsideRectWithRatio(viewPortWithoutMarginRect, RectUtil.getRatio(realImageRect));
        }
    }

    public static calculateViewPortContentSize(): ISize {
        if (!!EditorModel.viewPortSize && !!EditorModel.image) {
            const defaultViewPortImageRect: IRect = EditorModel.defaultRenderImageRect;
            const scaledImageSize: ISize = SizeUtil
                .scale(EditorModel.defaultRenderImageRect, GeneralSelector.getZoom());
            return {
                width: scaledImageSize.width + 2 * defaultViewPortImageRect.x,
                height: scaledImageSize.height + 2 * defaultViewPortImageRect.y
            }
        } else {
            return null;
        }
    }

    public static calculateViewPortContentImageRect(): IRect {
        if (!!EditorModel.viewPortSize && !!EditorModel.image) {
            const defaultViewPortImageRect: IRect = EditorModel.defaultRenderImageRect;
            const viewPortContentSize: ISize = ViewPortActions.calculateViewPortContentSize();
            return {
                ...defaultViewPortImageRect,
                width: viewPortContentSize.width - 2 * defaultViewPortImageRect.x,
                height: viewPortContentSize.height - 2 * defaultViewPortImageRect.y
            }
        } else {
            return null;
        }
    }

    public static resizeCanvas(newCanvasSize: ISize) {
        if (!!newCanvasSize && !!EditorModel.canvas) {
            EditorModel.canvas.width = newCanvasSize.width;
            EditorModel.canvas.height = newCanvasSize.height;
        }
    };

    public static resizeViewPortContent() {
        const viewPortContentSize = ViewPortActions.calculateViewPortContentSize();
        if (viewPortContentSize) {
            ViewPortActions.resizeCanvas(viewPortContentSize);
        }
    }

    public static calculateAbsoluteScrollPosition(relativePosition: IPoint): IPoint {
        const viewPortContentSize = ViewPortActions.calculateViewPortContentSize();
        const viewPortSize = EditorModel.viewPortSize;
        return {
            x: relativePosition.x * (viewPortContentSize.width - viewPortSize.width),
            y: relativePosition.y * (viewPortContentSize.height - viewPortSize.height)
        };
    }

    public static getRelativeScrollPosition(): IPoint {
        if (!!EditorModel.viewPortScrollbars) {
            const values = EditorModel.viewPortScrollbars.getValues();
            return {
                x: values.left,
                y: values.top
            }
        } else {
            return null;
        }
    }

    public static getAbsoluteScrollPosition(): IPoint {
        if (!!EditorModel.viewPortScrollbars) {
            const values = EditorModel.viewPortScrollbars.getValues();
            return {
                x: values.scrollLeft,
                y: values.scrollTop
            }
        } else {
            return null;
        }
    }

    public static setScrollPosition(position: IPoint) {
        EditorModel.viewPortScrollbars.scrollLeft(position.x);
        EditorModel.viewPortScrollbars.scrollTop(position.y);
    }

    public static translateViewPortPosition(direction: Direction) {
        if (EditorModel.viewPortActionsDisabled || GeneralSelector.getZoom() === ViewPointSettings.MIN_ZOOM) return;

        const directionVector: IPoint = DirectionUtil.convertDirectionToVector(direction);
        const translationVector: IPoint = PointUtil.multiply(directionVector, ViewPointSettings.TRANSLATION_STEP_PX);
        const currentScrollPosition = ViewPortActions.getAbsoluteScrollPosition();
        const nextScrollPosition = PointUtil.add(currentScrollPosition, translationVector);
        ViewPortActions.setScrollPosition(nextScrollPosition);
        EditorModel.mousePositionOnViewPortContent = PointUtil
            .add(EditorModel.mousePositionOnViewPortContent, translationVector);
        EditorActions.fullRender();
    }

    public static zoomIn() {
        if (EditorModel.viewPortActionsDisabled) return;

        const currentZoom: number = GeneralSelector.getZoom();
        const currentRelativeScrollPosition: IPoint = ViewPortActions.getRelativeScrollPosition();
        const nextRelativeScrollPosition = currentZoom === 1 ? {x: 0.5, y: 0.5} : currentRelativeScrollPosition;
        ViewPortActions.setZoom(currentZoom + ViewPointSettings.ZOOM_STEP);
        ViewPortActions.resizeViewPortContent();
        ViewPortActions.setScrollPosition(ViewPortActions.calculateAbsoluteScrollPosition(nextRelativeScrollPosition));
        EditorActions.fullRender();
    }

    public static zoomOut() {
        if (EditorModel.viewPortActionsDisabled) return;

        const currentZoom: number = GeneralSelector.getZoom();
        const currentRelativeScrollPosition: IPoint = ViewPortActions.getRelativeScrollPosition();
        ViewPortActions.setZoom(currentZoom - ViewPointSettings.ZOOM_STEP);
        ViewPortActions.resizeViewPortContent();
        ViewPortActions.setScrollPosition(ViewPortActions
            .calculateAbsoluteScrollPosition(currentRelativeScrollPosition));
        EditorActions.fullRender();
    }

    public static setDefaultZoom() {
        const currentRelativeScrollPosition: IPoint = ViewPortActions.getRelativeScrollPosition();
        ViewPortActions.setZoom(ViewPointSettings.MIN_ZOOM);
        ViewPortActions.resizeViewPortContent();
        ViewPortActions.setScrollPosition(ViewPortActions
            .calculateAbsoluteScrollPosition(currentRelativeScrollPosition));
        EditorActions.fullRender();
    }

    public static setOneForOneZoom() {
        const currentZoom: number = GeneralSelector.getZoom();
        const currentRelativeScrollPosition: IPoint = ViewPortActions.getRelativeScrollPosition();
        const nextRelativeScrollPosition = currentZoom === 1 ? {x: 0.5, y: 0.5} : currentRelativeScrollPosition;
        const nextZoom: number = EditorModel.image.width / EditorModel.defaultRenderImageRect.width
        ViewPortActions.setZoom(nextZoom);
        ViewPortActions.resizeViewPortContent();
        ViewPortActions.setScrollPosition(ViewPortActions.calculateAbsoluteScrollPosition(nextRelativeScrollPosition));
        EditorActions.fullRender();
    }

    public static setZoom(value: number) {
        const currentZoom: number = GeneralSelector.getZoom();
        const isNewValueValid: boolean = NumberUtil.isValueInRange(
            value, ViewPointSettings.MIN_ZOOM, ViewPointSettings.MAX_ZOOM);
        if (isNewValueValid && value !== currentZoom) {
            store.dispatch(updateZoom(value));
        }
    }
}

```

Path: src/logic/export/LineLabelExport.ts
```ts
import {AnnotationFormatType} from "../../data/enums/AnnotationFormatType";
import {LabelsSelector} from "../../store/selectors/LabelsSelector";
import {ImageData, LabelLine, LabelName} from "../../store/labels/types";
import {ExporterUtil} from "../../utils/ExporterUtil";
import {ImageRepository} from "../imageRepository/ImageRepository";
import {findLast} from "lodash";

export class LineLabelsExporter {
    public static export(exportFormatType: AnnotationFormatType): void {
        switch (exportFormatType) {
            case AnnotationFormatType.CSV:
                LineLabelsExporter.exportAsCSV();
                break;
            default:
                return;
        }
    }

    private static exportAsCSV(): void {
        const content: string = LabelsSelector.getImagesData()
            .map((imageData: ImageData) => {
                return LineLabelsExporter.wrapLineLabelsIntoCSV(imageData)})
            .filter((imageLabelData: string) => {
                return !!imageLabelData})
            .join("\n");
        const fileName: string = `${ExporterUtil.getExportFileName()}.csv`;
        ExporterUtil.saveAs(content, fileName);
    }

    private static wrapLineLabelsIntoCSV(imageData: ImageData): string {
        if (imageData.labelLines.length === 0 || !imageData.loadStatus)
            return null;

        const image: HTMLImageElement = ImageRepository.getById(imageData.id);
        const labelNames: LabelName[] = LabelsSelector.getLabelNames();
        const labelLinesString: string[] = imageData.labelLines.map((labelLine: LabelLine) => {
            const labelName: LabelName = findLast(labelNames, {id: labelLine.labelId});
            const labelFields = !!labelName ? [
                labelName.name,
                Math.round(labelLine.line.start.x).toString(),
                Math.round(labelLine.line.start.y).toString(),
                Math.round(labelLine.line.end.x).toString(),
                Math.round(labelLine.line.end.y).toString(),
                imageData.fileData.name,
                image.width.toString(),
                image.height.toString()
            ] : [];
            return labelFields.join(",")
        });
        return labelLinesString.join("\n");
    }
}
```

Path: src/logic/export/PointLabelsExport.ts
```ts
import {AnnotationFormatType} from "../../data/enums/AnnotationFormatType";
import {ImageData, LabelName, LabelPoint} from "../../store/labels/types";
import {ImageRepository} from "../imageRepository/ImageRepository";
import {LabelsSelector} from "../../store/selectors/LabelsSelector";
import {ExporterUtil} from "../../utils/ExporterUtil";
import {findLast} from "lodash";

export class PointLabelsExporter {
    public static export(exportFormatType: AnnotationFormatType): void {
        switch (exportFormatType) {
            case AnnotationFormatType.CSV:
                PointLabelsExporter.exportAsCSV();
                break;
            default:
                return;
        }
    }

    private static exportAsCSV(): void {
        const content: string = LabelsSelector.getImagesData()
            .map((imageData: ImageData) => {
                return PointLabelsExporter.wrapRectLabelsIntoCSV(imageData)})
            .filter((imageLabelData: string) => {
                return !!imageLabelData})
            .join("\n");
        const fileName: string = `${ExporterUtil.getExportFileName()}.csv`;
        ExporterUtil.saveAs(content, fileName);
    }

    private static wrapRectLabelsIntoCSV(imageData: ImageData): string {
        if (imageData.labelPoints.length === 0 || !imageData.loadStatus)
            return null;

        const image: HTMLImageElement = ImageRepository.getById(imageData.id);
        const labelNames: LabelName[] = LabelsSelector.getLabelNames();
        const labelRectsString: string[] = imageData.labelPoints.map((labelPoint: LabelPoint) => {
            const labelName: LabelName = findLast(labelNames, {id: labelPoint.labelId});
            const labelFields = !!labelName ? [
                labelName.name,
                Math.round(labelPoint.point.x).toString(),
                Math.round(labelPoint.point.y).toString(),
                imageData.fileData.name,
                image.width.toString(),
                image.height.toString()
            ] : [];
            return labelFields.join(",")
        });
        return labelRectsString.join("\n");
    }
}
```

Path: src/logic/export/RectLabelsExporter.ts
```ts
import {AnnotationFormatType} from '../../data/enums/AnnotationFormatType';
import {ImageData, LabelName, LabelRect} from '../../store/labels/types';
import {ImageRepository} from '../imageRepository/ImageRepository';
import JSZip from 'jszip';
import { saveAs } from 'file-saver';
import {LabelsSelector} from '../../store/selectors/LabelsSelector';
import {XMLSanitizerUtil} from '../../utils/XMLSanitizerUtil';
import {ExporterUtil} from '../../utils/ExporterUtil';
import {GeneralSelector} from '../../store/selectors/GeneralSelector';
import {findIndex, findLast} from 'lodash';
import {ISize} from '../../interfaces/ISize';
import {NumberUtil} from '../../utils/NumberUtil';
import {RectUtil} from '../../utils/RectUtil';
import {Settings} from '../../settings/Settings';

export class RectLabelsExporter {
    public static export(exportFormatType: AnnotationFormatType): void {
        switch (exportFormatType) {
            case AnnotationFormatType.YOLO:
                RectLabelsExporter.exportAsYOLO();
                break;
            case AnnotationFormatType.VOC:
                RectLabelsExporter.exportAsVOC();
                break;
            case AnnotationFormatType.CSV:
                RectLabelsExporter.exportAsCSV();
                break;
            default:
                return;
        }
    }

    private static exportAsYOLO(): void {
        const zip = new JSZip();
        LabelsSelector.getImagesData()
            .forEach((imageData: ImageData) => {
                const fileContent: string = RectLabelsExporter.wrapRectLabelsIntoYOLO(imageData);
                if (fileContent) {
                    const fileName : string = imageData.fileData.name.replace(/\.[^/.]+$/, '.txt');
                    try {
                        zip.file(fileName, fileContent);
                    } catch (error) {
                        // TODO
                        throw new Error(error as string);
                    }
                }
            });

        try {
            zip.generateAsync({type:'blob'})
                .then((content: Blob) => {
                    saveAs(content, `${ExporterUtil.getExportFileName()}.zip`);
                });
        } catch (error) {
            // TODO
            throw new Error(error as string);
        }
    }

    public static wrapRectLabelIntoYOLO(labelRect: LabelRect, labelNames: LabelName[], imageSize: ISize): string {
        const snapAndFix = (value: number) => NumberUtil.snapValueToRange(value,0, 1).toFixed(6)
        const classIdx: string = findIndex(labelNames, {id: labelRect.labelId}).toString()
        const rectCenter = RectUtil.getCenter(labelRect.rect)
        const rectSize = RectUtil.getSize(labelRect.rect)
        const rawBBox: number[] = [
            rectCenter.x / imageSize.width,
            rectCenter.y / imageSize.height,
            rectSize.width / imageSize.width,
            rectSize.height / imageSize.height
        ]

        let [x, y, width, height] = rawBBox.map((value: number) => parseFloat(snapAndFix(value)))

        if (x + width / 2 > 1) { width = 2 * (1 - x) }
        if (x - width / 2 < 0) { width = 2 * x }
        if (y + height / 2 > 1) { height = 2 * (1 - y) }
        if (y - height / 2 < 0) { height = 2 * y }

        const processedBBox = [x, y, width, height].map((value: number) => snapAndFix(value))

        return [classIdx, ...processedBBox].join(' ')
    }

    public static wrapRectLabelIntoCSV(
        labelRect: LabelRect,
        labelNames: LabelName[],
        imageSize: ISize,
        imageName: string
    ): string {
        const labelName: LabelName = findLast(labelNames, {id: labelRect.labelId});
        const labelFields = [
            !!labelName ? labelName.name: '',
            Math.round(labelRect.rect.x).toString(),
            Math.round(labelRect.rect.y).toString(),
            Math.round(labelRect.rect.width).toString(),
            Math.round(labelRect.rect.height).toString(),
            imageName,
            imageSize.width.toString(),
            imageSize.height.toString()
        ];
        return labelFields.join(Settings.CSV_SEPARATOR)
    }

    private static wrapRectLabelsIntoYOLO(imageData: ImageData): string {
        if (imageData.labelRects.length === 0 || !imageData.loadStatus)
            return null;

        const labelNames: LabelName[] = LabelsSelector.getLabelNames();
        const image: HTMLImageElement = ImageRepository.getById(imageData.id);
        const imageSize: ISize = {width: image.width, height: image.height}
        const labelRectsString: string[] = imageData.labelRects
            .filter((labelRect: LabelRect) => labelRect.labelId !== null)
            .map((labelRect: LabelRect) => {
                return RectLabelsExporter.wrapRectLabelIntoYOLO(labelRect, labelNames, imageSize)
            });
        return labelRectsString.join('\n');
    }

    private static exportAsVOC(): void {
        const zip = new JSZip();
        LabelsSelector.getImagesData().forEach((imageData: ImageData) => {
            const fileContent: string = RectLabelsExporter.wrapImageIntoVOC(imageData);
            if (fileContent) {
                const fileName : string = imageData.fileData.name.replace(/\.[^/.]+$/, '.xml');
                try {
                    zip.file(fileName, fileContent);
                } catch (error) {
                    // TODO
                    throw new Error(error as string);
                }
            }
        });

        try {
            zip.generateAsync({type:'blob'})
                .then(content => {
                    saveAs(content, `${ExporterUtil.getExportFileName()}.zip`);
                });
        } catch (error) {
            // TODO
            throw new Error(error as string);
        }
    }

    private static wrapRectLabelsIntoVOC(imageData: ImageData): string {
        if (imageData.labelRects.length === 0 || !imageData.loadStatus)
            return null;

        const labelNamesList: LabelName[] = LabelsSelector.getLabelNames();
        const labelRectsString: string[] = imageData.labelRects.map((labelRect: LabelRect) => {
            const labelName: LabelName = findLast(labelNamesList, {id: labelRect.labelId});
            const labelFields = !!labelName ? [
                `\t<object>`,
                `\t\t<name>${labelName.name}</name>`,
                `\t\t<pose>Unspecified</pose>`,
                `\t\t<truncated>0</truncated>`,
                `\t\t<difficult>0</difficult>`,
                `\t\t<bndbox>`,
                `\t\t\t<xmin>${Math.round(labelRect.rect.x)}</xmin>`,
                `\t\t\t<ymin>${Math.round(labelRect.rect.y)}</ymin>`,
                `\t\t\t<xmax>${Math.round(labelRect.rect.x + labelRect.rect.width)}</xmax>`,
                `\t\t\t<ymax>${Math.round(labelRect.rect.y + labelRect.rect.height)}</ymax>`,
                `\t\t</bndbox>`,
                `\t</object>`
            ] : [];
            return labelFields.join('\n')
        });
        return labelRectsString.join('\n');
    }

    private static wrapImageIntoVOC(imageData: ImageData): string {
        const labels: string = RectLabelsExporter.wrapRectLabelsIntoVOC(imageData);
        const projectName: string = XMLSanitizerUtil.sanitize(GeneralSelector.getProjectName());

        if (labels) {
            const image: HTMLImageElement = ImageRepository.getById(imageData.id);
            return [
                `<annotation>`,
                `\t<folder>${projectName}</folder>`,
                `\t<filename>${imageData.fileData.name}</filename>`,
                `\t<path>/${projectName}/${imageData.fileData.name}</path>`,
                `\t<source>`,
                `\t\t<database>Unspecified</database>`,
                `\t</source>`,
                `\t<size>`,
                `\t\t<width>${image.width}</width>`,
                `\t\t<height>${image.height}</height>`,
                `\t\t<depth>3</depth>`,
                `\t</size>`,
                labels,
                `</annotation>`
            ].join('\n');
        }
        return null;
    }


    private static exportAsCSV(): void {
        try {
            const contentEntries: string[] = LabelsSelector.getImagesData()
                .map((imageData: ImageData) => {
                    return RectLabelsExporter.wrapRectLabelsIntoCSV(imageData)})
                .filter((imageLabelData: string) => {
                    return !!imageLabelData})
            contentEntries.unshift(Settings.RECT_LABELS_EXPORT_CSV_COLUMN_NAMES)

            const content: string = contentEntries.join('\n');
            const fileName: string = `${ExporterUtil.getExportFileName()}.csv`;
            ExporterUtil.saveAs(content, fileName);
        } catch (error) {
            // TODO
            throw new Error(error as string);
        }
    }

    private static wrapRectLabelsIntoCSV(imageData: ImageData): string {
        if (imageData.labelRects.length === 0 || !imageData.loadStatus)
            return null;

        const image: HTMLImageElement = ImageRepository.getById(imageData.id);
        const labelNames: LabelName[] = LabelsSelector.getLabelNames();
        const imageSize: ISize = {width: image.width, height: image.height}
        const labelRectsString: string[] = imageData.labelRects
            .filter((labelRect: LabelRect) => labelRect.labelId !== null)
            .map((labelRect: LabelRect) => RectLabelsExporter.wrapRectLabelIntoCSV(
                labelRect, labelNames, imageSize, imageData.fileData.name));
        return labelRectsString.join('\n');
    }
}

```

Path: src/logic/export/TagLabelsExport.ts
```ts
import {AnnotationFormatType} from "../../data/enums/AnnotationFormatType";
import {LabelsSelector} from "../../store/selectors/LabelsSelector";
import {ImageData, LabelName} from "../../store/labels/types";
import {ExporterUtil} from "../../utils/ExporterUtil";
import {findLast} from "lodash";

export class TagLabelsExporter {
    public static export(exportFormatType: AnnotationFormatType): void {
        switch (exportFormatType) {
            case AnnotationFormatType.CSV:
                TagLabelsExporter.exportAsCSV();
                break;
            case AnnotationFormatType.JSON:
                TagLabelsExporter.exportAsJSON();
                break;
            default:
                return;
        }
    }

    private static exportAsCSV(): void {
        const content: string = LabelsSelector.getImagesData()
            .filter((imageData: ImageData) => {
                return imageData.labelNameIds.length > 0
            })
            .map((imageData: ImageData) => {
                return TagLabelsExporter.wrapLabelNamesIntoCSV(imageData)})
            .join("\n");
        const fileName: string = `${ExporterUtil.getExportFileName()}.csv`;
        ExporterUtil.saveAs(content, fileName);
    }

    private static exportAsJSON(): void {
        const contentObjects: object[] = LabelsSelector.getImagesData()
            .filter((imageData: ImageData) => {
                return imageData.labelNameIds.length > 0
            })
            .map((imageData: ImageData) => {
                return {
                    "image": imageData.fileData.name,
                    "annotations": TagLabelsExporter.wrapLabelNamesIntoJSON(imageData)
                }})
        const content: string = JSON.stringify(contentObjects);
        const fileName: string = `${ExporterUtil.getExportFileName()}.json`;
        ExporterUtil.saveAs(content, fileName);
    }

    private static wrapLabelNamesIntoCSV(imageData: ImageData): string {
        if (imageData.labelNameIds.length === 0 || !imageData.loadStatus)
            return null;

        const labelNames: LabelName[] = LabelsSelector.getLabelNames();
        const annotations: string[] = imageData.labelNameIds.map((labelNameId: string) => {
            return findLast(labelNames, {id: labelNameId}).name;
        })
        const labelFields = annotations.length !== 0 ? [
            imageData.fileData.name,
            `"[${annotations.toString()}]"`
        ] : [];
        return labelFields.join(",")
    }

    private static wrapLabelNamesIntoJSON(imageData: ImageData): string[] {
        if (imageData.labelNameIds.length === 0 || !imageData.loadStatus)
            return [];
        const labelNames: LabelName[] = LabelsSelector.getLabelNames();
        return imageData.labelNameIds.map((labelNameId: string) => {
            return findLast(labelNames, {id: labelNameId}).name;
        })
    }
}
```

Path: src/logic/export/polygon/COCOExporter.ts
```ts
import {ImageData, LabelName, LabelPolygon} from "../../../store/labels/types";
import {LabelsSelector} from "../../../store/selectors/LabelsSelector";
import {GeneralSelector} from "../../../store/selectors/GeneralSelector";
import {ImageRepository} from "../../imageRepository/ImageRepository";
import {ExporterUtil} from "../../../utils/ExporterUtil";
import {
    COCOAnnotation, COCOBBox,
    COCOCategory,
    COCOImage,
    COCOInfo,
    COCOObject,
    COCOSegmentation
} from "../../../data/labels/COCO";
import {flatten} from "lodash";
import {IPoint} from "../../../interfaces/IPoint";

export type LabelDataMap = { [key: string]: number; }

export class COCOExporter {
    public static export(): void {
        const imagesData: ImageData[] = LabelsSelector.getImagesData();
        const labelNames: LabelName[] = LabelsSelector.getLabelNames();
        const projectName: string = GeneralSelector.getProjectName();
        const COCOObject: COCOObject = COCOExporter.mapImagesDataToCOCOObject(imagesData, labelNames, projectName);
        const content: string = JSON.stringify(COCOObject);
        const fileName: string = `${ExporterUtil.getExportFileName()}.json`;
        ExporterUtil.saveAs(content, fileName);
    }

    private static mapImagesDataToCOCOObject(
        imagesData: ImageData[],
        labelNames: LabelName[],
        projectName: string
    ): COCOObject {
        return {
            "info": COCOExporter.getInfoComponent(projectName),
            "images": COCOExporter.getImagesComponent(imagesData),
            "annotations": COCOExporter.getAnnotationsComponent(imagesData, labelNames),
            "categories":COCOExporter.getCategoriesComponent(labelNames)
        }
    }

    public static getInfoComponent(description: string): COCOInfo {
        return {
            "description": description
        }
    }

    public static getCategoriesComponent(labelNames: LabelName[]): COCOCategory[] {
        return labelNames.map((labelName: LabelName, index: number) => {
            return {
                "id": index + 1,
                "name": labelName.name
            }
        })
    }

    public static getImagesComponent(imagesData: ImageData[]): COCOImage[] {
        return imagesData
            .filter((imagesData: ImageData) => imagesData.loadStatus)
            .filter((imagesData: ImageData) => imagesData.labelPolygons.length !== 0)
            .map((imageData: ImageData, index: number) => {
                const image: HTMLImageElement = ImageRepository.getById(imageData.id);
                return {
                    "id": index + 1,
                    "width": image.width,
                    "height": image.height,
                    "file_name": imageData.fileData.name
                }
            })
    }

    public static getAnnotationsComponent(imagesData: ImageData[], labelNames: LabelName[]): COCOAnnotation[] {
        const labelsMap: LabelDataMap = COCOExporter.mapLabelsData(labelNames);
        let id = 0;
        const annotations: COCOAnnotation[][] = imagesData
            .filter((imagesData: ImageData) => imagesData.loadStatus)
            .filter((imagesData: ImageData) => imagesData.labelPolygons.length !== 0)
            .map((imageData: ImageData, index: number) => {
                return imageData.labelPolygons.map((labelPolygon: LabelPolygon) => {
                    return {
                        "id": id++,
                        "iscrowd": 0,
                        "image_id": index + 1,
                        "category_id": labelsMap[labelPolygon.labelId],
                        "segmentation": COCOExporter.getCOCOSegmentation(labelPolygon.vertices),
                        "bbox": COCOExporter.getCOCOBbox(labelPolygon.vertices),
                        "area": COCOExporter.getCOCOArea(labelPolygon.vertices)
                    }
                })
            })
        return flatten(annotations);
    }

    public static mapLabelsData(labelNames: LabelName[]): LabelDataMap {
        return labelNames.reduce((data: LabelDataMap, label: LabelName, index: number) => {
            data[label.id] = index + 1;
            return data;
        }, {})
    }

    public static getCOCOSegmentation(vertices: IPoint[]): COCOSegmentation {
        const points: number[][] = vertices.map((point: IPoint) => [point.x, point.y]);
        return [flatten(points)];
    }

    public static getCOCOBbox(vertices: IPoint[]): COCOBBox {
        let xMin: number = vertices[0].x;
        let xMax: number = vertices[0].x;
        let yMin: number = vertices[0].y;
        let yMax: number = vertices[0].y;
        for (const vertex of vertices){
            if (xMin > vertex.x) xMin = vertex.x;
            if (xMax < vertex.x) xMax = vertex.x;
            if (yMin > vertex.y) yMin = vertex.y;
            if (yMax < vertex.y) yMax = vertex.y;
        }
        return [xMin, yMin, xMax - xMin, yMax - yMin];
    }

    public static getCOCOArea(vertices: IPoint[]): number {
        let area = 0;
        let j = vertices.length - 1;
        for (let  i = 0; i < vertices.length; i++) {
            area += (vertices[j].x + vertices[i].x) * (vertices[j].y - vertices[i].y);
            j = i;
        }
        return Math.abs(area/2);
    }
}
```

Path: src/logic/export/polygon/PolygonLabelsExporter.ts
```ts
import {AnnotationFormatType} from "../../../data/enums/AnnotationFormatType";
import {VGGExporter} from "./VGGExporter";
import {COCOExporter} from "./COCOExporter";

export class PolygonLabelsExporter {
    public static export(exportFormatType: AnnotationFormatType): void {
        switch (exportFormatType) {
            case AnnotationFormatType.VGG:
                VGGExporter.export();
                break;
            case AnnotationFormatType.COCO:
                COCOExporter.export();
                break;
            default:
                return;
        }
    }
}
```

Path: src/logic/export/polygon/VGGExporter.ts
```ts
import {ImageData, LabelName, LabelPolygon} from "../../../store/labels/types";
import {VGGFileData, VGGObject, VGGPolygon, VGGRegionsData} from "../../../data/labels/VGG";
import {findLast} from "lodash";
import {IPoint} from "../../../interfaces/IPoint";
import {LabelsSelector} from "../../../store/selectors/LabelsSelector";
import {ExporterUtil} from "../../../utils/ExporterUtil";

export class VGGExporter {
    public static export(): void {
        const imagesData: ImageData[] = LabelsSelector.getImagesData();
        const labelNames: LabelName[] = LabelsSelector.getLabelNames();
        const content: string = JSON.stringify(VGGExporter.mapImagesDataToVGGObject(imagesData, labelNames));
        const fileName: string = `${ExporterUtil.getExportFileName()}.json`;
        ExporterUtil.saveAs(content, fileName);
    }

    private static mapImagesDataToVGGObject(imagesData: ImageData[], labelNames: LabelName[]): VGGObject {
        return imagesData.reduce((data: VGGObject, image: ImageData) => {
            const fileData: VGGFileData = VGGExporter.mapImageDataToVGGFileData(image, labelNames);
            if (!!fileData) {
                data[image.fileData.name] = fileData
            }
            return data;
        }, {});
    }

    private static mapImageDataToVGGFileData(imageData: ImageData, labelNames: LabelName[]): VGGFileData {
        const regionsData: VGGRegionsData = VGGExporter.mapImageDataToVGG(imageData, labelNames);
        if (!regionsData) return null;
        return {
            fileref: "",
            size: imageData.fileData.size,
            filename: imageData.fileData.name,
            base64_img_data: "",
            file_attributes: {},
            regions: regionsData
        }
    }

    public static mapImageDataToVGG(imageData: ImageData, labelNames: LabelName[]): VGGRegionsData {
        if (!imageData.loadStatus || !imageData.labelPolygons || !imageData.labelPolygons.length ||
            !labelNames || !labelNames.length) return null;

        const validLabels: LabelPolygon[] = VGGExporter.getValidPolygonLabels(imageData);

        if (!validLabels.length) return null;

        return validLabels.reduce((data: VGGRegionsData, label: LabelPolygon, index: number) => {
            const labelName: LabelName = findLast(labelNames, {id: label.labelId});
            if (!!labelName) {
                data[index.toString()] = {
                    shape_attributes: VGGExporter.mapPolygonToVGG(label.vertices),
                    region_attributes: {
                        label: labelName.name
                    }
                };
            }
            return data;
        }, {})
    }

    public static getValidPolygonLabels(imageData: ImageData): LabelPolygon[] {
        return imageData.labelPolygons.filter((label: LabelPolygon) =>
            label.labelId !== null && !!label.vertices.length);
    }

    public static mapPolygonToVGG(path: src/IPoint[]): VGGPolygon {
        if (!path || !path.length) return null;

        const all_points_x: number[] = path.map((point: IPoint) => point.x).concat(path[0].x);
        const all_points_y: number[] = path.map((point: IPoint) => point.y).concat(path[0].y);
        return {
            name: "polygon",
            all_points_x,
            all_points_y
        }
    }
}
```

Path: src/logic/imageRepository/ImageLoadManager.ts
```ts
export class ImageLoadManager {

	private static queue: (() => Promise<any>)[] = [];
	private static isRunning: boolean = false;

	public static add(fx: Promise<any>) {
		ImageLoadManager.queue.push(async () => await fx);
	}

	public static run() {
		setTimeout(() => ImageLoadManager.runQueue(), 10);
	}

	public static addAndRun(fx: Promise<any>) {
		ImageLoadManager.add(fx);
		ImageLoadManager.run();
	}

	public static async runQueue() {
		if (!ImageLoadManager.isRunning) {
			ImageLoadManager.isRunning = true;
			await ImageLoadManager.runTasks();
			ImageLoadManager.isRunning = false;
		}
	}

	private static async runTasks() {
		while (ImageLoadManager.queue.length > 0) {
			const fx = ImageLoadManager.queue.shift();
			await fx();
		}
	}
}
```

Path: src/logic/imageRepository/ImageRepository.ts
```ts
import {zip} from "lodash";

export type ImageMap = { [s: string]: HTMLImageElement; };

export class ImageRepository {
    private static repository: ImageMap = {};

    public static storeImage(id: string, image: HTMLImageElement) {
        ImageRepository.repository[id] = image;
    }

    public static storeImages(ids: string[], images: HTMLImageElement[]) {
        zip(ids, images).forEach((pair: [string, HTMLImageElement]) => {
            ImageRepository.storeImage(...pair);
        })
    }

    public static getById(uuid: string): HTMLImageElement {
        return ImageRepository.repository[uuid];
    }
}
```

Path: src/logic/import/AnnotationImporter.ts
```ts
import {ImageData, LabelName} from '../../store/labels/types';
import {LabelType} from '../../data/enums/LabelType';

export type ImportResult = {
    imagesData: ImageData[]
    labelNames: LabelName[]
}

export class AnnotationImporter {
    public labelType: LabelType[]

    constructor(labelType: LabelType[]) {
        this.labelType = labelType;
    }

    public import(
        filesData: File[],
        onSuccess: (imagesData: ImageData[], labelNames: LabelName[]) => any,
        onFailure: (error?:Error) => any
    ): void {
        throw new Error('Method not implemented.');
    }
}
```

Path: src/logic/import/coco/COCOErrors.ts
```ts
export class COCOAnnotationsLoadingError extends Error {
    constructor(message) {
        super(message);
        this.name = "COCOAnnotationsLoadingError";
    }
}

export class COCOFormatValidationError extends COCOAnnotationsLoadingError {
    constructor(message) {
        super(message);
        this.name = "COCOFormatValidationError";
    }
}

export class COCOAnnotationReadingError extends COCOAnnotationsLoadingError {
    constructor() {
        super("Unexpected error occurred during reading annotations from file");
        this.name = "COCOAnnotationReadingError";
    }
}

export class COCOAnnotationDeserializationError extends COCOAnnotationsLoadingError {
    constructor() {
        super("COCO annotation file need to be in JSON format");
        this.name = "COCOAnnotationDeserializationError";
    }
}

export class COCOAnnotationFileCountError extends COCOAnnotationsLoadingError {
    constructor() {
        super("COCO annotation requires single file but multiple were given");
        this.name = "COCOAnnotationFileCountError";
    }
}
```

Path: src/logic/import/coco/COCOImporter.ts
```ts
import {ImageData, LabelName} from '../../../store/labels/types';
import {LabelsSelector} from '../../../store/selectors/LabelsSelector';
import {COCOCategory, COCOImage, COCOObject} from '../../../data/labels/COCO';
import { v4 as uuidv4 } from 'uuid';
import {ArrayUtil, PartitionResult} from '../../../utils/ArrayUtil';
import {ImageDataUtil} from '../../../utils/ImageDataUtil';
import {LabelUtil} from '../../../utils/LabelUtil';
import {
    COCOAnnotationDeserializationError,
    COCOAnnotationFileCountError,
    COCOAnnotationReadingError,
    COCOFormatValidationError
} from './COCOErrors';
import {LabelType} from '../../../data/enums/LabelType';
import {AnnotationImporter, ImportResult} from '../AnnotationImporter';
import {COCOUtils} from './COCOUtils';
import {Settings} from "../../../settings/Settings";

export type FileNameCOCOIdMap = {[ fileName: string]: number; }
export type LabelNameMap = { [labelCOCOId: number]: LabelName; }
export type ImageDataMap = { [imageCOCOId: number]: ImageData; }

export class COCOImporter extends AnnotationImporter {
    public static requiredKeys = ['images', 'annotations', 'categories']

    public import(
        filesData: File[],
        onSuccess: (imagesData: ImageData[], labelNames: LabelName[]) => any,
        onFailure: (error?:Error) => any
    ): void {
        if (filesData.length > 1) {
            onFailure(new COCOAnnotationFileCountError());
        }

        const reader = new FileReader();
        reader.readAsText(filesData[0]);
        reader.onloadend = (evt: any) => {
            try {
                const inputImagesData: ImageData[] = LabelsSelector.getImagesData();
                const annotations = COCOImporter.deserialize(evt.target.result)
                const {imagesData, labelNames} = this.applyLabels(inputImagesData, annotations);
                onSuccess(imagesData,labelNames);
            } catch (error) {
                onFailure(error as Error);
            }
        };
        reader.onerror = () => onFailure(new COCOAnnotationReadingError());
    }

    public static deserialize(text: string): COCOObject {
        try {
            return JSON.parse(text) as COCOObject
        } catch (error) {
            throw new COCOAnnotationDeserializationError()
        }
    }

    public applyLabels(imageData: ImageData[], annotationsObject: COCOObject): ImportResult {
        COCOImporter.validateCocoFormat(annotationsObject);
        const {images, categories, annotations} = annotationsObject;
        const labelNameMap: LabelNameMap = COCOImporter.mapCOCOCategories(categories);
        const cleanImageData: ImageData[] = imageData.map((item: ImageData) => ImageDataUtil.cleanAnnotations(item));
        const imageDataPartition: PartitionResult<ImageData> = COCOImporter.partitionImageData(cleanImageData, images);
        const imageDataMap: ImageDataMap = COCOImporter.mapImageData(imageDataPartition.pass, images);

        for (const annotation of annotations) {
            if (!imageDataMap[annotation.image_id] || annotation.iscrowd === 1)
                continue

            if (this.labelType.includes(LabelType.RECT)) {
                imageDataMap[annotation.image_id].labelRects.push(LabelUtil.createLabelRect(
                    labelNameMap[annotation.category_id].id,
                    COCOUtils.bbox2rect(annotation.bbox)
                ))
            }

            if (this.labelType.includes(LabelType.POLYGON)) {
                const polygons = COCOUtils.segmentation2vertices(annotation.segmentation);
                for (const polygon of polygons) {
                    imageDataMap[annotation.image_id].labelPolygons.push(LabelUtil.createLabelPolygon(
                        labelNameMap[annotation.category_id].id, polygon
                    ))
                }
            }
        }

        const resultImageData = Object.values(imageDataMap).concat(imageDataPartition.fail);

        return {
            imagesData: ImageDataUtil.arrange(resultImageData, imageData.map((item: ImageData) => item.id)),
            labelNames: Object.values(labelNameMap)
        }
    }

    protected static partitionImageData(items: ImageData[], images: COCOImage[]): PartitionResult<ImageData> {
        const imageNames: string[] = images.map((item: COCOImage) => item.file_name);
        const predicate = (item: ImageData) => imageNames.includes(item.fileData.name);
        return ArrayUtil.partition<ImageData>(items, predicate);
    }

    protected static mapCOCOCategories(categories: COCOCategory[]): LabelNameMap {
        return categories.reduce((acc: LabelNameMap, category : COCOCategory, index: number) => {
            acc[category.id] = {
                id: uuidv4(),
                name: category.name,
                color: ArrayUtil.getByInfiniteIndex(Settings.LABEL_COLORS_PALETTE, index)
            }
            return acc
        }, {});
    }

    protected static mapImageData(items: ImageData[], images: COCOImage[]): ImageDataMap {
        const fileNameCOCOIdMap: FileNameCOCOIdMap = images.reduce((acc: FileNameCOCOIdMap, image: COCOImage) => {
            acc[image.file_name] = image.id
            return acc
        }, {});
        return  items.reduce((acc: ImageDataMap, image: ImageData) => {
            acc[fileNameCOCOIdMap[image.fileData.name]] = image
            return acc;
        }, {});
    }

    public static validateCocoFormat(annotationsObject: COCOObject): void {
        const missingKeys = COCOImporter.requiredKeys.filter((key: string) => !annotationsObject.hasOwnProperty(key))
        if (missingKeys.length !== 0) {
            throw new COCOFormatValidationError(`Uploaded file does not contain all required keys: ${missingKeys}`)
        }
    }
}

```

Path: src/logic/import/coco/COCOUtils.ts
```ts
import {COCOBBox, COCOSegmentation} from "../../../data/labels/COCO";
import {IRect} from "../../../interfaces/IRect";
import {IPoint} from "../../../interfaces/IPoint";
import {chunk} from "lodash";

export class COCOUtils {
    public static bbox2rect(bbox: COCOBBox): IRect {
        return {
            x: bbox[0],
            y: bbox[1],
            width: bbox[2],
            height: bbox[3]
        }
    }

    public static segmentation2vertices(segmentation: COCOSegmentation): IPoint[][] {
        return segmentation.map((segment: number[]) => {
            return chunk(segment, 2).map((pair: number[]) => {
                return {x: pair[0], y: pair[1]}
            })
        })
    }
}
```

Path: src/logic/import/voc/VOCImporter.ts
```ts
import {ImageData, LabelName, LabelRect} from '../../../store/labels/types';
import {LabelUtil} from "../../../utils/LabelUtil";
import {AnnotationImporter} from '../AnnotationImporter';
import {LabelsSelector} from '../../../store/selectors/LabelsSelector';

type FileParseResult = {
    filename: string,
    labeledBoxes: LabelRect[]
};

type VOCImportResult = {
    labelNames: Record<string, LabelName>,
    fileParseResults: FileParseResult[],
};

export class DocumentParsingError extends Error {
    constructor(message?: string) {
        super(message);
        this.name = "DocumentParsingError";
    }
}

export class AnnotationAssertionError extends Error {
    constructor(message?: string) {
        super(message);
        this.name = "AnnotationAssertionError";
    }
}

const parser = new DOMParser();

export class VOCImporter extends AnnotationImporter {
    public import(
        filesData: File[],
        onSuccess: (imagesData: ImageData[], labelNames: LabelName[]) => any,
        onFailure: (error?:Error) => any
    ): void {
        try {
            const inputImagesData: Record<string, ImageData> = VOCImporter.mapImageData();

            this.loadAndParseFiles(filesData).then(results => {
                for (const result of results.fileParseResults) {
                    if (inputImagesData[result.filename]) {
                        inputImagesData[result.filename].labelRects = result.labeledBoxes;
                    }
                }

                onSuccess(
                    Array.from(Object.values(inputImagesData)),
                    Array.from(Object.values(results.labelNames))
                );
            }).catch((error: Error) => onFailure(error));
        } catch (error) {
            onFailure(error as Error)
        }
    }

    private loadAndParseFiles(files: File[]): Promise<VOCImportResult> {
        return Promise.all(files.map((file: File) => file.text())).then((fileTexts: string[]) =>
            fileTexts.reduce((current: VOCImportResult, fileText: string, currentIndex: number) =>
            {
                const fileName = files[currentIndex].name;
                try {
                    return VOCImporter.parseDocumentIntoImageData(VOCImporter.tryParseVOCDocument(fileText), current);
                } catch (e) {
                    if (e instanceof DocumentParsingError) {
                        throw new DocumentParsingError(`Failed trying to parse ${fileName} as VOC XML document.`)
                    } else if (e instanceof AnnotationAssertionError) {
                        throw new AnnotationAssertionError(`Failed trying to find required VOC annotations for ${fileName}.`)
                    } else {
                        throw e;
                    }
                }
            },
            {
                labelNames: {},
                fileParseResults: [],
            } as VOCImportResult)
            );
    }

    private static tryParseVOCDocument(fileText: string): Document {
        try {
            return parser.parseFromString(fileText, 'application/xml');
        } catch {
            throw new DocumentParsingError();
        }
    }

    protected static parseDocumentIntoImageData(document: Document, { fileParseResults, labelNames }: VOCImportResult): VOCImportResult {
        try {
            const root = document.getElementsByTagName('annotation')[0];
            const filename = root.getElementsByTagName('filename')[0].textContent;
            const [labeledBoxes, newLabelNames] = this.parseAnnotationsFromFileString(document, labelNames);

            return {
                labelNames: newLabelNames,
                fileParseResults: fileParseResults.concat({
                    filename,
                    labeledBoxes
                }),
            };
        } catch {
            throw new AnnotationAssertionError();
        }
    }

    protected static parseAnnotationsFromFileString(document: Document, labelNames: Record<string, LabelName>):
        [LabelRect[], Record<string, LabelName>] {
        const newLabelNames: Record<string, LabelName> = Object.assign({}, labelNames);
        return [Array.from(document.getElementsByTagName('object')).map(d => {
            const labelName = d.getElementsByTagName('name')[0].textContent;
            const bbox = d.getElementsByTagName('bndbox')[0];
            const xmin = parseInt(bbox.getElementsByTagName('xmin')[0].textContent);
            const xmax = parseInt(bbox.getElementsByTagName('xmax')[0].textContent);
            const ymin = parseInt(bbox.getElementsByTagName('ymin')[0].textContent);
            const ymax = parseInt(bbox.getElementsByTagName('ymax')[0].textContent);
            const rect = {
                x: xmin,
                y: ymin,
                height: ymax - ymin,
                width: xmax - xmin,
            };

            if (!newLabelNames[labelName]) {
                newLabelNames[labelName] = LabelUtil.createLabelName(labelName);
            }

            const labelId = newLabelNames[labelName].id;
            return LabelUtil.createLabelRect(labelId, rect);
        }), newLabelNames];
    }

    private static mapImageData(): Record<string, ImageData> {
        return LabelsSelector.getImagesData().reduce(
            (imageDataMap: Record<string, ImageData>, imageData: ImageData) => {
                imageDataMap[imageData.fileData.name] = imageData;
                return imageDataMap;
            }, {}
        );
    }
}

```

Path: src/logic/import/yolo/YOLOErrors.ts
```ts
export class YOLOAnnotationsLoadingError extends Error {
    constructor(message) {
        super(message);
        this.name = 'YOLOAnnotationsLoadingError';
    }
}

export class YOLOLabelsReadingError extends YOLOAnnotationsLoadingError {
    constructor() {
        super('Unexpected error occurred during reading label names from labels.txt file');
        this.name = 'YOLOLabelsLoadingError';
    }
}

export class NoLabelNamesFileProvidedError extends YOLOAnnotationsLoadingError {
    constructor() {
        super('For YOLO labels to be loaded correctly, labels.txt file is required');
        this.name = 'NoLabelNamesFileProvidedError';
    }
}

export class LabelNamesNotUniqueError extends YOLOAnnotationsLoadingError {
    constructor() {
        super('Label names listed in labels.txt file should be unique');
        this.name = 'LabelNamesNotUniqueError';
    }
}

export class AnnotationsParsingError extends YOLOAnnotationsLoadingError {
    constructor(imageName: string) {
        super(`Unexpected error occurred during parsing of ${imageName} annotations file`);
        this.name = 'AnnotationsParsingError';
    }
}
```

Path: src/logic/import/yolo/YOLOImporter.ts
```ts
import {AnnotationImporter} from '../AnnotationImporter';
import {ImageData, LabelName} from '../../../store/labels/types';
import {FileUtil} from '../../../utils/FileUtil';
import {ArrayUtil} from '../../../utils/ArrayUtil';
import {NoLabelNamesFileProvidedError} from './YOLOErrors';
import {LabelsSelector} from '../../../store/selectors/LabelsSelector';
import {YOLOUtils} from './YOLOUtils';
import {ImageDataUtil} from '../../../utils/ImageDataUtil';
import {zip, find} from 'lodash';
import {ImageRepository} from '../../imageRepository/ImageRepository';

export type YOLOFilesSpec = {
    labelNameFile: File
    annotationFiles: File[]
}

export class YOLOImporter extends AnnotationImporter {
    private static labelsFileName: string = 'labels.txt'

    public import(
        filesData: File[],
        onSuccess: (imagesData: ImageData[], labelNames: LabelName[]) => any,
        onFailure: (error?:Error) => any
    ): void {
        try {
            const sourceImagesData = LabelsSelector.getImagesData()
                .map((i: ImageData) => ImageDataUtil.cleanAnnotations(i));
            const {labelNameFile, annotationFiles} = YOLOImporter.filterFilesData(filesData, sourceImagesData);
            const [relevantImageData, relevantAnnotations] = YOLOImporter
                .matchImagesWithAnnotations(sourceImagesData, annotationFiles);
            const labelNamesPromise: Promise<LabelName[]> = FileUtil.readFile(labelNameFile)
                .then((fileContent: string) => YOLOUtils.parseLabelsNamesFromString(fileContent));
            const missingImagesPromise: Promise<void> = ImageDataUtil.loadMissingImages(relevantImageData);
            const annotationFilesPromise: Promise<string[]> = FileUtil.readFiles(relevantAnnotations);
            Promise
                .all([labelNamesPromise, missingImagesPromise, annotationFilesPromise])
                .then((values: [LabelName[], void, string[]]) => {
                    const [labelNames, , annotationsRaw] = values;
                    const resultImageData = zip<ImageData, string>(relevantImageData, annotationsRaw)
                        .map((pair: [ImageData, string]) => YOLOImporter.applyAnnotations(pair[0], pair[1], labelNames))
                    onSuccess(YOLOImporter.injectImageDataWithAnnotations(sourceImagesData, resultImageData), labelNames);
                })
                .catch((error: Error) => onFailure(error))
        } catch (error) {
            onFailure(error as Error)
        }
    }

    public static filterFilesData(filesData: File[], imagesData: ImageData[]): YOLOFilesSpec {
        const functionalityPartitionResult = ArrayUtil.partition(
            filesData,
            (i: File) => i.name === YOLOImporter.labelsFileName
        )
        if (functionalityPartitionResult.pass.length !== 1) {
            throw new NoLabelNamesFileProvidedError()
        }
        const imageIdentifiers: string[] = imagesData
            .map((i: ImageData) => i.fileData.name)
            .map((i: string) => FileUtil.extractFileName(i))
        const matchingPartitionResult = ArrayUtil.partition(
            filesData,
            (i: File) => imageIdentifiers.includes(FileUtil.extractFileName(i.name))
        )
        return {
            labelNameFile: functionalityPartitionResult.pass[0],
            annotationFiles: matchingPartitionResult.pass
        }
    }

    public static matchImagesWithAnnotations(images: ImageData[], annotations: File[]): [ImageData[], File[]] {
        const predicate = (image: ImageData, annotation:  File) => {
            return FileUtil.extractFileName(image.fileData.name) === FileUtil.extractFileName(annotation.name)
        }
        return ArrayUtil.unzip(
            ArrayUtil.match<ImageData, File>(images, annotations, predicate)
        );
    }

    public static applyAnnotations(imageData: ImageData, rawAnnotations: string, labelNames: LabelName[]): ImageData {
        const image: HTMLImageElement = ImageRepository.getById(imageData.id);
        imageData.labelRects = YOLOUtils.parseYOLOAnnotationsFromString(
            rawAnnotations,
            labelNames,
            {width: image.width, height: image.height},
            imageData.fileData.name
        );
        return imageData;
    }

    public static injectImageDataWithAnnotations(sourceImageData: ImageData[], annotatedImageData: ImageData[]): ImageData[] {
        return sourceImageData.map((i: ImageData) => {
            const result = find(annotatedImageData, {id: i.id});
            return result ? result : i;
        })
    }
}

```

Path: src/logic/import/yolo/YOLOUtils.ts
```ts
import {LabelName, LabelRect} from '../../../store/labels/types';
import {LabelUtil} from '../../../utils/LabelUtil';
import {AnnotationsParsingError, LabelNamesNotUniqueError} from './YOLOErrors';
import {ISize} from '../../../interfaces/ISize';
import {uniq} from 'lodash';

export class YOLOUtils {
    public static parseLabelsNamesFromString(content: string): LabelName[] {
        const labelNames: string[] = content
            .split(/[\r\n]/)
            .filter(Boolean)
            .map((name: string) => name.replace(/\s/g, ''))

        if (uniq(labelNames).length !== labelNames.length) {
            throw new LabelNamesNotUniqueError()
        }

        return labelNames
            .map((name: string) => LabelUtil.createLabelName(name))
    }

    public static loadLabelsList(
        fileData: File,
        onSuccess: (labels: LabelName[]) => void,
        onFailure: (error: Error) => void
    ) {
        const reader = new FileReader();
        reader.onloadend = (evt: ProgressEvent<FileReader>) => {
            try {
                const content: string = evt.target.result as string;
                const labelNames = YOLOUtils.parseLabelsNamesFromString(content);
                onSuccess(labelNames);
            } catch (error) {
                onFailure(error as Error)
            }
        };
        reader.readAsText(fileData);
    }

    public static parseYOLOAnnotationsFromString(
        rawAnnotations: string,
        labelNames: LabelName[],
        imageSize: ISize,
        imageName: string
    ): LabelRect[] {
        return rawAnnotations
            .split(/[\r\n]/)
            .filter(Boolean)
            .map((rawAnnotation: string) => YOLOUtils.parseYOLOAnnotationFromString(
                rawAnnotation, labelNames, imageSize, imageName
            ));
    }

    public static parseYOLOAnnotationFromString(
        rawAnnotation: string,
        labelNames: LabelName[],
        imageSize: ISize,
        imageName: string
    ): LabelRect {
        const components = rawAnnotation.split(' ');
        if (!YOLOUtils.validateYOLOAnnotationComponents(components, labelNames.length)) {
            throw new AnnotationsParsingError(imageName);
        }
        const labelIndex: number = parseInt(components[0]);
        const labelId: string = labelNames[labelIndex].id;
        const rectX: number = parseFloat(components[1]);
        const rectY: number = parseFloat(components[2]);
        const rectWidth: number = parseFloat(components[3]);
        const rectHeight: number = parseFloat(components[4]);
        const rect = {
            x: (rectX - rectWidth /2) * imageSize.width,
            y: (rectY - rectHeight /2) * imageSize.height,
            width: rectWidth * imageSize.width,
            height: rectHeight * imageSize.height
        }
        return LabelUtil.createLabelRect(labelId, rect);
    }

    public static validateYOLOAnnotationComponents(components: string[], labelNamesCount: number): boolean {
        const validateCoordinateValue = (rawValue: string): boolean => {
            const floatValue: number = Number(rawValue);
            return !isNaN(floatValue) && 0.0 <= floatValue && floatValue <= 1.0;
        }
        const validateLabelIdx = (rawValue: string): boolean => {
            const intValue: number = parseInt(rawValue);
            return !isNaN(intValue) && 0 <= intValue && intValue < labelNamesCount;
        }

        return [
            components.length === 5,
            validateLabelIdx(components[0]),
            validateCoordinateValue(components[1]),
            validateCoordinateValue(components[2]),
            validateCoordinateValue(components[3]),
            validateCoordinateValue(components[4])
        ].every(Boolean)
    }
}

```

Path: src/logic/helpers/CSSHelper.ts
```ts
import {Settings} from '../../settings/Settings';
import {AISelector} from '../../store/selectors/AISelector';

export class CSSHelper {
    public static getLeadingColor(): string {
        return AISelector.isAISSDObjectDetectorModelLoaded() || AISelector.isAIYOLOObjectDetectorModelLoaded() ||
            AISelector.isAIPoseDetectorModelLoaded() ? Settings.PRIMARY_COLOR : Settings.SECONDARY_COLOR;
    }
}

```

Path: src/logic/helpers/ViewPortHelper.ts
```ts
import {EditorData} from "../../data/EditorData";
import {MouseEventUtil} from "../../utils/MouseEventUtil";
import {EventType} from "../../data/enums/EventType";
import {store} from "../../index";
import {updateCustomCursorStyle} from "../../store/general/actionCreators";
import {CustomCursorStyle} from "../../data/enums/CustomCursorStyle";
import {EditorModel} from "../../staticModels/EditorModel";
import {IPoint} from "../../interfaces/IPoint";
import {PointUtil} from "../../utils/PointUtil";
import {ViewPortActions} from "../actions/ViewPortActions";

export class ViewPortHelper {
    private startScrollPosition: IPoint;
    private mouseStartPosition: IPoint;

    public update(data: EditorData): void {
        if (!!data.event) {
            switch (MouseEventUtil.getEventType(data.event)) {
                case EventType.MOUSE_MOVE:
                    this.mouseMoveHandler(data);
                    break;
                case EventType.MOUSE_UP:
                    this.mouseUpHandler(data);
                    break;
                case EventType.MOUSE_DOWN:
                    this.mouseDownHandler(data);
                    break;
                default:
                    break;
            }
        }
    }

    private mouseDownHandler(data: EditorData) {
        const event = data.event as MouseEvent;
        this.startScrollPosition = data.absoluteViewPortContentScrollPosition;
        this.mouseStartPosition = {x: event.screenX, y: event.screenY};

        store.dispatch(updateCustomCursorStyle(CustomCursorStyle.GRABBING));
        EditorModel.canvas.style.cursor = "none";
    }

    private mouseUpHandler(data: EditorData) {
        this.startScrollPosition = null;
        this.mouseStartPosition = null;
        store.dispatch(updateCustomCursorStyle(CustomCursorStyle.GRAB));
        EditorModel.canvas.style.cursor = "none";
    }

    private mouseMoveHandler(data: EditorData) {
        if (!!this.startScrollPosition && !!this.mouseStartPosition) {
            const event = data.event as MouseEvent;
            const currentMousePosition: IPoint = {x: event.screenX, y: event.screenY};
            const mousePositionDelta: IPoint = PointUtil.subtract(currentMousePosition, this.mouseStartPosition);
            const nextScrollPosition = PointUtil.subtract(this.startScrollPosition, mousePositionDelta);
            ViewPortActions.setScrollPosition(nextScrollPosition);
            store.dispatch(updateCustomCursorStyle(CustomCursorStyle.GRABBING));
        } else {
            store.dispatch(updateCustomCursorStyle(CustomCursorStyle.GRAB));
        }
        EditorModel.canvas.style.cursor = "none";
    }
}
```

Path: src/utils/ArrayUtil.ts
```ts
export type PartitionResult<T> = {
    pass: T[]
    fail: T[]
}

export class ArrayUtilAmbiguousMatchError extends Error {
    constructor() {
        super('Given predicate results in more than one value being matched.');
        this.name = 'ArrayUtilAmbiguousMatchError';
    }
}

export class EmptyArrayError extends Error {
    constructor() {
        super('Given array is empty.');
        this.name = 'EmptyArrayError';
    }
}

export class NegativeIndexError extends Error {
    constructor() {
        super('Index can not be negative.');
        this.name = 'NegativeIndexError';
    }
}

export class ArrayUtil {
    public static partition<T>(array: T[], predicate: (T) => boolean): PartitionResult<T> {
        return array.reduce((acc: PartitionResult<T>, item: T) => {
            if (predicate(item))
                acc.pass.push(item)
            else
                acc.fail.push(item)
            return acc
        }, {pass: [], fail: []})
    }

    public static match<T, P>(array1: T[], array2: P[], predicate: (key: T, value: P) => boolean): [T, P][] {
        return array1.reduce((acc: [T, P][], key: T) => {
            const match = array2.filter((value: P) => predicate(key, value))
            if (match.length === 1) {
                acc.push([key, match[0]])
            } else if (match.length > 1) {
                throw new ArrayUtilAmbiguousMatchError()
            }
            return acc
        }, [])
    }

    public static unzip<T, P>(array: [T, P][]): [T[], P[]] {
        return array.reduce((acc: [T[], P[]], i: [T, P]) => {
            acc[0].push(i[0]);
            acc[1].push(i[1]);
            return acc;
        }, [[], []])
    }

    public static getByInfiniteIndex<T>(array: T[], index: number): T {
        if (array.length === 0) {
            throw new EmptyArrayError()
        }
        if (index < 0) {
            throw new NegativeIndexError()
        }
        const boundedIndex: number = index % array.length
        return array[boundedIndex]
    }
}

```

Path: src/utils/CanvasUtil.ts
```ts
import React from "react";
import {IPoint} from "../interfaces/IPoint";
import {IRect} from "../interfaces/IRect";
import {ISize} from "../interfaces/ISize";

export class CanvasUtil {
    public static getMousePositionOnCanvasFromEvent(event: React.MouseEvent<HTMLCanvasElement, MouseEvent> | MouseEvent, canvas: HTMLCanvasElement): IPoint {
        if (!!canvas && !!event) {
            const canvasRect: DOMRect = canvas.getBoundingClientRect();
            return {
                x: event.clientX - canvasRect.left,
                y: event.clientY - canvasRect.top
            }
        }
        return null;
    }

    public static getClientRect(canvas: HTMLCanvasElement): IRect {
        if (canvas) {
            const canvasRect: DOMRect = canvas.getBoundingClientRect();
            return {
                x: canvasRect.left,
                y: canvasRect.top,
                width: canvasRect.width,
                height: canvasRect.height
            }
        }
        return null;
    }

    public static getSize(canvas: HTMLCanvasElement): ISize {
        if (canvas) {
            const canvasRect: DOMRect = canvas.getBoundingClientRect();
            return {
                width: canvasRect.width,
                height: canvasRect.height
            }
        }
        return null;
    }
}
```

Path: src/utils/DirectionUtil.ts
```ts
import {Direction} from "../data/enums/Direction";
import {IPoint} from "../interfaces/IPoint";

export class DirectionUtil {
    public static convertDirectionToVector(direction: Direction): IPoint {
        switch (direction) {
            case Direction.RIGHT:
                return {x: 1, y: 0};
            case Direction.LEFT:
                return {x: -1, y: 0};
            case Direction.TOP:
                return {x: 0, y: 1};
            case Direction.BOTTOM:
                return {x: 0, y: -1};
            case Direction.TOP_RIGHT:
                return {x: 1, y: 1};
            case Direction.TOP_LEFT:
                return {x: -1, y: 1};
            case Direction.BOTTOM_RIGHT:
                return {x: 1, y: -1};
            case Direction.BOTTOM_LEFT:
                return {x: -1, y: -1};
            case Direction.CENTER:
                return {x: 0, y: 0};
            default:
                return null;
        }
    }
}
```

Path: src/utils/DrawUtil.ts
```ts

import {IPoint} from '../interfaces/IPoint';
import {IRect} from '../interfaces/IRect';
import {UnitUtil} from './UnitUtil';

export class DrawUtil {

    public static clearCanvas(canvas:HTMLCanvasElement): void {
        const ctx:CanvasRenderingContext2D = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    public static drawLine(canvas:HTMLCanvasElement, startPoint:IPoint, endPoint:IPoint, color = '#111111', thickness = 1): void {
        const ctx:CanvasRenderingContext2D = canvas.getContext('2d');
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = thickness;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        ctx.lineTo(endPoint.x + 1, endPoint.y + 1);
        ctx.stroke();
        ctx.restore();
    }

    public static drawRect(canvas:HTMLCanvasElement, rect:IRect, color = '#fff', thickness = 1): void {
        const ctx:CanvasRenderingContext2D = canvas.getContext('2d');
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = thickness;
        ctx.beginPath();
        ctx.rect(rect.x, rect.y, rect.width, rect.height);
        ctx.stroke();
        ctx.restore();
    }

    public static drawRectWithFill(canvas:HTMLCanvasElement, rect:IRect, color = '#fff'): void {
        const ctx:CanvasRenderingContext2D = canvas.getContext('2d');
        ctx.save();
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.rect(rect.x, rect.y, rect.width, rect.height);
        ctx.fill();
        ctx.restore();
    }

    public static shadeEverythingButRect(canvas:HTMLCanvasElement, rect:IRect, color = 'rgba(0, 0, 0, 0.7)'): void {
        const ctx:CanvasRenderingContext2D = canvas.getContext('2d');
        ctx.save();
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
        ctx.restore();
    }

    public static drawCircleWithFill(canvas:HTMLCanvasElement, anchorPoint:IPoint, radius:number, color = '#ffffff'):void {
        const ctx:CanvasRenderingContext2D = canvas.getContext('2d');
        ctx.save();
        const startAngleRad = UnitUtil.deg2rad(0);
        const endAngleRad = UnitUtil.deg2rad(360);
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(anchorPoint.x, anchorPoint.y, radius, startAngleRad, endAngleRad, false);
        ctx.fill();
        ctx.restore();
    }

    public static drawCircle(canvas:HTMLCanvasElement, anchorPoint:IPoint, radius:number, startAngleDeg:number, endAngleDeg:number, thickness = 20, color = '#ffffff'): void {
        const ctx:CanvasRenderingContext2D = canvas.getContext('2d');
        const startAngleRad = UnitUtil.deg2rad(startAngleDeg);
        const endAngleRad = UnitUtil.deg2rad(endAngleDeg);
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = thickness;
        ctx.beginPath();
        ctx.arc(anchorPoint.x, anchorPoint.y, radius, startAngleRad, endAngleRad, false);
        ctx.stroke();
        ctx.restore();
    }

    public static drawPolygon(canvas:HTMLCanvasElement, anchors: IPoint[], color = '#fff', thickness = 1): void {
        const ctx:CanvasRenderingContext2D = canvas.getContext('2d');
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = thickness;
        ctx.beginPath();
        ctx.moveTo(anchors[0].x, anchors[0].y);
        for (let i = 1; i < anchors.length; i ++) {
            ctx.lineTo(anchors[i].x, anchors[i].y);
        }
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
    }

    public static drawPolygonWithFill(canvas:HTMLCanvasElement, anchors: IPoint[], color = '#fff'): void {
        const ctx:CanvasRenderingContext2D = canvas.getContext('2d');
        ctx.save();
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(anchors[0].x, anchors[0].y);
        for (let i = 1; i < anchors.length; i ++) {
            ctx.lineTo(anchors[i].x, anchors[i].y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    public static drawText(canvas:HTMLCanvasElement, text:string, textSize:number, anchorPoint:IPoint, color = '#ffffff', bold = false, align = 'center'):void {
        const ctx:CanvasRenderingContext2D = canvas.getContext('2d');
        ctx.save();
        ctx.fillStyle = color;
        ctx.textAlign = align as CanvasTextAlign;
        ctx.textBaseline='middle';
        ctx.font = (bold ? 'bold ' : '') + textSize + 'px Arial';
        ctx.fillText(text, anchorPoint.x, anchorPoint.y);
        ctx.restore();
    }

    public static hexToRGB(hex: string, alpha: number | null = null): string {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);

        if (alpha !== null) {
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        } else {
            return `rgb(${r}, ${g}, ${b})`;
        }
    }
}

```

Path: src/utils/EditorUtil.ts
```ts
import {CustomCursorStyle} from "../data/enums/CustomCursorStyle";
import classNames from "classnames";

export class EditorUtil {
    public static getIndicator = (cursorStyle: CustomCursorStyle): string => {
        switch (cursorStyle) {
            case CustomCursorStyle.ADD:
                return "ico/plus.png";
            case CustomCursorStyle.RESIZE:
                return "ico/resize.png";
            case CustomCursorStyle.CLOSE:
                return "ico/close.png";
            case CustomCursorStyle.MOVE:
                return "ico/move.png";
            case CustomCursorStyle.CANCEL:
                return "ico/cancel.png";
            case CustomCursorStyle.GRAB:
                return "ico/hand-fill.png";
            case CustomCursorStyle.GRABBING:
                return "ico/hand-fill-grab.png";
            default:
                return null;
        }
    };

    public static getCursorStyle = (cursorStyle: CustomCursorStyle) => {
        return classNames(
            "Cursor", {
                "move": cursorStyle === CustomCursorStyle.MOVE,
                "add": cursorStyle === CustomCursorStyle.ADD,
                "resize": cursorStyle === CustomCursorStyle.RESIZE,
                "close": cursorStyle === CustomCursorStyle.CLOSE,
                "cancel": cursorStyle === CustomCursorStyle.CANCEL,
                "grab": cursorStyle === CustomCursorStyle.GRAB,
                "grabbing": cursorStyle === CustomCursorStyle.GRABBING
            }
        );
    };
}
```

Path: src/utils/EnvironmentUtil.ts
```ts
export class EnvironmentUtil {
    public static isDev(): boolean {
        return process.env.NODE_ENV === 'development';
    }

    public static isProd(): boolean {
        return process.env.NODE_ENV === 'production';
    }
}
```

Path: src/utils/ExporterUtil.ts
```ts
import moment from 'moment';
import {GeneralSelector} from '../store/selectors/GeneralSelector';
import {saveAs} from 'file-saver';

export class ExporterUtil {
    public static getExportFileName(): string {
        const projectName: string = GeneralSelector.getProjectName();
        const date: string = moment().format('YYYY-MM-DD-hh-mm-ss');
        return `labels_${projectName}_${date}`
    }

    public static saveAs(content: string, fileName: string): void {
        const blob = new Blob([content], {type: 'text/plain;charset=utf-8'});
        try {
            saveAs(blob, fileName);
        } catch (error) {
            // TODO: Implement file save error handling
            throw new Error(error as string);
        }
    }
}

```

Path: src/utils/FileUtil.ts
```ts

export class FileUtil {
    public static loadImageBase64(fileData: File): Promise<string | ArrayBuffer> {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(fileData);
            reader.onload = () => resolve(reader.result);
            reader.onerror = (error) => reject(error);
        });
    }

    public static loadImage(fileData: File): Promise<HTMLImageElement> {
        return new Promise((resolve, reject) => {
            const url = URL.createObjectURL(fileData);
            const image = new Image();
            image.src = url;
            image.onload = () => resolve(image);
            image.onerror = reject;
        });
    }

    public static loadImages(fileData: File[]): Promise<HTMLImageElement[]> {
        return new Promise((resolve, reject) => {
            const promises: Promise<HTMLImageElement>[] = fileData.map((data: File) => FileUtil.loadImage(data));
            Promise
                .all(promises)
                .then((values: HTMLImageElement[]) => resolve(values))
                .catch((error) => reject(error));
        });
    }

    public static readFile(fileData: File): Promise<string> {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = (event: any) => {
                resolve(event?.target?.result);
            };
            reader.onerror = reject;
            reader.readAsText(fileData);
        });
    }

    public static readFiles(fileData: File[]): Promise<string[]> {
        return new Promise((resolve, reject) => {
            const promises: Promise<string>[] = fileData.map((data: File) => FileUtil.readFile(data));
            Promise
                .all(promises)
                .then((values: string[]) => resolve(values))
                .catch((error) => reject(error));
        });
    }

    public static extractFileExtension(name: string): string | null {
        const parts = name.split('.');
        return parts.length > 1 ? parts[parts.length - 1] : null;
    }

    public static extractFileName(name: string): string | null {
        const splitPath = name.split('.');
        let fName = '';
        for (const idx of Array(splitPath.length - 1).keys()) {
            if (fName === '') fName += splitPath[idx];
            else fName += '.' + splitPath[idx];
        }
        return fName;
    }
}

```

Path: src/utils/ImageDataUtil.ts
```ts
import {ImageData} from '../store/labels/types';
import { v4 as uuidv4 } from 'uuid';
import {FileUtil} from './FileUtil';
import {ImageRepository} from '../logic/imageRepository/ImageRepository';

export class ImageDataUtil {
    public static createImageDataFromFileData(fileData: File): ImageData {
        return {
            id: uuidv4(),
            fileData,
            loadStatus: false,
            labelRects: [],
            labelPoints: [],
            labelLines: [],
            labelPolygons: [],
            labelNameIds: [],
            isVisitedByYOLOObjectDetector: false,
            isVisitedBySSDObjectDetector: false,
            isVisitedByPoseDetector: false,
            isVisitedByRoboflowAPI: false
        }
    }

    public static cleanAnnotations(item: ImageData): ImageData {
        return {
            ...item,
            labelRects: [],
            labelPoints: [],
            labelLines: [],
            labelPolygons: [],
            labelNameIds: []
        }
    }

    public static arrange(items: ImageData[], idArrangement: string[]): ImageData[] {
        return items.sort((a: ImageData, b: ImageData) => {
            return idArrangement.indexOf(a.id) - idArrangement.indexOf(b.id)
        })
    }

    public static loadMissingImages(images: ImageData[]): Promise<void> {
        return new Promise((resolve, reject) => {
            const missingImages = images.filter((i: ImageData) => !i.loadStatus);
            const missingImagesFiles = missingImages.map((i: ImageData) => i.fileData);
            FileUtil.loadImages(missingImagesFiles)
                .then((htmlImageElements:HTMLImageElement[]) => {
                    ImageRepository.storeImages(missingImages.map((i: ImageData) => i.id), htmlImageElements);
                    resolve()
                })
                .catch((error: Error) => reject(error));
        });
    }
}

```

Path: src/utils/ImageUtil.ts
```ts
import {ISize} from "../interfaces/ISize";

export class ImageUtil {
    public static getSize(image: HTMLImageElement): ISize {
        if (!image) return null;
        return {
            width: image.width,
            height: image.height
        }
    }
}
```

Path: src/utils/LabelUtil.ts
```ts
import {Annotation, LabelName, LabelPoint, LabelPolygon, LabelRect} from '../store/labels/types';
import { v4 as uuidv4 } from 'uuid';
import {find} from 'lodash';
import {IRect} from '../interfaces/IRect';
import {LabelStatus} from '../data/enums/LabelStatus';
import {IPoint} from '../interfaces/IPoint';
import { sample } from 'lodash';
import {Settings} from '../settings/Settings';

export class LabelUtil {
    public static createLabelName(name: string): LabelName {
        return {
            id: uuidv4(),
            name,
            color: sample(Settings.LABEL_COLORS_PALETTE)
        }
    }

    public static createLabelRect(labelId: string, rect: IRect): LabelRect {
        return {
            id: uuidv4(),
            labelId,
            rect,
            isVisible: true,
            isCreatedByAI: false,
            status: LabelStatus.ACCEPTED,
            suggestedLabel: null
        }
    }

    public static createLabelPolygon(labelId: string, vertices: IPoint[]): LabelPolygon {
        return {
            id: uuidv4(),
            labelId,
            vertices,
            isVisible: true
        }
    }

    public static createLabelPoint(labelId: string, point: IPoint): LabelPoint {
        return {
            id: uuidv4(),
            labelId,
            point,
            isVisible: true,
            isCreatedByAI: false,
            status: LabelStatus.ACCEPTED,
            suggestedLabel: null
        }
    }

    public static toggleAnnotationVisibility<AnnotationType extends Annotation>(annotation: AnnotationType): AnnotationType {
        return {
            ...annotation,
            isVisible: !annotation.isVisible
        }
    }

    public static labelNamesIdsDiff(oldLabelNames: LabelName[], newLabelNames: LabelName[]): string[] {
        return oldLabelNames.reduce((missingIds: string[], labelName: LabelName) => {
            if (!find(newLabelNames, { 'id': labelName.id })) {
                missingIds.push(labelName.id);
            }
            return missingIds
        }, [])
    }
}

```

Path: src/utils/LineUtil.ts
```ts
import {ILine} from "../interfaces/ILine";
import {IPoint} from "../interfaces/IPoint";

export class LineUtil {
    public static getDistanceFromLine(l: ILine, p: IPoint): number {
        if (l.start.x !== l.end.x || l.start.y !== l.end.y) {
            const nom: number = Math.abs((l.end.y - l.start.y) * p.x - (l.end.x - l.start.x) * p.y + l.end.x * l.start.y - l.end.y * l.start.x);
            const denom: number = Math.sqrt(Math.pow(l.end.y - l.start.y, 2) + Math.pow(l.end.x - l.start.x, 2));
            return nom / denom;
        }
        return null;
    }

    public static getCenter(l: ILine): IPoint {
        return {
            x: (l.start.x + l.end.x) / 2,
            y: (l.start.y + l.end.y) / 2
        }
    }

    public static getPoints(l: ILine): IPoint[] {
        return [l.start, l.end]
    }
}
```

Path: src/utils/MouseEventUtil.ts
```ts
import {EventType} from "../data/enums/EventType";

export class MouseEventUtil {
    public static getEventType(event: Event): EventType | null {
        if (!event) return null;

        switch (event.type) {
            case EventType.MOUSE_DOWN:
                return EventType.MOUSE_DOWN;
            case EventType.MOUSE_UP:
                return EventType.MOUSE_UP;
            case EventType.MOUSE_MOVE:
                return EventType.MOUSE_MOVE;
            default:
                return null;
        }
    }
}
```

Path: src/utils/NotificationUtil.ts
```ts
import {INotification} from '../store/notifications/types';
import {v4 as uuidv4} from 'uuid';
import {NotificationType} from '../data/enums/NotificationType';
import {NotificationContent} from "../data/info/NotificationsData";

export class NotificationUtil {
    public static createErrorNotification(content: NotificationContent): INotification {
        return {
            id: uuidv4(),
            type: NotificationType.ERROR,
            header: content.header,
            description: content.description
        }
    }

    public static createMessageNotification(content: NotificationContent): INotification {
        return {
            id: uuidv4(),
            type: NotificationType.MESSAGE,
            header: content.header,
            description: content.description
        }
    }

    public static createWarningNotification(content: NotificationContent): INotification {
        return {
            id: uuidv4(),
            type: NotificationType.WARNING,
            header: content.header,
            description: content.description
        }
    }
}

```

Path: src/utils/NumberUtil.ts
```ts
export class NumberUtil {
    public static snapValueToRange(value: number, min: number, max: number): number {
        if (value < min)
            return min;
        if (value > max)
            return max;
        return value;
    }

    public static isValueInRange(value: number, min: number, max: number): boolean {
        return value >= min && value <= max;
    }
}

```

Path: src/utils/PlatformUtil.ts
```ts
import {MobileDeviceData} from "../data/MobileDeviceData";
import MobileDetect from 'mobile-detect'

export class PlatformUtil {
    public static getMobileDeviceData(userAgent: string): MobileDeviceData {
        const mobileDetect = new MobileDetect(userAgent);
        return {
            manufacturer: mobileDetect.mobile(),
            browser: mobileDetect.userAgent(),
            os: mobileDetect.os()
        }
    }

    public static isMac(userAgent: string): boolean {
        return !!userAgent.toLowerCase().match("mac");
    }

    public static isSafari(userAgent: string): boolean {
        return !!userAgent.toLowerCase().match("safari");
    }

    public static isFirefox(userAgent: string): boolean {
        return !!userAgent.toLowerCase().match("firefox");
    }
}
```

Path: src/utils/PointUtil.ts
```ts
import {IPoint} from '../interfaces/IPoint';

export class PointUtil {
    public static equals(p1: IPoint, p2: IPoint): boolean {
        return p1.x === p2.x && p1.y === p2.y;
    }

    public static add(p1: IPoint, p2: IPoint): IPoint {
        return {
            x: p1.x + p2.x,
            y: p1.y + p2.y
        }
    }

    public static subtract(p1: IPoint, p2: IPoint): IPoint {
        return {
            x: p1.x - p2.x,
            y: p1.y - p2.y
        }
    }

    public static multiply(p1: IPoint, factor: number) {
        return {
            x: p1.x * factor,
            y: p1.y * factor
        }
    }
}
```

Path: src/utils/PolygonUtil.ts
```ts
import {IPoint} from '../interfaces/IPoint';
import {ILine} from '../interfaces/ILine';

export class PolygonUtil {
    public static getEdges(vertices: IPoint[], closed: boolean = true): ILine[] {
        const points: IPoint[] = closed ? vertices.concat(vertices[0]) : vertices;
        const lines: ILine[] = [];
        for (let i = 0; i < points.length - 1; i++) {
            lines.push({start: points[i], end: points[i + 1]})
        }
        return lines;
    }
}

```

Path: src/utils/RectUtil.ts
```ts
import {IRect} from '../interfaces/IRect';
import {IPoint} from '../interfaces/IPoint';
import {ISize} from '../interfaces/ISize';
import {RectAnchor} from '../data/RectAnchor';
import {NumberUtil} from './NumberUtil';
import {Direction} from '../data/enums/Direction';

export class RectUtil {
    public static getRatio(rect: IRect): number {
        if (!rect) return null;

        return rect.width/rect.height
    }

    public static intersect(r1: IRect, r2: IRect) {
        if (!r1 || !r2) return null;
        return !(
            r2.x > r1.x + r1.width ||
            r2.x + r2.width < r1.x ||
            r2.y > r1.y + r1.height ||
            r2.y + r2.height < r1.y
        );
    }

    public static isPointInside(rect: IRect, point: IPoint): boolean {
        if (!rect || !point) return null;
        return (
            rect.x <= point.x &&
            rect.x + rect.width >= point.x &&
            rect.y <= point.y &&
            rect.y + rect.height >= point.y
        )
    }

    public static getRectWithCenterAndSize(centerPoint: IPoint, size: ISize): IRect {
        return {
            x: centerPoint.x - 0.5 * size.width,
            y: centerPoint.y - 0.5 * size.height,
            ...size
        }
    }

    public static fitInsideRectWithRatio(containerRect: IRect, ratio: number): IRect {
        const containerRectRatio = RectUtil.getRatio(containerRect);
        if (containerRectRatio < ratio) {
            const innerRectHeight = containerRect.width / ratio;
            return {
                x: containerRect.x,
                y: containerRect.y + (containerRect.height - innerRectHeight) / 2,
                width: containerRect.width,
                height: innerRectHeight
            }
        }
        else {
            const innerRectWidth = containerRect.height * ratio;
            return {
                x: containerRect.x + (containerRect.width - innerRectWidth) / 2,
                y: containerRect.y,
                width: innerRectWidth,
                height: containerRect.height
            }
        }
    }

    public static resizeRect(inputRect: IRect, rectAnchor: Direction, delta): IRect {
        const rect: IRect = {...inputRect};
        switch (rectAnchor) {
            case Direction.RIGHT:
                rect.width += delta.x;
                break;
            case Direction.BOTTOM_RIGHT:
                rect.width += delta.x;
                rect.height += delta.y;
                break;
            case Direction.BOTTOM:
                rect.height += delta.y;
                break;
            case Direction.TOP_RIGHT:
                rect.width += delta.x;
                rect.y += delta.y;
                rect.height -= delta.y;
                break;
            case Direction.TOP:
                rect.y += delta.y;
                rect.height -= delta.y;
                break;
            case Direction.TOP_LEFT:
                rect.x += delta.x;
                rect.width -= delta.x;
                rect.y += delta.y;
                rect.height -= delta.y;
                break;
            case Direction.LEFT:
                rect.x += delta.x;
                rect.width -= delta.x;
                break;
            case Direction.BOTTOM_LEFT:
                rect.x += delta.x;
                rect.width -= delta.x;
                rect.height += delta.y;
                break;
        }

        if (rect.width < 0) {
            rect.x = rect.x + rect.width;
            rect.width = -rect.width;
        }

        if (rect.height < 0) {
            rect.y = rect.y + rect.height;
            rect.height = -rect.height;
        }

        return rect;
    }

    public static translate(rect: IRect, delta: IPoint): IRect {
        return {
            ...rect,
            x: rect.x + delta.x,
            y: rect.y + delta.y
        }
    }

    public static expand(rect: IRect, delta: IPoint): IRect {
        return {
            x: rect.x - delta.x,
            y: rect.y - delta.y,
            width: rect.width + 2 * delta.x,
            height: rect.height + 2 * delta.y
        }
    }

    public static scaleRect(rect:IRect, scale: number): IRect {
        return {
            x: rect.x * scale,
            y: rect.y * scale,
            width: rect.width * scale,
            height: rect.height * scale
        }
    }

    public static mapRectToAnchors(rect: IRect): RectAnchor[] {
        return [
            {type: Direction.TOP_LEFT, position: {x: rect.x, y: rect.y}},
            {type: Direction.TOP, position: {x: rect.x + 0.5 * rect.width, y: rect.y}},
            {type: Direction.TOP_RIGHT, position: {x: rect.x + rect.width, y: rect.y}},
            {type: Direction.LEFT, position: {x: rect.x, y: rect.y + 0.5 * rect.height}},
            {type: Direction.RIGHT, position: {x: rect.x + rect.width, y: rect.y + 0.5 * rect.height}},
            {type: Direction.BOTTOM_LEFT, position: {x: rect.x, y: rect.y + rect.height}},
            {type: Direction.BOTTOM, position: {x: rect.x + 0.5 * rect.width, y: rect.y + rect.height}},
            {type: Direction.BOTTOM_RIGHT, position: {x: rect.x + rect.width, y: rect.y + rect.height}}
        ]
    }

    public static snapPointToRect(point: IPoint, rect: IRect): IPoint {
        if (RectUtil.isPointInside(rect, point))
            return point;

        return {
            x: NumberUtil.snapValueToRange(point.x, rect.x, rect.x + rect.width),
            y: NumberUtil.snapValueToRange(point.y, rect.y, rect.y + rect.height)
        }
    }

    public static getCenter(rect: IRect): IPoint {
        return {
            x: rect.x + rect.width / 2,
            y: rect.y + rect.height / 2
        }
    }

    public static getSize(rect: IRect): ISize {
        return {
            width: rect.width,
            height: rect.height
        }
    }

    public static getVertices(rect: IRect): IPoint[] {
        return [
            { x: rect.x, y: rect.y },
            { x: rect.x + rect.width, y: rect.y },
            { x: rect.x + rect.width, y: rect.y + rect.height },
            { x: rect.x, y: rect.y + rect.height }
        ]
    }
}



```

Path: src/utils/RenderEngineUtil.ts
```ts
import {EditorData} from '../data/EditorData';
import {RectUtil} from './RectUtil';
import {store} from '../index';
import {CustomCursorStyle} from '../data/enums/CustomCursorStyle';
import {updateCustomCursorStyle} from '../store/general/actionCreators';
import {IPoint} from '../interfaces/IPoint';
import {PointUtil} from './PointUtil';
import {IRect} from '../interfaces/IRect';
import {ILine} from '../interfaces/ILine';
import {LineUtil} from './LineUtil';
import {PolygonUtil} from './PolygonUtil';

export class RenderEngineUtil {
    public static calculateImageScale(data: EditorData): number {
        return data.realImageSize.width / data.viewPortContentImageRect.width;
    }

    public static isMouseOverImage(data: EditorData): boolean {
        return RectUtil.isPointInside(data.viewPortContentImageRect, data.mousePositionOnViewPortContent);
    }

    public static isMouseOverCanvas(data: EditorData): boolean {
        return RectUtil.isPointInside({x: 0, y: 0, ...data.viewPortContentSize}, data.mousePositionOnViewPortContent);
    }

    public static transferPointFromImageToViewPortContent(point: IPoint, data: EditorData): IPoint {
        const scale = RenderEngineUtil.calculateImageScale(data);
        return PointUtil.add(PointUtil.multiply(point, 1/scale), data.viewPortContentImageRect);
    }

    public static transferPolygonFromImageToViewPortContent(polygon: IPoint[], data: EditorData): IPoint[] {
        return polygon.map((point: IPoint) => RenderEngineUtil.transferPointFromImageToViewPortContent(point, data));
    }

    public static transferLineFromImageToViewPortContent(line: ILine, data: EditorData): ILine {
        return {
            start: RenderEngineUtil.transferPointFromImageToViewPortContent(line.start, data),
            end: RenderEngineUtil.transferPointFromImageToViewPortContent(line.end, data)
        }
    }

    public static transferPointFromViewPortContentToImage(point: IPoint, data: EditorData): IPoint {
        const scale = RenderEngineUtil.calculateImageScale(data);
        return PointUtil.multiply(PointUtil.subtract(point, data.viewPortContentImageRect), scale);
    }

    public static transferPolygonFromViewPortContentToImage(polygon: IPoint[], data: EditorData): IPoint[] {
        return polygon.map((point: IPoint) => RenderEngineUtil.transferPointFromViewPortContentToImage(point, data));
    }

    public static transferLineFromViewPortContentToImage(line: ILine, data: EditorData): ILine {
        return {
            start: RenderEngineUtil.transferPointFromViewPortContentToImage(line.start, data),
            end: RenderEngineUtil.transferPointFromViewPortContentToImage(line.end, data)
        }
    }

    public static transferRectFromViewPortContentToImage(rect: IRect, data: EditorData): IRect {
        const scale = RenderEngineUtil.calculateImageScale(data);
        return RectUtil.translate(RectUtil.scaleRect(rect, 1/scale), data.viewPortContentImageRect);
    }

    public static transferRectFromImageToViewPortContent(rect: IRect, data: EditorData): IRect {
        const scale = RenderEngineUtil.calculateImageScale(data);
        const translation: IPoint = {
            x: - data.viewPortContentImageRect.x,
            y: - data.viewPortContentImageRect.y
        };

        return RectUtil.scaleRect(RectUtil.translate(rect, translation), scale);
    }

    public static wrapDefaultCursorStyleInCancel(data: EditorData) {
        if (RectUtil.isPointInside(data.viewPortContentImageRect, data.mousePositionOnViewPortContent)) {
            store.dispatch(updateCustomCursorStyle(CustomCursorStyle.DEFAULT));
        } else {
            store.dispatch(updateCustomCursorStyle(CustomCursorStyle.CANCEL));
        }
    }

    public static setValueBetweenPixels(value: number): number {
        return Math.floor(value) + 0.5;
    }

    public static setPointBetweenPixels(point: IPoint): IPoint {
        return {
            x: RenderEngineUtil.setValueBetweenPixels(point.x),
            y: RenderEngineUtil.setValueBetweenPixels(point.y)
        }
    }

    public static setRectBetweenPixels(rect: IRect): IRect {
        const topLeft: IPoint = {
            x: rect.x,
            y: rect.y
        };
        const bottomRight: IPoint = {
            x: rect.x + rect.width,
            y: rect.y + rect.height
        };
        const topLeftBetweenPixels = RenderEngineUtil.setPointBetweenPixels(topLeft);
        const bottomRightBetweenPixels = RenderEngineUtil.setPointBetweenPixels(bottomRight);
        return {
            x: topLeftBetweenPixels.x,
            y: topLeftBetweenPixels.y,
            width: bottomRightBetweenPixels.x - topLeftBetweenPixels.x,
            height: bottomRightBetweenPixels.y - topLeftBetweenPixels.y
        }
    }

    public static isMouseOverLine(mouse: IPoint, line: ILine, radius: number): boolean {
        const minX: number = Math.min(line.start.x, line.end.x);
        const maxX: number = Math.max(line.start.x, line.end.x);
        const minY: number = Math.min(line.start.y, line.end.y);
        const maxY: number = Math.max(line.start.y, line.end.y);

        return (minX - radius <= mouse.x && maxX + radius >= mouse.x) &&
            (minY - radius <= mouse.y && maxY + radius >= mouse.y) &&
            LineUtil.getDistanceFromLine(line, mouse) < radius;
    }

    public static isMouseOverAnchor(mouse: IPoint, anchor: IPoint, radius: number): boolean {
        const anchorSize = { width: 2 * radius, height: 2 * radius}
        return RectUtil.isPointInside(RectUtil.getRectWithCenterAndSize(anchor, anchorSize), mouse);
    }

    public static isMouseOverPolygon(mouse: IPoint, vertices: IPoint[], radius: number): boolean {
        for (const vertex of vertices) {
            if (RenderEngineUtil.isMouseOverAnchor(mouse, vertex, radius)) return true;
        }
        const edges = PolygonUtil.getEdges(vertices)
        for (const edge of edges) {
            if (RenderEngineUtil.isMouseOverLine(mouse, edge, radius)) return true;
        }
        return false;
    }
}

```

Path: src/utils/SizeUtil.ts
```ts
import {ISize} from "../interfaces/ISize";

export class SizeUtil {
    public static scale(size: ISize, scale: number): ISize {
        return {
            width: size.width * scale,
            height: size.height * scale
        }
    }
}
```

Path: src/utils/UnitUtil.ts
```ts
export class UnitUtil {

    public static deg2rad(angleDeg:number) {
        return(angleDeg * Math.PI/180);
    }

    public static rad2deg(angleRad:number) {
        return(angleRad * 180/Math.PI);
    }
}
```

Path: src/utils/VirtualListUtil.ts
```ts
import {ISize} from "../interfaces/ISize";
import {IPoint} from "../interfaces/IPoint";

export class VirtualListUtil {
    public static calculateGridSize(listSize: ISize, childSize: ISize, childCount: number): ISize {
        const columnCount: number = Math.floor(listSize.width / childSize.width);
        const rowCount: number = Math.ceil(childCount / columnCount);
        return {width: columnCount, height: rowCount};
    }

    public static calculateContentSize(listSize: ISize, childSize: ISize, gridSize: ISize): ISize {
        const sizeFromGrid:ISize = {
            width: childSize.width * gridSize.width,
            height: childSize.height * gridSize.height
        };

        return {
            width: Math.max(listSize.width, sizeFromGrid.width),
            height: sizeFromGrid.height
        }
    }

    public static calculateAnchorPoints(listSize: ISize, childSize: ISize, childCount: number): IPoint[] {
        const gridSize: ISize = VirtualListUtil.calculateGridSize(listSize, childSize, childCount);
        const contentWrapperSize: ISize = VirtualListUtil.calculateContentSize(listSize, childSize, gridSize);
        const horizontalMargin = (contentWrapperSize.width - gridSize.width * childSize.width) / (gridSize.width + 1);

        const anchors = [];
        for (let i = 0; i < childCount; i++) {
            const rowCount: number = Math.floor(i / gridSize.width);
            const columnCount: number = i % gridSize.width;

            const anchor: IPoint = {
                x: rowCount * horizontalMargin + columnCount * childSize.width,
                y: rowCount * childSize.height
            };
            anchors.push(anchor);
        }
        return anchors;
    }
}
```

Path: src/utils/XMLSanitizerUtil.ts
```ts
export class XMLSanitizerUtil {
    public static sanitize(input: string): string {
        return input
            .replace('<', '&lt;')
            .replace('>', '&gt;')
            .replace('&', '&amp;')
            .replace("'", '&#39;')
            .replace("/", '&#x2F;')
    }
}
```

Path: src/utils/__tests__/ArrayUtil.test.ts
```ts
import {ArrayUtil, ArrayUtilAmbiguousMatchError, EmptyArrayError, NegativeIndexError} from '../ArrayUtil';


describe('ArrayUtil partition method', () => {
    it('should return empty PartitionResult if array is empty', () => {
        // when
        const result = ArrayUtil.partition([], (item: any) => true)

        // then
        expect(result.pass.length).toEqual(0);
        expect(result.fail.length).toEqual(0);
    });

    it('should pass even numbers and fail odd numbers', () => {
        // given
        const items = [1, 2, 3, 4, 5, 6]
        const predicate = (item: number) => item % 2 === 0

        // when
        const result = ArrayUtil.partition(items, predicate)

        // then
        expect(result.pass).toEqual([2, 4 ,6]);
        expect(result.fail).toEqual([1, 3, 5]);
    });

    it('should pass items with key name from list', () => {
        // given
        type MockObject = {
            name: string
        }

        const nameList = ['aaa', 'bbb', 'ccc']
        const items = [
            {name: 'aaa'},
            {name: 'aab'},
            {name: 'abb'},
            {name: 'bbb'}
        ]
        const predicate = (item: MockObject) => nameList.includes(item.name)

        // when
        const result = ArrayUtil.partition(items, predicate)

        // then
        expect(result.pass.length).toEqual(2);
        expect(result.fail.length).toEqual(2);
        expect(result.pass.map((item: MockObject) => item.name)).toEqual(['aaa', 'bbb']);
        expect(result.fail.map((item: MockObject) => item.name)).toEqual(['aab', 'abb']);
    });
});

describe('ArrayUtil match method', () => {
    it('should return empty array', () => {
        // when
        const result = ArrayUtil.match([], [], (k, v) => true)

        // then
        expect(result.length).toEqual(0);
    });

    it('should return correct array when number of keys and values is even', () => {
        // when
        const result = ArrayUtil.match([4, 2, 1, 3], [1, 2, 4, 3], (k, v) => k === v)

        // then
        const expectedResult = [[4, 4], [2, 2], [1, 1], [3, 3]];
        expect(result.length).toEqual(4);
        expect(JSON.stringify(result)).toEqual(JSON.stringify(expectedResult));
    });

    it('should return correct array when number of keys smaller than values', () => {
        // given
        const array1 = ['aa', 'bb', 'cc',];
        const array2 = ['bb1', 'aa2', 'cc4', 'cc3', 'aa1', 'bb2', 'aa3'];
        const predicate = (k, v) => v.startsWith(k);

        function wrapper() {
            return ArrayUtil.match(array1, array2, predicate)
        }
        expect(wrapper).toThrowError(new ArrayUtilAmbiguousMatchError());
    });
});

describe('ArrayUtil getByInfiniteIndex method', () => {
    it('should throw EmptyArrayError', () => {
        // then
        expect(() => { ArrayUtil.getByInfiniteIndex([], 0); }).toThrowError(new EmptyArrayError())
    })

    it('should throw NegativeIndexError', () => {
        // then
        expect(() => { ArrayUtil.getByInfiniteIndex([1], -1); }).toThrowError(new NegativeIndexError())
    })

    it('should return correct element', () => {
        // given
        const array = [1, 2, 3, 4, 5];
        // when
        const result = ArrayUtil.getByInfiniteIndex(array, 11)
        // then
        expect(result).toBe(2);
    })
})

```

Path: src/utils/__tests__/DrawUtil.test.ts
```ts
import {DrawUtil} from '../DrawUtil';

describe('DrawUtil hexToRGB method', () => {
    it('should return correct white rgb value when alpha is null', () => {
        // given
        const hex = '#ffffff'
        // when
        const result = DrawUtil.hexToRGB(hex)
        // then
        expect(result).toEqual('rgb(255, 255, 255)');
    })

    it('should return correct black rgb value when alpha is null', () => {
        // given
        const hex = '#000000'
        // when
        const result = DrawUtil.hexToRGB(hex)
        // then
        expect(result).toEqual('rgb(0, 0, 0)');
    })

    it('should return correct rgba value when alpha is null', () => {
        // given
        const hex = '#000000'
        const alpha = 0.5
        // when
        const result = DrawUtil.hexToRGB(hex, alpha)
        // then
        expect(result).toEqual('rgba(0, 0, 0, 0.5)');
    })
})

```

Path: src/utils/__tests__/FileUtil.test.ts
```ts
import {FileUtil} from "../FileUtil";

describe('FileUtil extractFileExtension method', () => {
    it('should return file extension', () => {
        // given
        const name: string = "labels.txt";

        // when
        const result = FileUtil.extractFileExtension(name);

        // then
        const expectedResult = "txt";
        expect(result).toEqual(expectedResult);
    });

    it('should return file extension even with multiple dots', () => {
        // given
        const name: string = "custom.file-name.12.labels.txt";

        // when
        const result = FileUtil.extractFileExtension(name);

        // then
        const expectedResult = "txt";
        expect(result).toEqual(expectedResult);
    });

    it('should return null', () => {
        // given
        const name: string = "labels";

        // when
        const result = FileUtil.extractFileExtension(name);

        // then
        const expectedResult = null;
        expect(result).toEqual(expectedResult);
    });
});

describe('FileUtil extractFileName method', () => {
    it('should return file name', () => {
        // given
        const name: string = "labels.txt";

        // when
        const result = FileUtil.extractFileName(name);

        // then
        const expectedResult = "labels";
        expect(result).toEqual(expectedResult);
    });

    it('should return file name even with multiple dots', () => {
        // given
        const name: string = "custom.file-name.12.labels.txt";

        // when
        const result = FileUtil.extractFileName(name);

        // then
        const expectedResult = "custom.file-name.12.labels";
        expect(result).toEqual(expectedResult);
    });
});
```

Path: src/utils/__tests__/ImageDataUtil.test.ts
```ts
import { ImageData } from '../../store/labels/types';
import { v4 as uuidv4 } from 'uuid';
import { LabelUtil } from '../LabelUtil';
import { ImageDataUtil } from '../ImageDataUtil';
import { AcceptedFileType } from '../../data/enums/AcceptedFileType';


const getDummyImageData = (id: string): ImageData => {
    return {
        id,
        fileData: new File([''], 'filename.txt', { type: AcceptedFileType.TEXT }),
        loadStatus: true,
        labelRects: [],
        labelPoints: [],
        labelLines: [],
        labelPolygons: [],
        labelNameIds: [],
        isVisitedByYOLOObjectDetector: false,
        isVisitedBySSDObjectDetector: false,
        isVisitedByPoseDetector: false,
        isVisitedByRoboflowAPI: false
    };
};


describe('ImageDataUtil cleanAnnotation method', () => {
    it('should return new ImageData object without annotations', () => {
        // given
        const item: ImageData = getDummyImageData(uuidv4());
        item.labelRects = [
            LabelUtil.createLabelRect('label-id', { x: 1, y: 1, width: 1, height: 1 }),
            LabelUtil.createLabelRect('label-id', { x: 1, y: 1, width: 1, height: 1 })
        ];

        // when
        const result = ImageDataUtil.cleanAnnotations(item);

        // then
        expect(result.labelRects.length).toEqual(0);
        expect(item.labelRects.length).toEqual(2);
    });
});

describe('ImageDataUtil arrange method', () => {
    it('should return new array with correctly arranged ImageData objects', () => {
        // given
        const idA = uuidv4(), idB = uuidv4(), idC = uuidv4(), idD = uuidv4();
        const givenIdArrangement = [idD, idA, idB, idC];
        const expectedIdArrangement = [idA, idB, idC, idD];
        const items = givenIdArrangement.map((id: string) => getDummyImageData(id));

        // when
        const result = ImageDataUtil.arrange(items, expectedIdArrangement);
        const resultIdArrangement = result.map((item: ImageData) => item.id);

        // then
        expect(JSON.stringify(expectedIdArrangement)).toBe(JSON.stringify(resultIdArrangement));
    });
});

```

Path: src/utils/__tests__/LabelUtil.test.ts
```ts
import { IRect } from '../../interfaces/IRect';
import { LabelUtil } from '../LabelUtil';
import {LabelPoint, LabelPolygon, LabelRect} from '../../store/labels/types';
import {LabelStatus} from '../../data/enums/LabelStatus';
import {IPoint} from '../../interfaces/IPoint';

const mockUUID: string = '123e4567-e89b-12d3-a456-426614174000'

jest.mock('uuid', () => ({ v4: () => mockUUID }));

describe('LabelUtil createLabelRect method', () => {
    it('return correct LabelRect object', () => {
        // given
        const labelId: string = '1';
        const rect: IRect = {
            x: 100,
            y: 100,
            width: 100,
            height: 100
        };

        // when
        const result = LabelUtil.createLabelRect(labelId, rect);

        // then
        const expectedResult: LabelRect = {
            id: mockUUID,
            labelId,
            rect,
            isVisible: true,
            isCreatedByAI: false,
            status: LabelStatus.ACCEPTED,
            suggestedLabel: null
        }
        expect(result).toEqual(expectedResult);
    });
});

describe('LabelUtil createLabelPolygon method', () => {
    it('return correct LabelPolygon object', () => {
        // given
        const labelId: string = '1';
        const vertices: IPoint[] = [
            {
                x: 100,
                y: 100
            },
            {
                x: 100,
                y: 200
            },
            {
                x: 200,
                y: 100
            }
        ];

        // when
        const result = LabelUtil.createLabelPolygon(labelId, vertices);

        // then
        const expectedResult: LabelPolygon = {
            id: mockUUID,
            labelId,
            vertices,
            isVisible: true
        }
        expect(result).toEqual(expectedResult);
    });
});

describe('LabelUtil createLabelPoint method', () => {
    it('return correct LabelPoint object', () => {
        // given
        const labelId: string = '1';
        const point: IPoint = {
            x: 100,
            y: 100
        };

        // when
        const result = LabelUtil.createLabelPoint(labelId, point);

        // then
        const expectedResult: LabelPoint = {
            id: mockUUID,
            labelId,
            point,
            isVisible: true,
            isCreatedByAI: false,
            status: LabelStatus.ACCEPTED,
            suggestedLabel: null
        }
        expect(result).toEqual(expectedResult);
    });
});

```

Path: src/utils/__tests__/LineUtil.test.ts
```ts
import {RectUtil} from '../RectUtil';
import {ILine} from '../../interfaces/ILine';
import {LineUtil} from '../LineUtil';
import {IPoint} from '../../interfaces/IPoint';

describe('LineUtil getCenter method', () => {
    it('should return correct value for horizontal line', () => {
        const givenLine: ILine = {
            start: {x: -10, y: 0},
            end: {x: 10, y: 0},
        };
        const expectedPoint: IPoint = {
            x: 0,
            y: 0
        };
        expect(LineUtil.getCenter(givenLine)).toEqual(expectedPoint);
    });

    it('should return correct value for vertical line', () => {
        const givenLine: ILine = {
            start: {x: 1, y: 0},
            end: {x: 1, y: 5},
        };
        const expectedPoint: IPoint = {
            x: 1,
            y: 2.5
        };
        expect(LineUtil.getCenter(givenLine)).toEqual(expectedPoint);
    });

    it('should return correct value for biased line', () => {
        const givenLine: ILine = {
            start: {x: 0, y: 0},
            end: {x: -10, y: -5},
        };
        const expectedPoint: IPoint = {
            x: -5,
            y: -2.5
        };
        expect(LineUtil.getCenter(givenLine)).toEqual(expectedPoint);
    });

    it('should return null', () => {
        expect(RectUtil.getRatio(null)).toBe(null);
    });
});

describe('LineUtil getDistanceFromLine method', () => {
    it('should return correct value for horizontal line', () => {
        const givenLine: ILine = {
            start: {x: -10, y: 0},
            end: {x: 10, y: 0},
        };
        const givenPoint: IPoint = {
            x: 0,
            y: 3
        };
        const expectedDistance: number = 3;
        expect(LineUtil.getDistanceFromLine(givenLine, givenPoint)).toBe(expectedDistance);
    });

    it('should return correct value for vertical line', () => {
        const givenLine: ILine = {
            start: {x: 1, y: 0},
            end: {x: 1, y: 5},
        };
        const givenPoint: IPoint = {
            x: 10,
            y: 2.5
        };
        const expectedDistance: number = 9;
        expect(LineUtil.getDistanceFromLine(givenLine, givenPoint)).toBe(expectedDistance);
    });

    it('should return correct value for biased line', () => {
        const givenLine: ILine = {
            start: {x: 0, y: 0},
            end: {x: 8, y: 6},
        };
        const givenPoint: IPoint = {
            x: 1,
            y: 7
        };
        const expectedDistance: number = 5;
        expect(LineUtil.getDistanceFromLine(givenLine, givenPoint)).toBe(expectedDistance);
    });

    it('should return null', () => {
        const givenLine: ILine = {
            start: {x: 1, y: 0},
            end: {x: 1, y: 0},
        };
        const givenPoint: IPoint = {
            x: 10,
            y: 2.5
        };

        expect(LineUtil.getDistanceFromLine(givenLine, givenPoint)).toBe(null);
    });
});
```

Path: src/utils/__tests__/NumberUtil.test.ts
```ts
import {NumberUtil} from "../NumberUtil";

describe('NumberUtil snapValueToRange method', () => {
    it('should return value rounded to the upper bound', () => {
        const result: number = NumberUtil.snapValueToRange(1.0000005, 0, 1)
        expect(result).toBe(1);
    });
    it('should return value rounded to the lower bound', () => {
        const result: number = NumberUtil.snapValueToRange(-0.0000005, 0, 1)
        expect(result).toBe(0);
    });
    it('should return unmodified value', () => {
        const result: number = NumberUtil.snapValueToRange(0.5, 0, 1)
        expect(result).toBe(0.5);
    });
});

```

Path: src/utils/__tests__/RectUtil.test.ts
```ts
import {RectUtil} from '../RectUtil';
import {IRect} from '../../interfaces/IRect';
import {IPoint} from '../../interfaces/IPoint';
import {ISize} from '../../interfaces/ISize';

describe('RectUtil getRatio method', () => {
    it('should return correct value of rect ratio', () => {
        // given
        const rect: IRect = {x: 0, y: 0, width: 10, height: 5};
        // when
        const result = RectUtil.getRatio(rect)
        // then
        expect(result).toBe(2);
    });

    it('should return null', () => {
        expect(RectUtil.getRatio(null)).toBe(null);
    });
});

describe('RectUtil getCenter method', () => {
    it('should return correct center value', () => {
        // given
        const rect: IRect = {x: 0, y: 0, width: 10, height: 20};
        const expectedResult: IPoint = {x: 5, y: 10};
        // when
        const result = RectUtil.getCenter(rect)
        // then
        expect(result).toMatchObject(expectedResult);
    })
})

describe('RectUtil getSize method', () => {
    it('should return correct size value', () => {
        // given
        const rect: IRect = {x: 0, y: 0, width: 10, height: 20};
        const expectedSize: ISize = {width: 10, height: 20};
        // when
        const result = RectUtil.getSize(rect)
        // then
        expect(result).toMatchObject(expectedSize);
    })
})

```

Path: src/utils/__tests__/RenderEngineUtil.test.ts
```ts
import {ILine} from '../../interfaces/ILine';
import {IPoint} from '../../interfaces/IPoint';
import {RenderEngineUtil} from '../RenderEngineUtil';

describe('RenderEngineUtil.isMouseOverLine tests', () => {
    test('return true when mouse directly over start point', () => {
        // given
        const mouse: IPoint = { x: 10, y: 10 };
        const line: ILine = {
            start: { x: 10, y: 10 },
            end: { x: 10, y: 20 }
        }
        const radius = 1;

        // when
        const result = RenderEngineUtil.isMouseOverLine(mouse, line, radius);

        // then
        expect(result).toBe(true);
    });

    test('return true when mouse directly over end point', () => {
        // given
        const mouse: IPoint = { x: 10, y: 20 };
        const line: ILine = {
            start: { x: 10, y: 10 },
            end: { x: 10, y: 20 }
        }
        const radius = 1;

        // when
        const result = RenderEngineUtil.isMouseOverLine(mouse, line, radius);

        // then
        expect(result).toBe(true);
    });

    test('return true when mouse within radius from start point vertically', () => {
        // given
        const mouse: IPoint = { x: 10, y: 10 - 0.99 };
        const line: ILine = {
            start: { x: 10, y: 10 },
            end: { x: 10, y: 20 }
        }
        const radius = 1;

        // when
        const result = RenderEngineUtil.isMouseOverLine(mouse, line, radius);

        // then
        expect(result).toBe(true);
    });

    test('return false when mouse outside radius from start point vertically', () => {
        // given
        const mouse: IPoint = { x: 10, y: 10 - 1.01 };
        const line: ILine = {
            start: { x: 10, y: 10 },
            end: { x: 10, y: 20 }
        }
        const radius = 1;

        // when
        const result = RenderEngineUtil.isMouseOverLine(mouse, line, radius);

        // then
        expect(result).toBe(false);
    });

    test('return true when mouse within radius from start point horizontally', () => {
        // given
        const mouse: IPoint = { x: 10 - 0.99, y: 10 };
        const line: ILine = {
            start: { x: 10, y: 10 },
            end: { x: 10, y: 20 }
        }
        const radius = 1;

        // when
        const result = RenderEngineUtil.isMouseOverLine(mouse, line, radius);

        // then
        expect(result).toBe(true);
    });

    test('return false when mouse outside radius from start point horizontally', () => {
        // given
        const mouse: IPoint = { x: 10 - 1.01, y: 10 };
        const line: ILine = {
            start: { x: 10, y: 10 },
            end: { x: 10, y: 20 }
        }
        const radius = 1;

        // when
        const result = RenderEngineUtil.isMouseOverLine(mouse, line, radius);

        // then
        expect(result).toBe(false);
    });

    test('return true when mouse within radius from end point vertically', () => {
        // given
        const mouse: IPoint = { x: 10, y: 20 + 0.99 };
        const line: ILine = {
            start: { x: 10, y: 10 },
            end: { x: 10, y: 20 }
        }
        const radius = 1;

        // when
        const result = RenderEngineUtil.isMouseOverLine(mouse, line, radius);

        // then
        expect(result).toBe(true);
    });

    test('return false when mouse outside radius from end point vertically', () => {
        // given
        const mouse: IPoint = { x: 10, y: 20 + 1.01 };
        const line: ILine = {
            start: { x: 10, y: 10 },
            end: { x: 10, y: 20 }
        }
        const radius = 1;

        // when
        const result = RenderEngineUtil.isMouseOverLine(mouse, line, radius);

        // then
        expect(result).toBe(false);
    });

    test('return true when mouse within radius from end point horizontally', () => {
        // given
        const mouse: IPoint = { x: 10 - 0.99, y: 20 };
        const line: ILine = {
            start: { x: 10, y: 10 },
            end: { x: 10, y: 20 }
        }
        const radius = 1;

        // when
        const result = RenderEngineUtil.isMouseOverLine(mouse, line, radius);

        // then
        expect(result).toBe(true);
    });

    test('return false when mouse outside radius from end point horizontally', () => {
        // given
        const mouse: IPoint = { x: 10 - 1.01, y: 20 };
        const line: ILine = {
            start: { x: 10, y: 10 },
            end: { x: 10, y: 20 }
        }
        const radius = 1;

        // when
        const result = RenderEngineUtil.isMouseOverLine(mouse, line, radius);

        // then
        expect(result).toBe(false);
    });

    test('return true when mouse within radius from line horizontally', () => {
        // given
        const mouse: IPoint = { x: 10 - 0.99, y: 15 };
        const line: ILine = {
            start: { x: 10, y: 10 },
            end: { x: 10, y: 20 }
        }
        const radius = 1;

        // when
        const result = RenderEngineUtil.isMouseOverLine(mouse, line, radius);

        // then
        expect(result).toBe(true);
    });

    test('return false when mouse outside radius from line horizontally', () => {
        // given
        const mouse: IPoint = { x: 10 - 1.01, y: 15 };
        const line: ILine = {
            start: { x: 10, y: 10 },
            end: { x: 10, y: 20 }
        }
        const radius = 1;

        // when
        const result = RenderEngineUtil.isMouseOverLine(mouse, line, radius);

        // then
        expect(result).toBe(false);
    });

    test('return true when mouse within radius from line vertically', () => {
        // given
        const mouse: IPoint = { x: 15, y: 10 - 0.99 };
        const line: ILine = {
            start: { x: 10, y: 10 },
            end: { x: 20, y: 10 }
        }
        const radius = 1;

        // when
        const result = RenderEngineUtil.isMouseOverLine(mouse, line, radius);

        // then
        expect(result).toBe(true);
    });

    test('return false when mouse outside radius from line vertically', () => {
        // given
        const mouse: IPoint = { x: 15, y: 10 - 1.01 };
        const line: ILine = {
            start: { x: 10, y: 10 },
            end: { x: 20, y: 10 }
        }
        const radius = 1;

        // when
        const result = RenderEngineUtil.isMouseOverLine(mouse, line, radius);

        // then
        expect(result).toBe(false);
    });
});

```

Path: src/ai/PoseDetector.ts
```ts
import * as posenet from '@tensorflow-models/posenet';
import {PoseNet} from '@tensorflow-models/posenet';
import {Pose} from '@tensorflow-models/posenet';
import {store} from '../index';
import {updatePoseDetectorStatus} from '../store/ai/actionCreators';
import {AIPoseDetectionActions} from '../logic/actions/AIPoseDetectionActions';
import {LabelType} from '../data/enums/LabelType';
import {LabelsSelector} from '../store/selectors/LabelsSelector';
import {updateActiveLabelType} from '../store/labels/actionCreators';
import {submitNewNotification} from '../store/notifications/actionCreators';
import {NotificationUtil} from '../utils/NotificationUtil';
import {NotificationsDataMap} from '../data/info/NotificationsData';
import {Notification} from '../data/enums/Notification';

export class PoseDetector {
    private static model: PoseNet;

    public static loadModel(callback?: () => unknown) {
        posenet
            .load({
                architecture: 'ResNet50',
                outputStride: 32,
                inputResolution: 257,
                quantBytes: 2
            })
            .then((model: PoseNet) => {
                PoseDetector.model = model;
                store.dispatch(updatePoseDetectorStatus(true));
                store.dispatch(updateActiveLabelType(LabelType.POINT));
                const activeLabelType: LabelType = LabelsSelector.getActiveLabelType();
                if (activeLabelType === LabelType.POINT) {
                    AIPoseDetectionActions.detectPoseForActiveImage();
                }
                if (callback) {
                    callback();
                }
            })
            .catch((error) => {
                // TODO: Introduce central logging system like Sentry
                store.dispatch(
                    submitNewNotification(
                        NotificationUtil.createErrorNotification(
                            NotificationsDataMap[Notification.MODEL_DOWNLOAD_ERROR]
                        )
                    )
                )
            })
    }

    public static predict(image: HTMLImageElement, callback?: (predictions: Pose[]) => unknown) {
        if (!PoseDetector.model) return;

        PoseDetector.model
            .estimateMultiplePoses(image)
            .then((predictions: Pose[]) => {
                if (callback) {
                    callback(predictions)
                }
            })
            .catch((error) => {
                // TODO: Introduce central logging system like Sentry
                store.dispatch(
                    submitNewNotification(
                        NotificationUtil.createErrorNotification(
                            NotificationsDataMap[Notification.MODEL_INFERENCE_ERROR]
                        )
                    )
                )
            })
    }
}

```

Path: src/ai/RoboflowAPIObjectDetector.ts
```ts
import axios from 'axios';
import { FileUtil } from '../utils/FileUtil';
import {ImageData} from '../store/labels/types';
import { RoboflowAPIDetails } from '../store/ai/types';
import { store } from '../index';
import { updateRoboflowAPIDetails } from '../store/ai/actionCreators';
import { updateActiveLabelType } from '../store/labels/actionCreators';
import { LabelType } from '../data/enums/LabelType';
import { LabelsSelector } from '../store/selectors/LabelsSelector';
import { AIRoboflowAPIObjectDetectionActions } from '../logic/actions/AIRoboflowAPIObjectDetectionActions';
import { AISelector } from '../store/selectors/AISelector';

interface RoboflowPrediction {
    x: number;
    y: number;
    width: number;
    height: number;
    confidence: number;
    class: string;
}

export interface DetectedObject {
    x: number;
    y: number;
    width: number;
    height: number;
    score: number;
    class: string;
}

export class RoboflowAPIObjectDetector {

    public static loadModel(
        roboflowAPIDetails: RoboflowAPIDetails,
        onSuccess?: () => any,
        onFailure?: () => any
    ) {
        store.dispatch(updateRoboflowAPIDetails(roboflowAPIDetails));
        store.dispatch(updateActiveLabelType(LabelType.RECT));
        const activeLabelType: LabelType = LabelsSelector.getActiveLabelType();
        if (activeLabelType === LabelType.RECT) {
            const activeImageData: ImageData = LabelsSelector.getActiveImageData();

            const wrappedOnFailure = () => {
                store.dispatch(updateRoboflowAPIDetails({status: false, model: '', key: ''}));
                onFailure()
            }

            RoboflowAPIObjectDetector.predict(activeImageData, onSuccess, wrappedOnFailure)
        }
    }

    public static predict(
        imageData: ImageData,
        onSuccess?: (predictions: DetectedObject[]) => any,
        onFailure?: () => any
    ) {
        const roboflowAPIDetails: RoboflowAPIDetails = AISelector.getRoboflowAPIDetails();
        FileUtil.loadImageBase64(imageData.fileData).then((data) => {
            axios({
                method: 'POST',
                url: 'https://detect.roboflow.com/' + roboflowAPIDetails.model,
                params: {
                    api_key: roboflowAPIDetails.key
                },
                data,
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded'
                }
            })
                .then((response) => {
                    const predictions: DetectedObject[] = (response.data.predictions as RoboflowPrediction[])
                        .map((prediction: RoboflowPrediction) => {
                            return {
                                x: prediction.x - prediction.width / 2,
                                y: prediction.y - prediction.height /2,
                                width: prediction.width,
                                height: prediction.height,
                                score: prediction.confidence,
                                class: prediction.class
                            }
                        });
                    onSuccess(predictions)
                })
                .catch(onFailure)
        })
    }
}
```

Path: src/ai/SSDObjectDetector.ts
```ts
import * as cocoSsd from '@tensorflow-models/coco-ssd';
import {DetectedObject, ObjectDetection} from '@tensorflow-models/coco-ssd';
import {store} from '../index';
import {updateSSDObjectDetectorStatus} from '../store/ai/actionCreators';
import {LabelType} from '../data/enums/LabelType';
import {LabelsSelector} from '../store/selectors/LabelsSelector';
import {AISSDObjectDetectionActions} from '../logic/actions/AISSDObjectDetectionActions';
import {updateActiveLabelType} from '../store/labels/actionCreators';
import {submitNewNotification} from '../store/notifications/actionCreators';
import {NotificationUtil} from '../utils/NotificationUtil';
import {NotificationsDataMap} from '../data/info/NotificationsData';
import {Notification} from '../data/enums/Notification';

export class SSDObjectDetector {
    private static model: ObjectDetection;

    public static loadModel(callback?: () => any) {
        cocoSsd
            .load()
            .then((model: ObjectDetection) => {
                SSDObjectDetector.model = model;
                store.dispatch(updateSSDObjectDetectorStatus(true));
                store.dispatch(updateActiveLabelType(LabelType.RECT));
                const activeLabelType: LabelType = LabelsSelector.getActiveLabelType();
                if (activeLabelType === LabelType.RECT) {
                    AISSDObjectDetectionActions.detectRectsForActiveImage();
                }
                if (callback) {
                    callback();
                }
            })
            .catch((error) => {
                // TODO: Introduce central logging system like Sentry
                store.dispatch(
                    submitNewNotification(
                        NotificationUtil.createErrorNotification(
                            NotificationsDataMap[Notification.MODEL_DOWNLOAD_ERROR]
                        )
                    )
                )
            })
    }

    public static predict(image: HTMLImageElement, callback?: (predictions: DetectedObject[]) => any) {
        if (!SSDObjectDetector.model) return;

        SSDObjectDetector.model
            .detect(image)
            .then((predictions: DetectedObject[]) => {
                if (callback) {
                    callback(predictions)
                }
            })
            .catch((error) => {
                // TODO: Introduce central logging system like Sentry
                store.dispatch(
                    submitNewNotification(
                        NotificationUtil.createErrorNotification(
                            NotificationsDataMap[Notification.MODEL_INFERENCE_ERROR]
                        )
                    )
                )
            })
    }
}

```

Path: src/ai/YOLOV5ObjectDetector.ts
```ts
import {DetectedObject, load, YOLOv5, ModelConfig} from 'yolov5js'
import {store} from '../index';
import {updateYOLOV5ObjectDetectorStatus} from '../store/ai/actionCreators';
import {updateActiveLabelType} from '../store/labels/actionCreators';
import {LabelType} from '../data/enums/LabelType';
import {NotificationUtil} from '../utils/NotificationUtil';
import {NotificationsDataMap} from '../data/info/NotificationsData';
import {Notification} from '../data/enums/Notification';
import {submitNewNotification} from '../store/notifications/actionCreators';
import {LabelsSelector} from '../store/selectors/LabelsSelector';
import {AIYOLOObjectDetectionActions} from '../logic/actions/AIYOLOObjectDetectionActions';
import {ImageData} from '../store/labels/types';
import {ImageRepository} from '../logic/imageRepository/ImageRepository';

export class YOLOV5ObjectDetector {
    private static model: YOLOv5;

    public static loadModel(modelConfig: ModelConfig, onSuccess?: () => any, onFailure?: () => any) {
        const activeImageData: ImageData = LabelsSelector.getActiveImageData();
        const image = ImageRepository.getById(activeImageData.id)
        YOLOV5ObjectDetector.loadModelSafely(modelConfig, image)
            .then((model: YOLOv5) => {
                YOLOV5ObjectDetector.model = model;
                store.dispatch(updateYOLOV5ObjectDetectorStatus(true));
                store.dispatch(updateActiveLabelType(LabelType.RECT));
                const activeLabelType: LabelType = LabelsSelector.getActiveLabelType();
                if (activeLabelType === LabelType.RECT) {
                    AIYOLOObjectDetectionActions.detectRectsForActiveImage();
                }
                if (onSuccess) onSuccess()
            })
            .catch((error) => {
                // tslint:disable-next-line:no-console
                console.log(error)
                if (onFailure) onFailure()
            })
    }

    private static loadModelSafely(modelConfig: ModelConfig, image: HTMLImageElement): Promise<YOLOv5> {
        return new Promise( (resolve, reject) => {
            load(modelConfig, [640, 640])
                .then((model640: YOLOv5) => {
                    model640.detect(image)
                        .then((detections: DetectedObject[]) => resolve(model640))
                        .catch((error: Error) => {
                            load(modelConfig, [1280, 1280])
                                .then((model1280: YOLOv5) => {
                                    model1280.detect(image)
                                        .then((detections: DetectedObject[]) => resolve(model1280))
                                        .catch(reject)
                                })
                                .catch(reject)
                        })
                })
                .catch(reject)
        });
    }

    public static predict(image: HTMLImageElement, callback?: (predictions: DetectedObject[]) => any) {
        if (!YOLOV5ObjectDetector.model) return;

        YOLOV5ObjectDetector.model
            .detect(image)
            .then((predictions: DetectedObject[]) => {
                if (callback) {
                    callback(predictions)
                }
            })
            .catch((error) => {
                // tslint:disable-next-line:no-console
                console.log(error)
                // TODO: Introduce central logging system like Sentry
                store.dispatch(
                    submitNewNotification(
                        NotificationUtil.createErrorNotification(
                            NotificationsDataMap[Notification.MODEL_INFERENCE_ERROR]
                        )
                    )
                )
            })
    }
}

```

Path: src/data/EditorData.ts
```ts
import {IPoint} from '../interfaces/IPoint';
import {IRect} from '../interfaces/IRect';
import {ISize} from '../interfaces/ISize';

export interface EditorData {
    viewPortContentSize: ISize,
    mousePositionOnViewPortContent: IPoint,
    activeKeyCombo: string[],
    event?: Event
    zoom: number,
    viewPortSize: ISize,
    defaultRenderImageRect: IRect,
    realImageSize: ISize,
    viewPortContentImageRect: IRect,
    absoluteViewPortContentScrollPosition: IPoint
}

```

Path: src/data/ExportFormatData.ts
```ts
import {ILabelFormatData} from '../interfaces/ILabelFormatData';
import {LabelType} from './enums/LabelType';
import {AnnotationFormatType} from './enums/AnnotationFormatType';

export type ExportFormatDataMap = Record<LabelType, ILabelFormatData[]>;

export const ExportFormatData: ExportFormatDataMap = {
    [LabelType.RECT]: [
        {
            type: AnnotationFormatType.YOLO,
            label: 'A .zip package containing files in YOLO format.'
        },
        {
            type: AnnotationFormatType.VOC,
            label: 'A .zip package containing files in VOC XML format.'
        },
        {
            type: AnnotationFormatType.CSV,
            label: 'Single CSV file.'
        }
    ],
    [LabelType.POINT]: [
        {
            type: AnnotationFormatType.CSV,
            label: 'Single CSV file.'
        }
    ],
    [LabelType.LINE]: [
        {
            type: AnnotationFormatType.CSV,
            label: 'Single CSV file.'
        }
    ],
    [LabelType.POLYGON]: [
        {
            type: AnnotationFormatType.VGG,
            label: 'Single file in VGG JSON format.'
        },
        {
            type: AnnotationFormatType.COCO,
            label: 'Single file in COCO JSON format.'
        }
    ],
    [LabelType.IMAGE_RECOGNITION]: [
        {
            type: AnnotationFormatType.CSV,
            label: 'Single CSV file.'
        },
        {
            type: AnnotationFormatType.JSON,
            label: 'Single JSON file.'
        }
    ]
}

```

Path: src/data/HotKeyAction.ts
```ts
export type HotKeyAction = {
    keyCombo: string[];
    action: (event: KeyboardEvent) => unknown;
}
```

Path: src/data/ImportFormatData.ts
```ts
import {LabelType} from './enums/LabelType';
import {ILabelFormatData} from '../interfaces/ILabelFormatData';
import {AnnotationFormatType} from './enums/AnnotationFormatType';

export type ImportFormatDataMap = Record<LabelType, ILabelFormatData[]>

export const ImportFormatData: ImportFormatDataMap = {
    [LabelType.RECT]: [
        {
            type: AnnotationFormatType.COCO,
            label: 'Single file in COCO JSON format.'
        },
        {
            type: AnnotationFormatType.YOLO,
            label: 'Multiple files in YOLO format along with labels names definition - labels.txt file.'
        },
        {
            type: AnnotationFormatType.VOC,
            label: 'Multiple files in VOC XML format.'
        }
    ],
    [LabelType.POINT]: [],
    [LabelType.LINE]: [],
    [LabelType.POLYGON]: [
        {
            type: AnnotationFormatType.COCO,
            label: 'Single file in COCO JSON format.'
        }
    ],
    [LabelType.IMAGE_RECOGNITION]: []
}

```

Path: src/data/ImporterSpecData.ts
```ts
import {AnnotationFormatType} from './enums/AnnotationFormatType';
import {AnnotationImporter} from '../logic/import/AnnotationImporter';
import {COCOImporter} from '../logic/import/coco/COCOImporter';
import {YOLOImporter} from '../logic/import/yolo/YOLOImporter';
import {VOCImporter} from '../logic/import/voc/VOCImporter';

export type ImporterSpecDataMap = Record<AnnotationFormatType, typeof AnnotationImporter>;


export const ImporterSpecData: ImporterSpecDataMap = {
    [AnnotationFormatType.COCO]: COCOImporter,
    [AnnotationFormatType.CSV]: undefined,
    [AnnotationFormatType.JSON]: undefined,
    [AnnotationFormatType.VGG]: undefined,
    [AnnotationFormatType.VOC]: VOCImporter,
    [AnnotationFormatType.YOLO]: YOLOImporter
}

```

Path: src/data/MobileDeviceData.ts
```ts
export interface MobileDeviceData {
    manufacturer: string,
    browser: string,
    os: string
}
```

Path: src/data/RectAnchor.ts
```ts
import {IPoint} from "../interfaces/IPoint";
import {Direction} from "./enums/Direction";

export interface RectAnchor {
    type: Direction,
    position: IPoint
}
```

Path: src/data/enums/AIModel.ts
```ts
export enum AIModel {
    YOLO_V5_OBJECT_DETECTION = 'YOLO_V5_OBJECT_DETECTION',
    SSD_OBJECT_DETECTION = 'SSD_OBJECT_DETECTION',
    POSE_DETECTION = 'POSE_DETECTION'
}

```

Path: src/data/enums/AcceptedFileType.ts
```ts
export enum AcceptedFileType {
    IMAGE = 'image/jpeg, image/png',
    TEXT = 'text/plain',
    JSON = 'application/json',
    XML = 'application/xml',
}
```

Path: src/data/enums/AnnotationFormatType.ts
```ts
export enum AnnotationFormatType {
    YOLO = 'YOLO',
    COCO = 'COCO',
    CSV = 'CSV',
    JSON = 'JSON',
    VOC = 'VOC',
    VGG = 'VGG'
}
```

Path: src/data/enums/ContextType.ts
```ts
export enum ContextType {
    EDITOR = "EDITOR",
    LEFT_NAVBAR = "LEFT_NAVBAR",
    RIGHT_NAVBAR = "RIGHT_NAVBAR",
    POPUP = "POPUP",
    DROPDOWN = "DROPDOWN"
}
```

Path: src/data/enums/CustomCursorStyle.ts
```ts
export enum CustomCursorStyle {
    DEFAULT = "DEFAULT",
    MOVE = "MOVE",
    RESIZE = "RESIZE",
    ADD = "ADD",
    CANCEL = "CANCEL",
    CLOSE = "CLOSE",
    GRAB = "GRAB",
    GRABBING = "GRABBING"
}
```

Path: src/data/enums/Direction.ts
```ts
export enum Direction {
    TOP = "TOP",
    BOTTOM = "BOTTOM",
    LEFT = "LEFT",
    RIGHT = "RIGHT",
    TOP_RIGHT = "TOP_RIGHT",
    TOP_LEFT = "TOP_LEFT",
    BOTTOM_RIGHT = "BOTTOM_RIGHT",
    BOTTOM_LEFT = "BOTTOM_LEFT",
    CENTER = "CENTER"
}
```

Path: src/data/enums/EventType.ts
```ts
export enum EventType {
    RESIZE = "resize",
    MOUSE_UP = "mouseup",
    MOUSE_DOWN = "mousedown",
    MOUSE_MOVE = "mousemove",
    MOUSE_WHEEL = "wheel",
    KEY_DOWN = "keydown",
    KEY_PRESS = "keypress",
    KEY_UP = "keyup",
    FOCUS = "focus"
}
```

Path: src/data/enums/InferenceServerType.ts
```ts
export enum InferenceServerType {
    ROBOFLOW = 'ROBOFLOW',
    MAKESENSE = 'MAKESENSE'
}
```

Path: src/data/enums/LabelStatus.ts
```ts
export enum LabelStatus {
    ACCEPTED = "ACCEPTED",
    REJECTED = "REJECTED",
    UNDECIDED = "UNDECIDED"
}
```

Path: src/data/enums/LabelType.ts
```ts
export enum LabelType {
    IMAGE_RECOGNITION = 'IMAGE RECOGNITION',
    POINT = 'POINT',
    RECT = 'RECT',
    POLYGON = 'POLYGON',
    LINE = 'LINE'
}
```

Path: src/data/enums/LineAnchorType.ts
```ts
export enum LineAnchorType {
    START = "START",
    END = "END"
}
```

Path: src/data/enums/Notification.ts
```ts
export enum Notification {
    EMPTY_LABEL_NAME_ERROR = 0,
    NON_UNIQUE_LABEL_NAMES_ERROR = 1,
    MODEL_DOWNLOAD_ERROR = 2,
    MODEL_INFERENCE_ERROR = 3,
    MODEL_LOAD_ERROR = 4,
    LABELS_FILE_UPLOAD_ERROR = 5,
    ANNOTATION_FILE_PARSE_ERROR = 6,
    ANNOTATION_IMPORT_ASSERTION_ERROR = 7,
    UNSUPPORTED_INFERENCE_SERVER_MESSAGE = 8,
    ROBOFLOW_INFERENCE_SERVER_ERROR = 9,
}

```

Path: src/data/enums/NotificationType.ts
```ts
export enum NotificationType {
    ERROR = 'ERROR',
    SUCCESS = 'SUCCESS',
    MESSAGE = 'MESSAGE',
    WARNING = 'WARNING'
}

```

Path: src/data/enums/PopupWindowType.ts
```ts
export enum PopupWindowType {
    LOAD_LABEL_NAMES = 'LOAD_LABEL_NAMES',
    UPDATE_LABEL = 'UPDATE_LABEL',
    SUGGEST_LABEL_NAMES = 'SUGGEST_LABEL_NAMES',
    IMPORT_IMAGES = 'IMPORT_IMAGES',
    LOAD_AI_MODEL = 'LOAD_AI_MODEL',
    CONNECT_AI_MODEL_VIA_API = 'CONNECT_AI_MODEL_VIA_API',
    LOAD_YOLO_V5_MODEL = 'LOAD_YOLO_V5_MODEL',
    EXPORT_ANNOTATIONS = 'EXPORT_ANNOTATIONS',
    IMPORT_ANNOTATIONS = 'IMPORT_ANNOTATIONS',
    INSERT_LABEL_NAMES = 'INSERT_LABEL_NAMES',
    EXIT_PROJECT = 'EXIT_PROJECT',
    LOADER = 'LOADER',
}

```

Path: src/data/enums/ProjectType.ts
```ts
export enum ProjectType {
    IMAGE_RECOGNITION = 'IMAGE_RECOGNITION',
    OBJECT_DETECTION = 'OBJECT_DETECTION'
}

```

Path: src/data/labels/COCO.ts
```ts
export type COCOSegmentation = number[][]
export type COCOBBox = [number, number, number, number]

export type COCOInfo = {
    description: string;
}

export type COCOImage = {
    id: number;
    width: number;
    height: number;
    file_name: string;
}

export type COCOCategory = {
    id: number;
    name: string;
}

export type COCOAnnotation = {
    id: number;
    category_id: number;
    iscrowd: number;
    segmentation: COCOSegmentation;
    image_id: number;
    area: number;
    bbox: COCOBBox;
}

export type COCOObject = {
    info: COCOInfo,
    images: COCOImage[],
    annotations: COCOAnnotation[],
    categories: COCOCategory[]
}
```

Path: src/data/labels/VGG.ts
```ts
export interface VGGShape {}

export interface VGGRect extends VGGShape {
    name: string,
    x: number,
    y: number,
    width: number,
    height: number
}

export interface VGGPolygon extends VGGShape {
    name: string,
    all_points_x: number[],
    all_points_y: number[]
}

export interface VGGRegion {
    shape_attributes: VGGShape,
    region_attributes: { [key:string]:string; }
}

export type VGGRegionsData = { [key: string]: VGGRegion; }

export type VGGFileData = {
    fileref: string;
    size: number;
    filename: string;
    base64_img_data: string;
    file_attributes: object;
    regions: VGGRegionsData;
}

export type VGGObject = { [key: string]: VGGFileData; }
```

Path: src/data/info/DropDownMenuData.ts
```ts
import {updateActivePopupType} from '../../store/general/actionCreators';
import {PopupWindowType} from '../enums/PopupWindowType';
import {store} from '../../index';

export type DropDownMenuNode = {
    name: string
    description?: string
    imageSrc: string
    imageAlt: string
    disabled: boolean
    onClick?: () => void
    children?: DropDownMenuNode[]
}

export const DropDownMenuData: DropDownMenuNode[] = [
    {
        name: 'Actions',
        imageSrc: 'ico/actions.png',
        imageAlt: 'actions',
        disabled: false,
        children: [
            {
                name: 'Edit Labels',
                description: 'Modify labels list',
                imageSrc: 'ico/tags.png',
                imageAlt: 'labels',
                disabled: false,
                onClick: () => store.dispatch(updateActivePopupType(PopupWindowType.UPDATE_LABEL))
            },
            {
                name: 'Import Images',
                description: 'Load more images',
                imageSrc: 'ico/camera.png',
                imageAlt: 'images',
                disabled: false,
                onClick: () => store.dispatch(updateActivePopupType(PopupWindowType.IMPORT_IMAGES))
            },
            {
                name: 'Import Annotations',
                description: 'Import annotations from file',
                imageSrc: 'ico/import-labels.png',
                imageAlt: 'import-labels',
                disabled: false,
                onClick: () => store.dispatch(updateActivePopupType(PopupWindowType.IMPORT_ANNOTATIONS))
            },
            {
                name: 'Export Annotations',
                description: 'Export annotations to file',
                imageSrc: 'ico/export-labels.png',
                imageAlt: 'export-labels',
                disabled: false,
                onClick: () => store.dispatch(updateActivePopupType(PopupWindowType.EXPORT_ANNOTATIONS))
            },
            {
                name: 'Run AI locally',
                description: 'Run annotation model in browser',
                imageSrc: 'ico/ai.png',
                imageAlt: 'load-ai-model-in-browser',
                disabled: false,
                onClick: () => store.dispatch(updateActivePopupType(PopupWindowType.LOAD_AI_MODEL))
            },
            {
                name: 'Connect AI server',
                description: 'Run annotation model on server',
                imageSrc: 'ico/api.png',
                imageAlt: 'connect-ai-server',
                disabled: false,
                onClick: () => store.dispatch(updateActivePopupType(PopupWindowType.CONNECT_AI_MODEL_VIA_API))
            },
        ]
    },
    {
        name: 'Community',
        imageSrc: 'ico/plant.png',
        imageAlt: 'community',
        disabled: false,
        children: [
            {
                name: 'Documentation',
                description: 'Read more about Make Sense',
                imageSrc: 'ico/documentation.png',
                imageAlt: 'documentation',
                disabled: false,
                onClick: () => window.open('https://skalskip.github.io/make-sense', '_blank')
            },
            {
                name: 'Bugs and Features',
                description: 'Report a bug or propose a new feature',
                imageSrc: 'ico/bug.png',
                imageAlt: 'bug',
                disabled: false,
                onClick: () => window.open('https://github.com/SkalskiP/make-sense/issues', '_blank')
            }
        ]
    }
]


```

Path: src/data/info/EditorFeatureData.ts
```ts
export interface IEditorFeature {
    displayText:string;
    imageSrc:string;
    imageAlt:string;
}

export const EditorFeatureData: IEditorFeature[] = [
    {
        displayText: 'Open source and free to use under GPLv3 license',
        imageSrc: 'ico/open-source.png',
        imageAlt: 'open-source',
    },
    {
        displayText: 'No advanced installation required, just open up your browser',
        imageSrc: 'ico/online.png',
        imageAlt: 'online',
    },
    {
        displayText: "We don't store your images, because we don't send them anywhere",
        imageSrc: 'ico/private.png',
        imageAlt: 'private',
    },
    {
        displayText: 'Support multiple label types - rects, lines, points and polygons',
        imageSrc: 'ico/labels.png',
        imageAlt: 'labels',
    },
    {
        displayText: 'Support output file formats like YOLO, VOC XML, VGG JSON, CSV',
        imageSrc: 'ico/file.png',
        imageAlt: 'file',
    },
    {
        displayText: 'Use AI to make your work more productive',
        imageSrc: 'ico/robot.png',
        imageAlt: 'robot',
    },
];
```

Path: src/data/info/InferenceServerData.ts
```ts
import { InferenceServerType } from '../enums/InferenceServerType';

export interface IInferenceServer {
    name: string
    imageSrc: string
    imageAlt: string
    isDisabled: boolean
}

export const InferenceServerDataMap: Record<InferenceServerType, IInferenceServer> = {
    [InferenceServerType.ROBOFLOW]: {
        name: 'Roboflow Inference Server',
        imageSrc: 'ico/roboflow-logo.png',
        imageAlt: 'roboflow-inference-server',
        isDisabled: false
    },
    [InferenceServerType.MAKESENSE]: {
        name: 'Make Sense Inference Server',
        imageSrc: 'ico/make-sense-ico-transparent.png',
        imageAlt: 'make-sense-inference-server',
        isDisabled: true
    }
}
```

Path: src/data/info/LabelToolkitData.ts
```ts
import {LabelType} from '../enums/LabelType';
import {ProjectType} from '../enums/ProjectType';

export interface ILabelToolkit {
    labelType: LabelType;
    headerText: string;
    imageSrc: string;
    imageAlt: string;
    projectType: ProjectType;
}

export const LabelToolkitData: ILabelToolkit[] = [
    {
        labelType: LabelType.IMAGE_RECOGNITION,
        headerText: 'Image recognition',
        imageSrc: 'ico/object.png',
        imageAlt: 'object',
        projectType: ProjectType.IMAGE_RECOGNITION,
    },
    {
        labelType: LabelType.RECT,
        headerText: 'Rect',
        imageSrc: 'ico/rectangle.png',
        imageAlt: 'rectangle',
        projectType: ProjectType.OBJECT_DETECTION,
    },
    {
        labelType: LabelType.POINT,
        headerText: 'Point',
        imageSrc: 'ico/point.png',
        imageAlt: 'point',
        projectType: ProjectType.OBJECT_DETECTION,
    },
    {
        labelType: LabelType.LINE,
        headerText: 'Line',
        imageSrc: 'ico/line.png',
        imageAlt: 'line',
        projectType: ProjectType.OBJECT_DETECTION,
    },
    {
        labelType: LabelType.POLYGON,
        headerText: 'Polygon',
        imageSrc: 'ico/polygon.png',
        imageAlt: 'polygon',
        projectType: ProjectType.OBJECT_DETECTION,
    },
];
```

Path: src/data/info/NotificationsData.ts
```ts
import {Notification} from '../enums/Notification';

export type NotificationContent = {
    header: string;
    description: string;
}

export type ExportFormatDataMap = Record<Notification, NotificationContent>;

export const NotificationsDataMap: ExportFormatDataMap = {
    [Notification.EMPTY_LABEL_NAME_ERROR]: {
        header: 'Empty label name',
        description: "Looks like you didn't assign name to one of your labels. Unfortunately it is mandatory for " +
            'every label to have unique name value. Insert correct name or delete empty label and try again.'
    },
    [Notification.NON_UNIQUE_LABEL_NAMES_ERROR]: {
        header: 'Non unique label names',
        description: 'Looks like not all your label names are unique. Unique names are necessary to guarantee correct' +
            ' data export when you complete your work. Make your names unique and try again.'
    },
    [Notification.MODEL_DOWNLOAD_ERROR]: {
        header: 'Model could not be downloaded',
        description: 'Looks like we ware unable to download tensorflow.js model from external server. Make sure that ' +
            'you are connected to internet and try again.'
    },
    [Notification.MODEL_INFERENCE_ERROR]: {
        header: 'Inference failed',
        description: 'Looks like we were unable to run inference of your image. Please help us improve Make Sense ' +
            'and let us know.'
    },
    [Notification.MODEL_LOAD_ERROR]: {
        header: 'Model could not be loaded',
        description: 'Looks like we ware unable to load your tensorflow.js model from uploaded files. Make sure that ' +
            'you uploaded all model shard files. Please re-upload all model files once again.'
    },
    [Notification.LABELS_FILE_UPLOAD_ERROR]: {
        header: 'Labels file was not uploaded',
        description: 'Looks like you forgot to upload text file containing list of detected classes names. We need ' +
            'it to map YOLOv5 model output to labels. Please re-upload all model files once again.'
    },
    [Notification.ANNOTATION_FILE_PARSE_ERROR]: {
        header: 'Annotation files could not be parsed',
        description: 'The contents of an annotation file is not valid JSON, CSV, or XML. Please fix the files ' +
            'selected to import and try again.',
    },
    [Notification.ANNOTATION_IMPORT_ASSERTION_ERROR]: {
        header: 'Annotation files did not contain valid data',
        description: 'Missing or invalid annotations provided during import. Please fix the files selected ' +
            'to import and try again.',
    },
    [Notification.UNSUPPORTED_INFERENCE_SERVER_MESSAGE]: {
        header: 'Selected inference server is not yet supported',
        description: 'Integration with selected inference server is still under construction. Stay tuned for more ' +
            'updates on our GitHub.'
    },
    [Notification.ROBOFLOW_INFERENCE_SERVER_ERROR]: {
        header: 'Roboflow connection failed',
        description: 'Looks like we ware unable to connect to your Roboflow model. Please, make sure that the model ' +
            'specification and Roboflow API key, are correct.'
    }
}

```

Path: src/data/info/SocialMediaData.ts
```ts
import {Settings} from '../../settings/Settings';

export interface ISocialMedia {
    displayName:string;
    imageSrc:string;
    imageAlt:string;
    href:string;
    tooltipMessage:string;
}

export const SocialMediaData: ISocialMedia[] = [
    {
        displayName: 'Github',
        imageSrc: '/ico/github-logo.png',
        imageAlt: 'GitHub',
        href: Settings.GITHUB_URL,
        tooltipMessage: 'Show us some love ‚≠ê on GitHub',
    },
    {
        displayName: 'Medium',
        imageSrc: '/ico/medium-logo.png',
        imageAlt: 'Medium',
        href: Settings.MEDIUM_URL,
        tooltipMessage: 'Read our AI content on Medium',
    },
    {
        displayName: 'YouTube',
        imageSrc: '/ico/youtube-logo.png',
        imageAlt: 'YouTube',
        href: Settings.YOUTUBE_URL,
        tooltipMessage: 'Watch our AI tutorials on YouTube'
    },
    {
        displayName: 'Twitch',
        imageSrc: '/ico/twitch-logo.png',
        imageAlt: 'Twitch',
        href: Settings.TWITCH_URL,
        tooltipMessage: 'Fight along with us in Kaggle competitions on Twitch'
    },
];

```

Path: src/views/NotificationsView/NotificationsView.tsx
```tsx
import React, {useState} from 'react';
import './NotificationsView.scss';
import {AppState} from '../../store';
import {connect} from 'react-redux';
import classNames from 'classnames';
import {deleteNotificationById} from '../../store/notifications/actionCreators';
import {INotification} from '../../store/notifications/types';
import {NotificationType} from '../../data/enums/NotificationType';

interface IProps {
    deleteNotificationByIdAction: (id: string) => void
    queue: INotification[]
}

enum NotificationState {
    IN = 'IN',
    DISPLAY = 'DISPLAY',
    OUT = 'OUT',
    IDLE = 'IDLE'
}

enum Animation {
    IN = 'animation-in',
    DISPLAY = 'animation-display',
    OUT = 'animation-out'
}

const NotificationsView: React.FC<IProps> = (props) => {
    const [ notificationState, setNotificationState ] = useState(NotificationState.IDLE);

    if (props.queue.length > 0 && notificationState === NotificationState.IDLE) {
        setNotificationState(NotificationState.IN)
    }

    const notification: INotification | undefined = props.queue[0]

    const onClose = () => {
        setNotificationState(NotificationState.OUT)
    }

    const onAnimationEnd = (event: React.AnimationEvent<HTMLDivElement>) => {
        switch (event.animationName) {
            case Animation.IN:
                setNotificationState(NotificationState.DISPLAY)
                break
            case Animation.DISPLAY:
                setNotificationState(NotificationState.OUT)
                break
            case Animation.OUT:
                props.deleteNotificationByIdAction(notification.id)
                setNotificationState(NotificationState.IDLE)
                break
        }
    }

    const getNotificationWrapperClassName = () => {
        return classNames('notification-wrapper', {
            'in': notificationState === NotificationState.IN,
            'display': notificationState === NotificationState.DISPLAY,
            'out': notificationState === NotificationState.OUT
        })
    }

    const getNotificationClassName = () => {
        return classNames('notification', {
            'error': notification.type === NotificationType.ERROR,
            'success': notification.type === NotificationType.SUCCESS,
            'message': notification.type === NotificationType.MESSAGE,
            'warning': notification.type === NotificationType.WARNING
        })
    }

    const renderNotification = () => {
        return(
            notification && <div
                className={getNotificationWrapperClassName()}
                key={notification.id}
                onAnimationEnd={onAnimationEnd}
                onClick={onClose}
            >
                <div className={getNotificationClassName()}>
                    <div className='header'>
                        {notification.header}
                    </div>
                    <div className='content'>
                        {notification.description}
                    </div>
                    <div className='loader'/>
                </div>
            </div>
        )
    }

    return(notificationState !== NotificationState.IDLE ? renderNotification() : null)
}

const mapDispatchToProps = {
    deleteNotificationByIdAction: deleteNotificationById
};

const mapStateToProps = (state: AppState) => ({
    queue: state.notifications.queue
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(NotificationsView);

```

Path: src/views/PopupView/PopupView.tsx
```tsx
import React from 'react';
import './PopupView.scss';
import { PopupWindowType } from '../../data/enums/PopupWindowType';
import { AppState } from '../../store';
import { connect } from 'react-redux';
import LoadLabelsPopup from './LoadLabelNamesPopup/LoadLabelNamesPopup';
import InsertLabelNamesPopup from './InsertLabelNamesPopup/InsertLabelNamesPopup';
import ExitProjectPopup from './ExitProjectPopup/ExitProjectPopup';
import LoadMoreImagesPopup from './LoadMoreImagesPopup/LoadMoreImagesPopup';
import SuggestLabelNamesPopup from './SuggestLabelNamesPopup/SuggestLabelNamesPopup';
import { CSSHelper } from '../../logic/helpers/CSSHelper';
import { ClipLoader } from 'react-spinners';
import ImportLabelPopup from './ImportLabelPopup/ImportLabelPopup';
import ExportLabelPopup from './ExportLabelsPopup/ExportLabelPopup';
import LoadModelPopup from './LoadModelPopup/LoadModelPopup';
import LoadYOLOv5ModelPopup from './LoadYOLOv5ModelPopup/LoadYOLOv5ModelPopup';
import ConnectInferenceServerPopup from './ConnectInferenceServerPopup/ConnectInferenceServerPopup';

interface IProps {
    activePopupType: PopupWindowType;
}

const PopupView: React.FC<IProps> = ({ activePopupType }) => {

    const selectPopup = () => {
        switch (activePopupType) {
            case PopupWindowType.LOAD_LABEL_NAMES:
                return <LoadLabelsPopup />;
            case PopupWindowType.EXPORT_ANNOTATIONS:
                return <ExportLabelPopup />;
            case PopupWindowType.IMPORT_ANNOTATIONS:
                return <ImportLabelPopup />;
            case PopupWindowType.INSERT_LABEL_NAMES:
                return <InsertLabelNamesPopup
                    isUpdate={false}
                />;
            case PopupWindowType.UPDATE_LABEL:
                return <InsertLabelNamesPopup
                    isUpdate={true}
                />;
            case PopupWindowType.EXIT_PROJECT:
                return <ExitProjectPopup />;
            case PopupWindowType.IMPORT_IMAGES:
                return <LoadMoreImagesPopup />;
            case PopupWindowType.LOAD_AI_MODEL:
                return <LoadModelPopup />;
            case PopupWindowType.LOAD_YOLO_V5_MODEL:
                return <LoadYOLOv5ModelPopup />;
            case PopupWindowType.CONNECT_AI_MODEL_VIA_API:
                return <ConnectInferenceServerPopup />;
            case PopupWindowType.SUGGEST_LABEL_NAMES:
                return <SuggestLabelNamesPopup />;
            case PopupWindowType.LOADER:
                return <ClipLoader
                    size={50}
                    color={CSSHelper.getLeadingColor()}
                    loading={true}
                />;
            default:
                return null;
        }
    };

    return (
        activePopupType && <div className='PopupView'>
            {selectPopup()}
        </div>
    );
};

const mapStateToProps = (state: AppState) => ({
    activePopupType: state.general.activePopupType
});

export default connect(
    mapStateToProps
)(PopupView);

```

Path: src/views/PopupView/GenericSideMenuPopup/GenericSideMenuPopup.tsx
```tsx
import React from 'react';
import './GenericSideMenuPopup.scss'
import { GenericYesNoPopup } from '../GenericYesNoPopup/GenericYesNoPopup';

interface IProps {
    title: string;
    acceptLabel: string;
    onAccept: () => void;
    disableAcceptButton?: boolean;
    rejectLabel: string;
    onReject: () => void;
    renderContent: () => JSX.Element;
    renderSideMenuContent: () => JSX.Element[];
}

export const GenericSideMenuPopup: React.FC<IProps> = (
    {
        title,
        acceptLabel,
        onAccept,
        disableAcceptButton,
        rejectLabel,
        onReject,
        renderContent,
        renderSideMenuContent
    }
) => {

    const renderPopupContent = () => {
        return (<div className='generic-side-menu-popup'>
            <div className='left-container'>
                {renderSideMenuContent()}
            </div>
            <div className='right-container'>
                {renderContent()}
            </div>
        </div>);
    }

    return(
        <GenericYesNoPopup
            title={title}
            renderContent={renderPopupContent}
            acceptLabel={acceptLabel}
            disableAcceptButton={disableAcceptButton}
            onAccept={onAccept}
            rejectLabel={rejectLabel}
            onReject={onReject}
        />
    );
}
```

Path: src/views/PopupView/SuggestLabelNamesPopup/SuggestLabelNamesPopup.tsx
```tsx
import React, {useState} from 'react'
import './SuggestLabelNamesPopup.scss'
import {AppState} from '../../../store';
import {connect} from 'react-redux';
import {updateRejectedSuggestedLabelList, updateSuggestedLabelList} from '../../../store/ai/actionCreators';
import {GenericYesNoPopup} from '../GenericYesNoPopup/GenericYesNoPopup';
import {PopupActions} from '../../../logic/actions/PopupActions';
import {AISelector} from '../../../store/selectors/AISelector';
import Scrollbars from 'react-custom-scrollbars-2';
import {LabelName} from '../../../store/labels/types';
import {updateLabelNames} from '../../../store/labels/actionCreators';
import {LabelsSelector} from '../../../store/selectors/LabelsSelector';
import { v4 as uuidv4 } from 'uuid';
import {ArrayUtil} from '../../../utils/ArrayUtil';
import {Settings} from '../../../settings/Settings';

interface SelectableName {
    name: string;
    flag: boolean;
}

interface IProps {
    updateLabelNames: (labels: LabelName[]) => any,
    updateSuggestedLabelList: (labelList: string[]) => any;
    updateRejectedSuggestedLabelList: (labelList: string[]) => any;
}

const SuggestLabelNamesPopup: React.FC<IProps> = (
    {
        updateLabelNames,
        updateSuggestedLabelList,
        updateRejectedSuggestedLabelList
    }) => {

    const mapNamesToSelectableNames = (names: string[]): SelectableName[] => {
        return names.map((name: string) => {
            return {
                name,
                flag: false
            }
        })
    };

    const [selectAllFlag, setSelectAllFlag] = useState(false);
    const [labelNames, setLabelNames] = useState(mapNamesToSelectableNames(AISelector.getSuggestedLabelList()));

    const onAccept = () => {
        updateLabelNames(extractSelectedNames().reduce((acc: LabelName[], entry: string, index: number) => {
            acc.push({
                name: entry,
                id: uuidv4(),
                color: ArrayUtil.getByInfiniteIndex(Settings.LABEL_COLORS_PALETTE, index)
            });
            return acc;
        }, LabelsSelector.getLabelNames()));
        updateRejectedSuggestedLabelList(AISelector.getRejectedSuggestedLabelList().concat(extractUnselectedNames()));
        updateSuggestedLabelList([]);
        PopupActions.close();
    };

    const onReject = () => {
        updateRejectedSuggestedLabelList(AISelector.getRejectedSuggestedLabelList().concat(extractNames()));
        updateSuggestedLabelList([]);
        PopupActions.close();
    };

    const selectAll = () => {
        setSelectAllFlag(true);
        setLabelNames(labelNames.map((entry: SelectableName) => {
            return {
                ...entry,
                flag: true
            }
        }))
    };

    const deselectAll = () => {
        setSelectAllFlag(false);
        setLabelNames(labelNames.map((entry: SelectableName) => {
            return {
                ...entry,
                flag: false
            }
        }))
    };

    const toggleSelectableNameByIndex = (index: number) => {
        const nextLabelNames: SelectableName[] = labelNames.map((entry: SelectableName, entryIndex: number) => {
            if (index === entryIndex)
                return {
                    ...entry,
                    flag: !entry.flag
                };
            else
                return entry;
        });
        setLabelNames(nextLabelNames);

        const nextSelectAllFlag: boolean = nextLabelNames.reduce((acc: boolean, entry: SelectableName) => {
            return(acc && entry.flag)
        }, true);
        setSelectAllFlag(nextSelectAllFlag);
    };

    const extractSelectedNames = (): string[] => {
        return labelNames.reduce((acc: string[], entry: SelectableName) => {
            if (entry.flag) {
                acc.push(entry.name);
            }
            return acc;
        }, [])
    };

    const extractUnselectedNames = (): string[] => {
        return labelNames.reduce((acc: string[], entry: SelectableName) => {
            if (!entry.flag) {
                acc.push(entry.name);
            }
            return acc;
        }, [])
    };

    const extractNames = (): string[] => {
        return labelNames.map((entry: SelectableName) => entry.name);
    };

    const getOptions = () => {
        return labelNames.map((entry: SelectableName, index: number) => {
            return <div
                className='OptionsItem'
                onClick={() => toggleSelectableNameByIndex(index)}
                key={index}
            >
                {entry.flag ?
                    <img
                        draggable={false}
                        src={'ico/checkbox-checked.png'}
                        alt={'checked'}
                    /> :
                    <img
                        draggable={false}
                        src={'ico/checkbox-unchecked.png'}
                        alt={'unchecked'}
                    />}
                {entry.name}
            </div>
        })
    };

    const renderContent = () => {
        return(<div className='SuggestLabelNamesPopupContent'>
            <div className='Message'>
                We found objects of classes that are not yet included in the list of labels. Select the names you
                would like to add. This will help to speed up the labeling process.
            </div>
            <div className='AllToggle'>
                <div
                    className='OptionsItem'
                    onClick={() => selectAllFlag ? deselectAll() : selectAll()}
                >
                    {selectAllFlag ?
                        <img
                            draggable={false}
                            src={'ico/checkbox-checked.png'}
                            alt={'checked'}
                        /> :
                        <img
                            draggable={false}
                            src={'ico/checkbox-unchecked.png'}
                            alt={'unchecked'}
                        />}
                    {selectAllFlag ? 'Deselect all' : 'Select all'}
                </div>
            </div>
            <div className='LabelNamesContainer'>
                <Scrollbars autoHeight={true}>
                    <div
                        className='LabelNamesContent'
                    >
                        {getOptions()}
                    </div>
                </Scrollbars>
            </div>
        </div>);
    };

    return(
        <GenericYesNoPopup
            title={'New classes found'}
            renderContent={renderContent}
            acceptLabel={'Accept'}
            onAccept={onAccept}
            rejectLabel={'Reject'}
            onReject={onReject}
        />
    );
};

const mapDispatchToProps = {
    updateLabelNames,
    updateSuggestedLabelList,
    updateRejectedSuggestedLabelList
};

const mapStateToProps = (state: AppState) => ({});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(SuggestLabelNamesPopup);

```

Path: src/views/PopupView/ExitProjectPopup/ExitProjectPopup.tsx
```tsx
import React from 'react';
import './ExitProjectPopup.scss';
import { GenericYesNoPopup } from "../GenericYesNoPopup/GenericYesNoPopup";
import {
    updateActiveImageIndex as storeUpdateActiveImageIndex,
    updateActiveLabelNameId as storeUpdateActiveLabelNameId,
    updateFirstLabelCreatedFlag as storeUpdateFirstLabelCreatedFlag,
    updateImageData as storeUpdateImageData,
    updateLabelNames as storeUpdateLabelNames
} from "../../../store/labels/actionCreators";
import { AppState } from "../../../store";
import { connect } from "react-redux";
import { ImageData, LabelName } from "../../../store/labels/types";
import { PopupActions } from "../../../logic/actions/PopupActions";
import { ProjectData } from "../../../store/general/types";
import { updateProjectData as storeUpdateProjectData } from "../../../store/general/actionCreators";

interface IProps {
    updateActiveImageIndex: (activeImageIndex: number) => any;
    updateActiveLabelNameId: (activeLabelId: string) => any;
    updateLabelNames: (labelNames: LabelName[]) => any;
    updateImageData: (imageData: ImageData[]) => any;
    updateFirstLabelCreatedFlag: (firstLabelCreatedFlag: boolean) => any;
    updateProjectData: (projectData: ProjectData) => any;
}

const ExitProjectPopup: React.FC<IProps> = ({
    updateActiveLabelNameId,
    updateLabelNames,
    updateActiveImageIndex,
    updateImageData,
    updateFirstLabelCreatedFlag,
    updateProjectData
}: IProps) => {


    const renderContent = () => {
        return (
            <div className="ExitProjectPopupContent">
                <div className="Message">
                    Are you sure you want to leave the editor? You will permanently lose all your progress.
                </div>
            </div>
        );
    };

    const onAccept = () => {
        updateActiveLabelNameId(null);
        updateLabelNames([]);
        updateProjectData({ type: null, name: "my-project-name" });
        updateActiveImageIndex(null);
        updateImageData([]);
        updateFirstLabelCreatedFlag(false);
        PopupActions.close();
    };

    const onReject = () => {
        PopupActions.close();
    };

    return (
        <GenericYesNoPopup
            title={"Exit project"}
            renderContent={renderContent}
            acceptLabel={"Exit"}
            onAccept={onAccept}
            rejectLabel={"Back"}
            onReject={onReject}
        />);
};

const mapDispatchToProps = {
    updateActiveLabelNameId: storeUpdateActiveLabelNameId,
    updateLabelNames: storeUpdateLabelNames,
    updateProjectData: storeUpdateProjectData,
    updateActiveImageIndex: storeUpdateActiveImageIndex,
    updateImageData: storeUpdateImageData,
    updateFirstLabelCreatedFlag: storeUpdateFirstLabelCreatedFlag
};

const mapStateToProps = (state: AppState) => ({});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(ExitProjectPopup);
```

Path: src/views/PopupView/LoadLabelNamesPopup/LoadLabelNamesPopup.tsx
```tsx
import React, { useState } from 'react';
import './LoadLabelNamesPopup.scss';
import { AppState } from '../../../store';
import { connect } from 'react-redux';
import { updateLabelNames } from '../../../store/labels/actionCreators';
import { GenericYesNoPopup } from '../GenericYesNoPopup/GenericYesNoPopup';
import { PopupWindowType } from '../../../data/enums/PopupWindowType';
import { updateActivePopupType } from '../../../store/general/actionCreators';
import { useDropzone } from 'react-dropzone';
import { LabelName } from '../../../store/labels/types';
import { YOLOUtils } from '../../../logic/import/yolo/YOLOUtils';
import {LabelNamesNotUniqueError} from '../../../logic/import/yolo/YOLOErrors';
import {NotificationUtil} from '../../../utils/NotificationUtil';
import {NotificationsDataMap} from '../../../data/info/NotificationsData';
import {Notification} from '../../../data/enums/Notification';
import {submitNewNotification} from '../../../store/notifications/actionCreators';
import {INotification} from '../../../store/notifications/types';

interface IProps {
    updateActivePopupTypeAction: (activePopupType: PopupWindowType) => any;
    updateLabelNamesAction: (labels: LabelName[]) => any;
    submitNewNotificationAction: (notification: INotification) => any;
}

const LoadLabelNamesPopup: React.FC<IProps> = (
    { updateActivePopupTypeAction, updateLabelNamesAction, submitNewNotificationAction }
) => {
    const [labelsList, setLabelsList] = useState([]);
    const [invalidFileLoadedStatus, setInvalidFileLoadedStatus] = useState(false);

    const onSuccess = (labels: LabelName[]) => {
        setLabelsList(labels);
        setInvalidFileLoadedStatus(false);
    };

    const onFailure = (error: Error) => {
        setInvalidFileLoadedStatus(true);
        if (error instanceof LabelNamesNotUniqueError) {
            submitNewNotificationAction(NotificationUtil
                .createErrorNotification(NotificationsDataMap[Notification.NON_UNIQUE_LABEL_NAMES_ERROR]));
        }
    };

    const { acceptedFiles, getRootProps, getInputProps } = useDropzone({
        accept: { 'text/plain': ['.txt'] },
        multiple: false,
        onDrop: (accepted) => {
            if (accepted.length === 1) {
                YOLOUtils.loadLabelsList(accepted[0], onSuccess, onFailure);
            }
        }
    });


    const onAccept = () => {
        if (labelsList.length > 0) {
            updateLabelNamesAction(labelsList);
            updateActivePopupTypeAction(null);
        }
    };

    const onReject = () => {
        updateActivePopupTypeAction(PopupWindowType.INSERT_LABEL_NAMES);
    };

    const getDropZoneContent = () => {
        if (invalidFileLoadedStatus)
            return <>
                <input {...getInputProps()} />
                <img
                    draggable={false}
                    alt={'upload'}
                    src={'ico/box-opened.png'}
                />
                <p className='extraBold'>Loading of labels file was unsuccessful</p>
                <p className='extraBold'>Try again</p>
            </>;
        else if (acceptedFiles.length === 0)
            return <>
                <input {...getInputProps()} />
                <img
                    draggable={false}
                    alt={'upload'}
                    src={'ico/box-opened.png'}
                />
                <p className='extraBold'>Drop labels file</p>
                <p>or</p>
                <p className='extraBold'>Click here to select it</p>
            </>;
        else if (labelsList.length === 1)
            return <>
                <img
                    draggable={false}
                    alt={'uploaded'}
                    src={'ico/box-closed.png'}
                />
                <p className='extraBold'>only 1 label found</p>
            </>;
        else
            return <>
                <img
                    draggable={false}
                    alt={'uploaded'}
                    src={'ico/box-closed.png'}
                />
                <p className='extraBold'>{labelsList.length} labels found</p>
            </>;
    };

    const renderContent = () => {
        return (<div className='LoadLabelsPopupContent'>
            <div className='Message'>
                Load a text file with a list of labels you are planning to use. The names of
                each label should be separated by new line. If you don&apos;t have a prepared file, no problem. You can
                create your own list now.
            </div>
            <div {...getRootProps({ className: 'DropZone' })}>
                {getDropZoneContent()}
            </div>
        </div>);
    };

    return (
        <GenericYesNoPopup
            title={'Load file with labels description'}
            renderContent={renderContent}
            acceptLabel={'Start project'}
            onAccept={onAccept}
            disableAcceptButton={labelsList.length === 0}
            rejectLabel={'Back'}
            onReject={onReject}
        />
    );
};

const mapDispatchToProps = {
    updateActivePopupTypeAction: updateActivePopupType,
    updateLabelNamesAction: updateLabelNames,
    submitNewNotificationAction: submitNewNotification
};

const mapStateToProps = (state: AppState) => ({});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(LoadLabelNamesPopup);

```

Path: src/views/PopupView/LoadMoreImagesPopup/LoadMoreImagesPopup.tsx
```tsx
import React from 'react';
import './LoadMoreImagesPopup.scss';
import { AppState } from '../../../store';
import { connect } from 'react-redux';
import { addImageData } from '../../../store/labels/actionCreators';
import { GenericYesNoPopup } from '../GenericYesNoPopup/GenericYesNoPopup';
import { useDropzone } from 'react-dropzone';
import { ImageData } from '../../../store/labels/types';
import { PopupActions } from '../../../logic/actions/PopupActions';
import { ImageDataUtil } from '../../../utils/ImageDataUtil';

interface IProps {
    addImageData: (imageData: ImageData[]) => any;
}

const LoadMoreImagesPopup: React.FC<IProps> = ({ addImageData }) => {
    const { acceptedFiles, getRootProps, getInputProps } = useDropzone({
        accept: {
            'image/*': ['.jpeg', '.png']
        }
    });

    const onAccept = () => {
        if (acceptedFiles.length > 0) {
            addImageData(acceptedFiles.map((fileData: File) => ImageDataUtil.createImageDataFromFileData(fileData)));
            PopupActions.close();
        }
    };

    const onReject = () => {
        PopupActions.close();
    };

    const getDropZoneContent = () => {
        if (acceptedFiles.length === 0)
            return <>
                <input {...getInputProps()} />
                <img
                    draggable={false}
                    alt={'upload'}
                    src={'ico/box-opened.png'}
                />
                <p className='extraBold'>Add new images</p>
                <p>or</p>
                <p className='extraBold'>Click here to select them</p>
            </>;
        else if (acceptedFiles.length === 1)
            return <>
                <img
                    draggable={false}
                    alt={'uploaded'}
                    src={'ico/box-closed.png'}
                />
                <p className='extraBold'>1 new image loaded</p>
            </>;
        else
            return <>
                <img
                    draggable={false}
                    key={1}
                    alt={'uploaded'}
                    src={'ico/box-closed.png'}
                />
                <p key={2} className='extraBold'>{acceptedFiles.length} new images loaded</p>
            </>;
    };

    const renderContent = () => {
        return (<div className='LoadMoreImagesPopupContent'>
            <div {...getRootProps({ className: 'DropZone' })}>
                {getDropZoneContent()}
            </div>
        </div>);
    };

    return (
        <GenericYesNoPopup
            title={'Load more images'}
            renderContent={renderContent}
            acceptLabel={'Load'}
            disableAcceptButton={acceptedFiles.length < 1}
            onAccept={onAccept}
            rejectLabel={'Cancel'}
            onReject={onReject}
        />
    );
};

const mapDispatchToProps = {
    addImageData
};

const mapStateToProps = (state: AppState) => ({});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(LoadMoreImagesPopup);
```

Path: src/views/PopupView/ExportLabelsPopup/ExportLabelPopup.tsx
```tsx
import React, { useState } from 'react';
import './ExportLabelPopup.scss';
import { AnnotationFormatType } from '../../../data/enums/AnnotationFormatType';
import { RectLabelsExporter } from '../../../logic/export/RectLabelsExporter';
import { LabelType } from '../../../data/enums/LabelType';
import { ILabelFormatData } from '../../../interfaces/ILabelFormatData';
import { PointLabelsExporter } from '../../../logic/export/PointLabelsExport';
import { PolygonLabelsExporter } from '../../../logic/export/polygon/PolygonLabelsExporter';
import { PopupActions } from '../../../logic/actions/PopupActions';
import { LineLabelsExporter } from '../../../logic/export/LineLabelExport';
import { TagLabelsExporter } from '../../../logic/export/TagLabelsExport';
import GenericLabelTypePopup from '../GenericLabelTypePopup/GenericLabelTypePopup';
import { ExportFormatData } from '../../../data/ExportFormatData';
import { AppState } from '../../../store';
import { connect } from 'react-redux';

interface IProps {
    activeLabelType: LabelType,
}

const ExportLabelPopup: React.FC<IProps> = ({ activeLabelType }) => {
    const [labelType, setLabelType] = useState(activeLabelType);
    const [exportFormatType, setExportFormatType] = useState(null);

    const onAccept = (type: LabelType) => {
        switch (type) {
            case LabelType.RECT:
                RectLabelsExporter.export(exportFormatType);
                break;
            case LabelType.POINT:
                PointLabelsExporter.export(exportFormatType);
                break;
            case LabelType.LINE:
                LineLabelsExporter.export(exportFormatType);
                break;
            case LabelType.POLYGON:
                PolygonLabelsExporter.export(exportFormatType);
                break;
            case LabelType.IMAGE_RECOGNITION:
                TagLabelsExporter.export(exportFormatType);
                break;
        }
        PopupActions.close();
    };

    const onReject = (type: LabelType) => {
        PopupActions.close();
    };

    const onSelect = (type: AnnotationFormatType) => {
        setExportFormatType(type);
    };

    const getOptions = (exportFormatData: ILabelFormatData[]) => {
        return exportFormatData.map((entry: ILabelFormatData) => {
            return <div
                className='OptionsItem'
                onClick={() => onSelect(entry.type)}
                key={entry.type}
            >
                {entry.type === exportFormatType ?
                    <img
                        draggable={false}
                        src={'ico/checkbox-checked.png'}
                        alt={'checked'}
                    /> :
                    <img
                        draggable={false}
                        src={'ico/checkbox-unchecked.png'}
                        alt={'unchecked'}
                    />}
                {entry.label}
            </div>;
        });
    };

    const renderInternalContent = (type: LabelType) => {
        return <>
            <div className='Message'>
                Select label type and the file format you would like to use to export labels.
            </div>,
            <div className='Options'>
                {getOptions(ExportFormatData[type])}
            </div>
        </>;
    };

    const onLabelTypeChange = (type: LabelType) => {
        setLabelType(type);
        setExportFormatType(null);
    };

    return (
        <GenericLabelTypePopup
            activeLabelType={labelType}
            title={`Export ${labelType.toLowerCase()} annotations`}
            onLabelTypeChange={onLabelTypeChange}
            acceptLabel={'Export'}
            onAccept={onAccept}
            disableAcceptButton={!exportFormatType}
            rejectLabel={'Cancel'}
            onReject={onReject}
            renderInternalContent={renderInternalContent}
        />
    );
};

const mapDispatchToProps = {};

const mapStateToProps = (state: AppState) => ({
    activeLabelType: state.labels.activeLabelType,
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(ExportLabelPopup);
```

Path: src/views/PopupView/LoadYOLOv5ModelPopup/LoadYOLOv5ModelPopup.tsx
```tsx
import React, {useState} from 'react';
import './LoadYOLOv5ModelPopup.scss'
import {GenericYesNoPopup} from '../GenericYesNoPopup/GenericYesNoPopup';
import {PopupActions} from '../../../logic/actions/PopupActions';
import {ImageButton} from '../../Common/ImageButton/ImageButton';
import {
    ModelConfig,
    YOLO_V5_M_COCO_MODEL_CONFIG,
    YOLO_V5_N_COCO_MODEL_CONFIG,
    YOLO_V5_S_COCO_MODEL_CONFIG
} from 'yolov5js'
import {AppState} from '../../../store';
import {connect} from 'react-redux';
import {PopupWindowType} from '../../../data/enums/PopupWindowType';
import {GeneralActionTypes} from '../../../store/general/types';
import {YOLOV5ObjectDetector} from '../../../ai/YOLOV5ObjectDetector';
import {updateActivePopupType} from '../../../store/general/actionCreators';
import {submitNewNotification} from '../../../store/notifications/actionCreators';
import {INotification, NotificationsActionType} from '../../../store/notifications/types';
import {NotificationUtil} from '../../../utils/NotificationUtil';
import {NotificationsDataMap} from '../../../data/info/NotificationsData';
import {Notification} from '../../../data/enums/Notification';
import {CSSHelper} from '../../../logic/helpers/CSSHelper';
import {ClipLoader} from 'react-spinners';
import {useDropzone} from 'react-dropzone';
import {YOLOUtils} from '../../../logic/import/yolo/YOLOUtils';
import {LabelName} from '../../../store/labels/types';
import {LabelNamesNotUniqueError} from '../../../logic/import/yolo/YOLOErrors';

enum ModelSource {
    DOWNLOAD = 'DOWNLOAD',
    UPLOAD = 'UPLOAD'
}

enum PretrainedModel {
    YOLO_V5_N_COCO = 'YOLO_V5_N_COCO',
    YOLO_V5_S_COCO = 'YOLO_V5_S_COCO',
    YOLO_V5_M_COCO = 'YOLO_V5_M_COCO'
}

interface IPretrainedModelSpecification {
    config: ModelConfig,
    name: string
}

const PretrainedModelDataMap: Record<PretrainedModel, IPretrainedModelSpecification> = {
    [PretrainedModel.YOLO_V5_N_COCO]: {
        config: YOLO_V5_N_COCO_MODEL_CONFIG,
        name: 'YOLOv5n / COCO'
    },
    [PretrainedModel.YOLO_V5_S_COCO]: {
        config: YOLO_V5_S_COCO_MODEL_CONFIG,
        name: 'YOLOv5s / COCO'
    },
    [PretrainedModel.YOLO_V5_M_COCO]: {
        config: YOLO_V5_M_COCO_MODEL_CONFIG,
        name: 'YOLOv5m / COCO'
    }
}

interface IProps {
    updateActivePopupTypeAction: (activePopupType: PopupWindowType) => GeneralActionTypes;
    submitNewNotificationAction: (notification: INotification) => NotificationsActionType;
}

const LoadYOLOv5ModelPopup: React.FC<IProps> = ({ updateActivePopupTypeAction, submitNewNotificationAction }) => {

    // BUSINESS LOGIC

    const [modelSource, setModelSource] = useState(ModelSource.UPLOAD);
    const [selectedPretrainedModel, setSelectedPretrainedModel] = useState(PretrainedModel.YOLO_V5_N_COCO);
    const [isLoading, setIsLoading] = useState(false);
    const [modelFiles, setModeFiles] = useState([]);
    const [classNames, setClassNames] = useState([]);

    const onDrop = (accepted: File[]) => {
        const jsonFiles = accepted.filter((file: File) => file.name.endsWith('json'));
        const binFiles = accepted.filter((file: File) => file.name.endsWith('bin'));
        const txtFiles = accepted.filter((file: File) => file.name.endsWith('txt'));

        if (txtFiles.length === 0) {
            submitNewNotificationAction(NotificationUtil.createErrorNotification(
                NotificationsDataMap[Notification.LABELS_FILE_UPLOAD_ERROR]))
        }

        if (jsonFiles.length === 1 && txtFiles.length === 1 && binFiles.length > 0) {
            const onSuccess = (labels: LabelName[]) => {
                setClassNames(labels)
                setModeFiles([...jsonFiles, ...binFiles])
            }
            const onFailure = (error) => {
                if (error instanceof LabelNamesNotUniqueError) {
                    submitNewNotificationAction(NotificationUtil
                        .createErrorNotification(NotificationsDataMap[Notification.NON_UNIQUE_LABEL_NAMES_ERROR]));
                }
            }
            YOLOUtils.loadLabelsList(txtFiles[0], onSuccess, onFailure)
        }
    }

    const {acceptedFiles, getRootProps, getInputProps} = useDropzone({ onDrop });

    const onAccept = () => {
        const onSuccess = () => {
            PopupActions.close();
        }
        const onFailure = () => {
            setIsLoading(false)
            const notification = modelSource === ModelSource.UPLOAD ?
                Notification.MODEL_LOAD_ERROR : Notification.MODEL_DOWNLOAD_ERROR
            submitNewNotificationAction(NotificationUtil.createErrorNotification(NotificationsDataMap[notification]
            ))
        }
        setIsLoading(true)
        if (modelSource === ModelSource.DOWNLOAD) {
            YOLOV5ObjectDetector.loadModel(PretrainedModelDataMap[selectedPretrainedModel].config, onSuccess, onFailure)
        } else {
            const config = { source: modelFiles, classNames: classNames.map((className: LabelName) => className.name) }
            YOLOV5ObjectDetector.loadModel(config, onSuccess, onFailure)
        }
    }

    const onReject = () => {
        updateActivePopupTypeAction(PopupWindowType.LOAD_AI_MODEL);
    }

    const changeModelSource = (source: ModelSource) => {
        setModelSource(source)
        setModeFiles([])
        setClassNames([])
    }

    // RENDER

    const renderMenu = () => {
        return(<div className='left-container'>
            <ImageButton
                image={'ico/upload.png'}
                imageAlt={'upload model weights'}
                buttonSize={{ width: 40, height: 40 }}
                padding={15}
                onClick={() => changeModelSource(ModelSource.UPLOAD)}
                externalClassName={'monochrome'}
                isActive={modelSource === ModelSource.UPLOAD}
            />
            <ImageButton
                image={'ico/download.png'}
                imageAlt={'download model weights'}
                buttonSize={{ width: 40, height: 40 }}
                padding={15}
                onClick={() => changeModelSource(ModelSource.DOWNLOAD)}
                externalClassName={'monochrome'}
                isActive={modelSource === ModelSource.DOWNLOAD}
            />
        </div>)
    }

    const getOptionsContent = () => {
        return Object.entries(PretrainedModelDataMap).map(([key, value]) => {
            return <div
                className='options-item'
                onClick={() => setSelectedPretrainedModel(key as PretrainedModel)}
                key={key}
            >
                {key === selectedPretrainedModel ?
                    <img
                        draggable={false}
                        src={'ico/checkbox-checked.png'}
                        alt={'checked'}
                    /> :
                    <img
                        draggable={false}
                        src={'ico/checkbox-unchecked.png'}
                        alt={'unchecked'}
                    />}
                {value.name}
            </div>
        })
    }

    const renderOptions = () => {
        return(<div className='options'>
            {getOptionsContent()}
        </div>)
    }

    const renderMessage = () => {
        const uploadMessage: string = 'Drag and drop your own YOLOv5 model converted to tensorflow.js format and ' +
            'speed up annotation process. Make sure to upload all required files: model.json, model shards as well ' +
            'as .txt containing list of detected classes names.'
        const downloadMessage: string = 'Use one of ours pretrained YOLOv5 models to speed up annotation process.'
        return(<div className='message'>
            {modelSource === ModelSource.DOWNLOAD ? downloadMessage : uploadMessage}
        </div>)
    }

    const renderLoader = () => {
        return(<div className='loader'>
            <ClipLoader
                size={40}
                color={CSSHelper.getLeadingColor()}
                loading={true}
            />
        </div>)
    }

    const getDropZoneContent = () => {
        if (modelFiles.length === 0 && classNames.length === 0) {
            return <>
                <input {...getInputProps()} />
                <img
                    draggable={false}
                    alt={'upload'}
                    src={'ico/box-opened.png'}
                />
                <p className='extraBold'>Drop model files</p>
                <p>or</p>
                <p className='extraBold'>Click here to select them</p>
            </>;
        } else {
            return <>
                <input {...getInputProps()} />
                <img
                    draggable={false}
                    alt={'uploaded'}
                    src={'ico/box-closed.png'}
                />
                <p className='extraBold'>{modelFiles.length} model files</p>
                <p className='extraBold'>{classNames.length} class names</p>
            </>;
        }

    }

    const renderDropZone = () => {
        return(<div {...getRootProps({ className: 'drop-zone' })}>
            {getDropZoneContent()}
        </div>)
    }

    const renderContent = () => {
        const shouldRenderDropZone = !isLoading && modelSource === ModelSource.UPLOAD
        const shouldRenderOptions = !isLoading && modelSource === ModelSource.DOWNLOAD
        return (<div className='load-yolo-v5-model-popup'>
            {renderMenu()}
            <div className='right-container'>
                {isLoading && renderLoader()}
                {!isLoading && renderMessage()}
                {shouldRenderOptions && renderOptions()}
                {shouldRenderDropZone && renderDropZone()}
            </div>
        </div>);
    }

    const disableAcceptButton = modelSource === ModelSource.UPLOAD &&
        (modelFiles.length === 0 || classNames.length === 0)

    return (
        <GenericYesNoPopup
            title={'Load YOLOv5 model'}
            renderContent={renderContent}
            disableAcceptButton={disableAcceptButton}
            acceptLabel={'Use model!'}
            onAccept={onAccept}
            rejectLabel={'Back'}
            onReject={onReject}
        />
    );
}

const mapDispatchToProps = {
    updateActivePopupTypeAction: updateActivePopupType,
    submitNewNotificationAction: submitNewNotification
};

const mapStateToProps = (state: AppState) => ({});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(LoadYOLOv5ModelPopup);

```

Path: src/views/PopupView/ConnectInferenceServerPopup/ConnectInferenceServerPopup.tsx
```tsx
import React, { useState } from 'react';
import { PopupActions } from '../../../logic/actions/PopupActions';
import { AppState } from '../../../store';
import { connect } from 'react-redux';
import { GenericSideMenuPopup } from '../GenericSideMenuPopup/GenericSideMenuPopup';
import { ImageButton } from '../../Common/ImageButton/ImageButton';
import { InferenceServerDataMap } from '../../../data/info/InferenceServerData';
import { InferenceServerType } from '../../../data/enums/InferenceServerType';
import { INotification, NotificationsActionType } from '../../../store/notifications/types';
import { submitNewNotification } from '../../../store/notifications/actionCreators';
import { NotificationUtil } from '../../../utils/NotificationUtil';
import { NotificationsDataMap } from '../../../data/info/NotificationsData';
import { Notification } from '../../../data/enums/Notification';
import './ConnectInferenceServerPopup.scss'
import { StyledTextField } from '../../Common/StyledTextField/StyledTextField';
import { AIActionTypes, RoboflowAPIDetails } from '../../../store/ai/types';
import { RoboflowAPIObjectDetector } from '../../../ai/RoboflowAPIObjectDetector';
import { ClipLoader } from 'react-spinners';
import { CSSHelper } from '../../../logic/helpers/CSSHelper';
import { updateRoboflowAPIDetails } from '../../../store/ai/actionCreators';
import { AIActions } from '../../../logic/actions/AIActions';
import { ImageRepository } from '../../../logic/imageRepository/ImageRepository';
import { ImageData } from '../../../store/labels/types';
import { LabelsSelector } from '../../../store/selectors/LabelsSelector';

interface IProps {
    roboflowAPIDetails: RoboflowAPIDetails;
    submitNewNotificationAction: (notification: INotification) => NotificationsActionType;
    updateRoboflowAPIDetailsAction: (roboflowAPIDetails: RoboflowAPIDetails) => AIActionTypes;
}

const ConnectInferenceServerPopup: React.FC<IProps> = (
    {
        roboflowAPIDetails,
        submitNewNotificationAction,
        updateRoboflowAPIDetailsAction
    }
) => {
    // general
    const [currentServerType, setCurrentServerType] = useState(InferenceServerType.ROBOFLOW);
    const [modelIsLoadingStatus, setModelIsLoadingStatus] = useState(false);

    // roboflow
    const [roboflowModel, setRoboflowModel] = useState(roboflowAPIDetails.model);
    const [roboflowKey, setRoboflowKey] = useState(roboflowAPIDetails.key);

    const wrapServerOnClick = (newServerType: InferenceServerType) => {
        return () => {
            if (!InferenceServerDataMap[newServerType].isDisabled) {
                setCurrentServerType(newServerType)
            } else {
                submitNewNotificationAction(NotificationUtil.createMessageNotification(
                    NotificationsDataMap[Notification.UNSUPPORTED_INFERENCE_SERVER_MESSAGE]));
                return;
            }
        }
    }

    const disableAcceptButton = () => {
        if (modelIsLoadingStatus) return true;

        switch(currentServerType) {
            case InferenceServerType.ROBOFLOW:
                return roboflowModel === '' || roboflowKey === ''
            default:
                return true;
        }
    }

    const onAccept = () => {
        if (disableAcceptButton()) return;

        const onSuccess = () => {
            updateRoboflowAPIDetailsAction({
                status: true,
                model: roboflowModel,
                key: roboflowKey
            })
            PopupActions.close();

            const activeImageData: ImageData = LabelsSelector.getActiveImageData();
            AIActions.detect(activeImageData.id, ImageRepository.getById(activeImageData.id));
        }

        const onFailure = () => {
            submitNewNotificationAction(NotificationUtil.createErrorNotification(
                NotificationsDataMap[Notification.ROBOFLOW_INFERENCE_SERVER_ERROR]));
            setModelIsLoadingStatus(false);
        }

        setModelIsLoadingStatus(true);
        RoboflowAPIObjectDetector.loadModel({
            status: false,
            model: roboflowModel,
            key: roboflowKey
        }, onSuccess, onFailure)
    };

    const onReject = () => {
        PopupActions.close();
    };

    const roboflowModelOnChangeCallback = (event: React.ChangeEvent<HTMLInputElement>) => {
        setRoboflowModel(event.target.value)
    }

    const roboflowKeyOnChangeCallback = (event: React.ChangeEvent<HTMLInputElement>) => {
        setRoboflowKey(event.target.value)
    }

    const renderLoader = () => {
        return(<div className='loader'>
            <ClipLoader
                size={40}
                color={CSSHelper.getLeadingColor()}
                loading={true}
            />
        </div>)
    }

    const renderRoboflow = () => {
        return <>
            <div className='message'>
                Provide details of the Roboflow model you want to run over tha API, as well as your API key.
            </div>
            <div className='details'>
                <StyledTextField
                    variant='standard'
                    id={'roboflow-model'}
                    autoComplete={'off'}
                    autoFocus={true}
                    type={'text'}
                    margin={'dense'}
                    label={'roboflow model'}
                    value={roboflowModel}
                    onChange={roboflowModelOnChangeCallback}
                    style={{ width: 280 }}
                    InputLabelProps={{ shrink: true }}
                />
                <StyledTextField
                    variant='standard'
                    id={'roboflow-api- key'}
                    autoComplete={'off'}
                    autoFocus={true}
                    type={'password'}
                    margin={'dense'}
                    label={'roboflow api key'}
                    value={roboflowKey}
                    onChange={roboflowKeyOnChangeCallback}
                    style={{ width: 280 }}
                    InputLabelProps={{ shrink: true }}
                />
            </div>
        </>;
    }

    const renderContent = (): JSX.Element => {
        if (modelIsLoadingStatus) {
            return renderLoader()
        }
        if (currentServerType === InferenceServerType.ROBOFLOW) {
            return renderRoboflow();
        }
        return <div className='load-model-popup-content'/>
    };

    const renderSideMenuContent = (): JSX.Element[] => {
        return Object.entries(InferenceServerDataMap).map(([serverType, serverData], index: number) => {
            return <ImageButton
                key={index}
                image={serverData.imageSrc}
                imageAlt={serverData.imageAlt}
                buttonSize={{width: 40, height: 40}}
                padding={20}
                onClick={wrapServerOnClick(serverType as InferenceServerType)}
                isActive={currentServerType === serverType}
                isDisabled={serverData.isDisabled}
            />
        })
    }

    return (
        <GenericSideMenuPopup
            title={InferenceServerDataMap[currentServerType].name}
            renderContent={renderContent}
            renderSideMenuContent={renderSideMenuContent}
            acceptLabel={'Connect'}
            onAccept={onAccept}
            disableAcceptButton={disableAcceptButton()}
            rejectLabel={'Back'}
            onReject={onReject}
        />
    );
}

const mapDispatchToProps = {
    submitNewNotificationAction: submitNewNotification,
    updateRoboflowAPIDetailsAction: updateRoboflowAPIDetails
};

const mapStateToProps = (state: AppState) => ({
    roboflowAPIDetails: state.ai.roboflowAPIDetails
});

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(ConnectInferenceServerPopup);
```

Path: src/views/PopupView/GenericLabelTypePopup/GenericLabelTypePopup.tsx
```tsx
import React, {useState} from 'react'
import './GenericLabelTypePopup.scss'
import {LabelType} from '../../../data/enums/LabelType';
import {AppState} from '../../../store';
import {connect} from 'react-redux';
import {ImageButton} from '../../Common/ImageButton/ImageButton';
import {GenericYesNoPopup} from '../GenericYesNoPopup/GenericYesNoPopup';
import {ILabelToolkit, LabelToolkitData} from '../../../data/info/LabelToolkitData';
import {ProjectType} from '../../../data/enums/ProjectType';

interface IProps {
    title: string,
    activeLabelType: LabelType,
    projectType: ProjectType;
    onLabelTypeChange?: (labelType: LabelType) => any;
    acceptLabel: string;
    onAccept: (labelType: LabelType) => any;
    skipAcceptButton?: boolean;
    disableAcceptButton?: boolean;
    rejectLabel: string;
    onReject: (labelType: LabelType) => any;
    renderInternalContent: (labelType: LabelType) => any;
}

const GenericLabelTypePopup: React.FC<IProps> = (
    {
        title,
        activeLabelType,
        projectType,
        onLabelTypeChange,
        acceptLabel,
        onAccept,
        skipAcceptButton,
        disableAcceptButton,
        rejectLabel,
        onReject,
        renderInternalContent
    }) => {

    const [labelType, setLabelType] = useState(activeLabelType);

    const getSidebarButtons = () => {
        return LabelToolkitData
            .filter((label: ILabelToolkit) => label.projectType === projectType)
            .map((label: ILabelToolkit) => {
                return <ImageButton
                    key={label.labelType}
                    image={label.imageSrc}
                    imageAlt={label.imageAlt}
                    buttonSize={{width: 40, height: 40}}
                    padding={20}
                    onClick={() => {
                        setLabelType(label.labelType);
                        onLabelTypeChange(label.labelType);
                    }}
                    isActive={labelType === label.labelType}
                />
            })
    }

    const renderContent = () => {
        return (<div className='GenericLabelTypePopupContent'>
            <div className='LeftContainer'>
                {getSidebarButtons()}
            </div>
            <div className='RightContainer'>
                {renderInternalContent(labelType)}
            </div>
        </div>);
    }

    return(
        <GenericYesNoPopup
            title={title}
            renderContent={renderContent}
            acceptLabel={acceptLabel}
            onAccept={() => onAccept(labelType)}
            skipAcceptButton={skipAcceptButton}
            disableAcceptButton={disableAcceptButton}
            rejectLabel={rejectLabel}
            onReject={() => onReject(labelType)}
        />
    );
};

const mapDispatchToProps = {};

const mapStateToProps = (state: AppState) => ({
    projectType: state.general.projectData.type
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(GenericLabelTypePopup);
```

Path: src/views/PopupView/GenericYesNoPopup/GenericYesNoPopup.tsx
```tsx
import React, {useEffect, useState} from 'react'
import './GenericYesNoPopup.scss'
import {TextButton} from '../../Common/TextButton/TextButton';
import {ContextManager} from '../../../logic/context/ContextManager';
import {ContextType} from '../../../data/enums/ContextType';

interface IProps {
    title: string;
    renderContent: () => any;
    acceptLabel?: string;
    onAccept?: () => any;
    skipAcceptButton?: boolean;
    disableAcceptButton?: boolean;
    rejectLabel?: string;
    onReject?: () => any;
    skipRejectButton?: boolean;
    disableRejectButton?: boolean;
}

export const GenericYesNoPopup: React.FC<IProps> = (
    {
        title,
        renderContent,
        acceptLabel,
        onAccept,
        skipAcceptButton,
        disableAcceptButton,
        rejectLabel,
        onReject,
        skipRejectButton,
        disableRejectButton
    }) => {

    const [status, setMountStatus] = useState(false);
    useEffect(() => {
        if (!status) {
            ContextManager.switchCtx(ContextType.POPUP);
            setMountStatus(true);
        }
    }, [status]);

    return (
        <div className='GenericYesNoPopup'>
            <div className='Header'>
                {title}
            </div>
            <div className='Content'>
                {renderContent()}
            </div>
            <div className='Footer'>
                {!skipRejectButton && <TextButton
                    label={rejectLabel ? rejectLabel : 'NO, THANKS'}
                    onClick={onReject}
                    externalClassName={'reject'}
                    isDisabled={disableRejectButton}
                />}
                {!skipAcceptButton && <TextButton
                    label={acceptLabel ? acceptLabel : 'YES'}
                    onClick={onAccept}
                    externalClassName={'accept'}
                    isDisabled={disableAcceptButton}
                />}
            </div>
        </div>
    )
};

```

Path: src/views/PopupView/LoadModelPopup/LoadModelPopup.tsx
```tsx
import React, {useState} from 'react';
import {PopupActions} from '../../../logic/actions/PopupActions';
import {GenericYesNoPopup} from '../GenericYesNoPopup/GenericYesNoPopup';
import {SSDObjectDetector} from '../../../ai/SSDObjectDetector';
import './LoadModelPopup.scss'
import {ClipLoader} from 'react-spinners';
import {AIModel} from '../../../data/enums/AIModel';
import {PoseDetector} from '../../../ai/PoseDetector';
import {findLast} from 'lodash';
import {CSSHelper} from '../../../logic/helpers/CSSHelper';
import {updateActivePopupType as storeUpdateActivePopupType} from '../../../store/general/actionCreators';
import {AppState} from '../../../store';
import {connect} from 'react-redux';
import {PopupWindowType} from '../../../data/enums/PopupWindowType';
import {GeneralActionTypes} from '../../../store/general/types';

interface SelectableModel {
    model: AIModel,
    name: string,
    flag: boolean
}

const models: SelectableModel[] = [
    {
        model: AIModel.YOLO_V5_OBJECT_DETECTION,
        name: 'YOLOv5 - object detection using rectangles',
        flag: false
    },
    {
        model: AIModel.SSD_OBJECT_DETECTION,
        name: 'COCO SSD - object detection using rectangles',
        flag: false
    },
    {
        model: AIModel.POSE_DETECTION,
        name: 'POSE-NET - pose estimation using points',
        flag: false
    }
];

interface IProps {
    updateActivePopupType: (activePopupType: PopupWindowType) => GeneralActionTypes;
}

const LoadModelPopup: React.FC<IProps> = ({ updateActivePopupType }) => {
    const [modelIsLoadingStatus, setModelIsLoadingStatus] = useState(false);
    const [selectedModelToLoad, updateSelectedModelToLoad] = useState(models);

    const extractSelectedModel = (): AIModel => {
        const model: SelectableModel = findLast(selectedModelToLoad, { flag: true });
        if (!!model) {
            return model.model
        } else {
            return null;
        }
    };

    const onAccept = () => {
        setModelIsLoadingStatus(true);
        switch (extractSelectedModel()) {
            case AIModel.POSE_DETECTION:
                PoseDetector.loadModel(() => {
                    PopupActions.close();
                });
                break;
            case AIModel.SSD_OBJECT_DETECTION:
                SSDObjectDetector.loadModel(() => {
                    PopupActions.close();
                });
                break;
            case AIModel.YOLO_V5_OBJECT_DETECTION:
                updateActivePopupType(PopupWindowType.LOAD_YOLO_V5_MODEL);
                break;
        }
    };

    const onSelect = (selectedModel: AIModel) => {
        const nextSelectedModelToLoad: SelectableModel[] = selectedModelToLoad.map((model: SelectableModel) => {
            if (model.model === selectedModel)
                return {
                    ...model,
                    flag: !model.flag
                };
            else
                return {
                    ...model,
                    flag: false
                };
        });
        updateSelectedModelToLoad(nextSelectedModelToLoad);
    };

    const getOptions = () => {
        return selectedModelToLoad.map((entry: SelectableModel) => {
            return <div
                className='OptionsItem'
                onClick={() => onSelect(entry.model)}
                key={entry.model}
            >
                {entry.flag ?
                    <img
                        draggable={false}
                        src={'ico/checkbox-checked.png'}
                        alt={'checked'}
                    /> :
                    <img
                        draggable={false}
                        src={'ico/checkbox-unchecked.png'}
                        alt={'unchecked'}
                    />}
                {entry.name}
            </div>
        })
    };

    const onReject = () => {
        PopupActions.close();
    };

    const renderContent = () => {
        return <div className='LoadModelPopupContent'>
            <div className='Message'>
                Speed up your annotation process using AI. Don't worry, your photos are still safe. To take care of
                your privacy, we decided not to send your images to the server, but instead bring AI to you. Make sure
                that you have a fast and stable connection - it may take a while to load the model.
            </div>
            <div className='Companion'>
                {modelIsLoadingStatus ?
                    <ClipLoader
                        size={40}
                        color={CSSHelper.getLeadingColor()}
                        loading={true}
                    /> :
                    <div className='Options'>
                        {getOptions()}
                    </div>
                }
            </div>
        </div>
    };

    return (
        <GenericYesNoPopup
            title={'Say hello to AI'}
            renderContent={renderContent}
            acceptLabel={'Use model!'}
            onAccept={onAccept}
            disableAcceptButton={modelIsLoadingStatus || !extractSelectedModel()}
            rejectLabel={"I'm going on my own"}
            onReject={onReject}
            disableRejectButton={modelIsLoadingStatus}
        />
    );
};

const mapDispatchToProps = {
    updateActivePopupType: storeUpdateActivePopupType
};

const mapStateToProps = (state: AppState) => ({});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(LoadModelPopup);

```

Path: src/views/PopupView/ImportLabelPopup/ImportLabelPopup.tsx
```tsx
import React, { useState } from 'react';
import './ImportLabelPopup.scss';
import { LabelType } from '../../../data/enums/LabelType';
import { PopupActions } from '../../../logic/actions/PopupActions';
import GenericLabelTypePopup from '../GenericLabelTypePopup/GenericLabelTypePopup';
import { ImportFormatData } from '../../../data/ImportFormatData';
import { FeatureInProgress } from '../../EditorView/FeatureInProgress/FeatureInProgress';
import { AppState } from '../../../store';
import { connect } from 'react-redux';
import { useDropzone } from 'react-dropzone';
import { ImageData, LabelName } from '../../../store/labels/types';
import { updateActiveLabelType, updateImageData, updateLabelNames } from '../../../store/labels/actionCreators';
import { ImporterSpecData } from '../../../data/ImporterSpecData';
import { AnnotationFormatType } from '../../../data/enums/AnnotationFormatType';
import { ILabelFormatData } from '../../../interfaces/ILabelFormatData';
import { submitNewNotification } from '../../../store/notifications/actionCreators';
import { NotificationUtil } from '../../../utils/NotificationUtil';
import { NotificationsDataMap } from '../../../data/info/NotificationsData';
import { DocumentParsingError } from '../../../logic/import/voc/VOCImporter';
import { Notification } from '../../../data/enums/Notification';
import {LabelNamesNotUniqueError} from '../../../logic/import/yolo/YOLOErrors';

interface IProps {
    activeLabelType: LabelType,
    updateImageDataAction: (imageData: ImageData[]) => any,
    updateLabelNamesAction: (labels: LabelName[]) => any,
    updateActiveLabelTypeAction: (activeLabelType: LabelType) => any;
}

const ImportLabelPopup: React.FC<IProps> = (
    {
        activeLabelType,
        updateImageDataAction,
        updateLabelNamesAction,
        updateActiveLabelTypeAction
    }) => {
    const resolveFormatType = (labelType: LabelType): AnnotationFormatType => {
        const possibleImportFormats = ImportFormatData[labelType];
        return possibleImportFormats.length === 1 ? possibleImportFormats[0].type : null;
    };

    const [labelType, setLabelType] = useState(activeLabelType);
    const [formatType, setFormatType] = useState(resolveFormatType(activeLabelType));
    const [loadedLabelNames, setLoadedLabelNames] = useState([]);
    const [loadedImageData, setLoadedImageData] = useState([]);
    const [annotationsLoadedError, setAnnotationsLoadedError] = useState(null);

    const resolveNotification = (error: Error): Notification => {
        if (error instanceof DocumentParsingError) {
            return Notification.ANNOTATION_FILE_PARSE_ERROR
        }
        if (error instanceof LabelNamesNotUniqueError) {
            return Notification.NON_UNIQUE_LABEL_NAMES_ERROR
        }
        return Notification.ANNOTATION_IMPORT_ASSERTION_ERROR
    }

    const onLabelTypeChange = (type: LabelType) => {
        setLabelType(type);
        setFormatType(resolveFormatType(type));
        setLoadedLabelNames([]);
        setLoadedImageData([]);
        setAnnotationsLoadedError(null);
    };

    const onAnnotationLoadSuccess = (imagesData: ImageData[], labelNames: LabelName[]) => {
        setLoadedLabelNames(labelNames);
        setLoadedImageData(imagesData);
        setAnnotationsLoadedError(null);
    };

    const onAnnotationsLoadFailure = (error?: Error) => {
        setLoadedLabelNames([]);
        setLoadedImageData([]);
        setAnnotationsLoadedError(error);
        const notification = resolveNotification(error)
        submitNewNotification(NotificationUtil.createErrorNotification(NotificationsDataMap[notification]));
    };

    const { getRootProps, getInputProps } = useDropzone({
        accept: {
            "application/json": [".json" ],
            "text/plain": [".txt"],
            "application/xml": [".xml"],
        },
        multiple: true,
        onDrop: (acceptedFiles) => {
            const importer = new (ImporterSpecData[formatType])([labelType]);
            importer.import(acceptedFiles, onAnnotationLoadSuccess, onAnnotationsLoadFailure);
        }
    });

    const onAccept = (type: LabelType) => {
        if (loadedLabelNames.length !== 0 && loadedImageData.length !== 0) {
            updateImageDataAction(loadedImageData);
            updateLabelNamesAction(loadedLabelNames);
            updateActiveLabelTypeAction(type);
            PopupActions.close();
        }
    };

    const onReject = (_: LabelType) => {
        PopupActions.close();
    };

    const onAnnotationFormatChange = (format: AnnotationFormatType) => {
        setFormatType(format);
    };

    const getDropZoneContent = () => {
        if (annotationsLoadedError) {
            return <>
                <input {...getInputProps()} />
                <img
                    draggable={false}
                    alt={'upload'}
                    src={'ico/box-opened.png'}
                />
                <p className='extraBold'>Annotation import was unsuccessful</p>
                {annotationsLoadedError.message}
                <p className='extraBold'>Try again</p>
            </>;
        } else if (loadedImageData.length !== 0 && loadedLabelNames.length !== 0) {
            return <>
                <img
                    draggable={false}
                    alt={'uploaded'}
                    src={'ico/box-closed.png'}
                />
                <p className='extraBold'>Annotation ready for import</p>
                After import you will lose
                all your current annotations
            </>;
        } else {
            return <>
                <input {...getInputProps()} />
                <img
                    draggable={false}
                    alt={'upload'}
                    src={'ico/box-opened.png'}
                />
                <p className='extraBold'>{`Drop ${formatType} annotations`}</p>
                <p>or</p>
                <p className='extraBold'>Click here to select them</p>
            </>;
        }
    };

    const getOptions = (exportFormatData: ILabelFormatData[]) => {
        return exportFormatData.map((entry: ILabelFormatData) => {
            return <div
                className='OptionsItem'
                onClick={() => onAnnotationFormatChange(entry.type)}
                key={entry.type}
            >
                {entry.type === formatType ?
                    <img
                        draggable={false}
                        src={'ico/checkbox-checked.png'}
                        alt={'checked'}
                    /> :
                    <img
                        draggable={false}
                        src={'ico/checkbox-unchecked.png'}
                        alt={'unchecked'}
                    />}
                {entry.label}
            </div>;
        });
    };

    const renderInternalContent = (type: LabelType) => {
        if (!formatType && ImportFormatData[type].length !== 0) {
            return <>
                <div className='Message'>
                    Select file format you would like to use to import labels.
                </div>,
                <div className='Options'>
                    {getOptions(ImportFormatData[type])}
                </div>
            </>;
        }
        const importFormatData = ImportFormatData[type];
        return importFormatData.length === 0 ?
            <FeatureInProgress /> :
            <div {...getRootProps({ className: 'DropZone' })}>
                {getDropZoneContent()}
            </div>;
    };

    return (
        <GenericLabelTypePopup
            activeLabelType={labelType}
            title={`Import ${labelType.toLowerCase()} annotations`}
            onLabelTypeChange={onLabelTypeChange}
            acceptLabel={'Import'}
            onAccept={onAccept}
            skipAcceptButton={ImportFormatData[labelType].length === 0}
            disableAcceptButton={loadedImageData.length === 0 || loadedLabelNames.length === 0 || !!annotationsLoadedError}
            rejectLabel={'Cancel'}
            onReject={onReject}
            renderInternalContent={renderInternalContent}
        />
    );
};

const mapDispatchToProps = {
    updateImageDataAction: updateImageData,
    updateLabelNamesAction: updateLabelNames,
    updateActiveLabelTypeAction: updateActiveLabelType
};

const mapStateToProps = (state: AppState) => ({
    activeLabelType: state.labels.activeLabelType,
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(ImportLabelPopup);

```

Path: src/views/PopupView/InsertLabelNamesPopup/InsertLabelNamesPopup.tsx
```tsx
import React, { useState } from 'react';
import './InsertLabelNamesPopup.scss';
import { GenericYesNoPopup } from '../GenericYesNoPopup/GenericYesNoPopup';
import { PopupWindowType } from '../../../data/enums/PopupWindowType';
import { updateLabelNames } from '../../../store/labels/actionCreators';
import { updateActivePopupType, updatePerClassColorationStatus } from '../../../store/general/actionCreators';
import { AppState } from '../../../store';
import { connect } from 'react-redux';
import Scrollbars from 'react-custom-scrollbars-2';
import { ImageButton } from '../../Common/ImageButton/ImageButton';
import { LabelName } from '../../../store/labels/types';
import { LabelUtil } from '../../../utils/LabelUtil';
import { LabelsSelector } from '../../../store/selectors/LabelsSelector';
import { LabelActions } from '../../../logic/actions/LabelActions';
import { ColorSelectorView } from './ColorSelectorView/ColorSelectorView';
import { Settings } from '../../../settings/Settings';
import { reject, sample, filter, uniq } from 'lodash';
import { ProjectType } from '../../../data/enums/ProjectType';
import { submitNewNotification } from '../../../store/notifications/actionCreators';
import { INotification } from '../../../store/notifications/types';
import { NotificationUtil } from '../../../utils/NotificationUtil';
import { NotificationsDataMap } from '../../../data/info/NotificationsData';
import { Notification } from '../../../data/enums/Notification';
import { StyledTextField } from '../../Common/StyledTextField/StyledTextField';

interface IProps {
    updateActivePopupTypeAction: (activePopupType: PopupWindowType) => any;
    updateLabelNamesAction: (labels: LabelName[]) => any;
    updatePerClassColorationStatusAction: (updatePerClassColoration: boolean) => any;
    submitNewNotificationAction: (notification: INotification) => any;
    isUpdate: boolean;
    projectType: ProjectType;
    enablePerClassColoration: boolean;
}

const InsertLabelNamesPopup: React.FC<IProps> = (
    {
        updateActivePopupTypeAction,
        updateLabelNamesAction,
        updatePerClassColorationStatusAction,
        submitNewNotificationAction,
        isUpdate,
        projectType,
        enablePerClassColoration
    }) => {
    const [labelNames, setLabelNames] = useState(LabelsSelector.getLabelNames());

    const validateEmptyLabelNames = (): boolean => {
        const emptyLabelNames = filter(labelNames, (labelName: LabelName) => labelName.name === '');
        return emptyLabelNames.length === 0;
    };

    const validateNonUniqueLabelNames = (): boolean => {
        const uniqueLabelNames = uniq(labelNames.map((labelName: LabelName) => labelName.name));
        return uniqueLabelNames.length === labelNames.length;
    };

    const callbackWithLabelNamesValidation = (callback: () => any): () => any => {
        return () => {
            if (!validateEmptyLabelNames()) {
                submitNewNotificationAction(NotificationUtil
                    .createErrorNotification(NotificationsDataMap[Notification.EMPTY_LABEL_NAME_ERROR]));
                return;
            }
            if (validateNonUniqueLabelNames()) {
                callback();
            } else {
                submitNewNotificationAction(NotificationUtil
                    .createErrorNotification(NotificationsDataMap[Notification.NON_UNIQUE_LABEL_NAMES_ERROR]));
            }
        };
    };

    const addLabelNameCallback = () => {
        const newLabelNames = [
            ...labelNames,
            LabelUtil.createLabelName('')
        ];
        setLabelNames(newLabelNames);
    };

    const safeAddLabelNameCallback = () => callbackWithLabelNamesValidation(addLabelNameCallback)();

    const deleteLabelNameCallback = (id: string) => {
        const newLabelNames = reject(labelNames, { id });
        setLabelNames(newLabelNames);
    };

    const togglePerClassColorationCallback = () => {
        updatePerClassColorationStatusAction(!enablePerClassColoration);
    };

    const changeLabelNameColorCallback = (id: string) => {
        const newLabelNames = labelNames.map((labelName: LabelName) => {
            return labelName.id === id ? { ...labelName, color: sample(Settings.LABEL_COLORS_PALETTE) } : labelName;
        });
        setLabelNames(newLabelNames);
    };

    const onKeyUpCallback = (event: React.KeyboardEvent<HTMLInputElement>) => {
        if (event.key === 'Enter') {
            safeAddLabelNameCallback();
        }
    };

    const onChange = (id: string, value: string) => {
        const newLabelNames = labelNames.map((labelName: LabelName) => {
            return labelName.id === id ? {
                ...labelName, name: value
            } : labelName;
        });
        setLabelNames(newLabelNames);
    };

    const labelInputs = labelNames.map((labelName: LabelName) => {
        const onChangeCallback = (event: React.ChangeEvent<HTMLInputElement>) =>
            onChange(labelName.id, event.target.value);
        const onDeleteCallback = () => deleteLabelNameCallback(labelName.id);
        const onChangeColorCallback = () => changeLabelNameColorCallback(labelName.id);
        return <div className='LabelEntry' key={labelName.id}>
            <StyledTextField variant='standard'
                id={'key'}
                autoComplete={'off'}
                autoFocus={true}
                type={'text'}
                margin={'dense'}
                label={'Insert label'}
                onKeyUp={onKeyUpCallback}
                value={labelName.name}
                onChange={onChangeCallback}
                style={{ width: 280 }}
                InputLabelProps={{
                    shrink: true,
                }}
            />
            {projectType === ProjectType.OBJECT_DETECTION && enablePerClassColoration && <ColorSelectorView
                color={labelName.color}
                onClick={onChangeColorCallback}
            />}
            <ImageButton
                image={'ico/trash.png'}
                imageAlt={'remove_label'}
                buttonSize={{ width: 30, height: 30 }}
                onClick={onDeleteCallback}
            />
        </div>;
    });


    const onCreateAcceptCallback = () => {
        const nonEmptyLabelNames: LabelName[] = reject(labelNames,
            (labelName: LabelName) => labelName.name.length === 0);
        if (labelNames.length > 0) {
            updateLabelNamesAction(nonEmptyLabelNames);
        }
        updateActivePopupTypeAction(null);
    };

    const safeOnCreateAcceptCallback = () => callbackWithLabelNamesValidation(onCreateAcceptCallback)();

    const onUpdateAcceptCallback = () => {
        const nonEmptyLabelNames: LabelName[] = reject(labelNames,
            (labelName: LabelName) => labelName.name.length === 0);
        const missingIds: string[] = LabelUtil.labelNamesIdsDiff(LabelsSelector.getLabelNames(), nonEmptyLabelNames);
        LabelActions.removeLabelNames(missingIds);
        updateLabelNamesAction(nonEmptyLabelNames);
        updateActivePopupTypeAction(null);
    };

    const safeOnUpdateAcceptCallback = () => callbackWithLabelNamesValidation(onUpdateAcceptCallback)();

    const onCreateRejectCallback = () => {
        updateActivePopupTypeAction(PopupWindowType.LOAD_LABEL_NAMES);
    };

    const onUpdateRejectCallback = () => {
        updateActivePopupTypeAction(null);
    };

    const renderContent = () => {
        return (<div className='InsertLabelNamesPopup'>
            <div className='LeftContainer'>
                <ImageButton
                    image={'ico/plus.png'}
                    imageAlt={'plus'}
                    buttonSize={{ width: 40, height: 40 }}
                    padding={25}
                    onClick={safeAddLabelNameCallback}
                    externalClassName={'monochrome'}
                />
                {labelNames.length > 0 && <ImageButton
                    image={enablePerClassColoration ? 'ico/colors-on.png' : 'ico/colors-off.png'}
                    imageAlt={'per-class-coloration'}
                    buttonSize={{ width: 40, height: 40 }}
                    padding={15}
                    onClick={togglePerClassColorationCallback}
                    isActive={enablePerClassColoration}
                    externalClassName={enablePerClassColoration ? '' : 'monochrome'}
                />}
            </div>
            <div className='RightContainer'>
                <div className='Message'>
                    {
                        isUpdate ?
                            'You can now edit the label names you use to describe the objects in the photos. Use the ' +
                            '+ button to add a new empty text field.' :
                            'Before you start, you can create a list of labels you plan to assign to objects in your ' +
                            'project. You can also choose to skip that part for now and define label names as you go.'
                    }
                </div>
                <div className='LabelsContainer'>
                    {Object.keys(labelNames).length !== 0 ? <Scrollbars>
                        <div
                            className='InsertLabelNamesPopupContent'
                        >
                            {labelInputs}
                        </div>
                    </Scrollbars> :
                        <div
                            className='EmptyList'
                            onClick={addLabelNameCallback}
                        >
                            <img
                                draggable={false}
                                alt={'upload'}
                                src={'ico/type-writer.png'}
                            />
                            <p className='extraBold'>Your label list is empty</p>
                        </div>}
                </div>
            </div>
        </div>);
    };

    return (
        <GenericYesNoPopup
            title={isUpdate ? 'Edit labels' : 'Create labels'}
            renderContent={renderContent}
            acceptLabel={isUpdate ? 'Accept' : 'Start project'}
            onAccept={isUpdate ? safeOnUpdateAcceptCallback : safeOnCreateAcceptCallback}
            rejectLabel={isUpdate ? 'Cancel' : 'Load labels from file'}
            onReject={isUpdate ? onUpdateRejectCallback : onCreateRejectCallback}
        />);
};

const mapDispatchToProps = {
    updateActivePopupTypeAction: updateActivePopupType,
    updateLabelNamesAction: updateLabelNames,
    updatePerClassColorationStatusAction: updatePerClassColorationStatus,
    submitNewNotificationAction: submitNewNotification
};

const mapStateToProps = (state: AppState) => ({
    projectType: state.general.projectData.type,
    enablePerClassColoration: state.general.enablePerClassColoration
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(InsertLabelNamesPopup);

```

Path: src/views/PopupView/InsertLabelNamesPopup/ColorSelectorView/ColorSelectorView.tsx
```tsx
import React from 'react';
import './ColorSelectorView.scss'

interface IProps {
    color: string;
    onClick: () => any;
}

export const ColorSelectorView: React.FC<IProps> = ({color, onClick}) => {
    return <div
        className={'ColorSelectorView'}
        style={{
            backgroundColor: color
        }}
        onClick={onClick}
    >
        <img
            draggable={false}
            alt={'refresh'}
            src={'ico/refresh.png'}
        />
    </div>
}

```

Path: src/views/MobileMainView/MobileMainView.tsx
```tsx
import React, {useState} from 'react';
import './MobileMainView.scss';
import Scrollbars from 'react-custom-scrollbars-2';
import {ISize} from "../../interfaces/ISize";
import {AppState} from "../../store";
import {connect} from "react-redux";
import classNames from 'classnames'
import {EditorFeatureData, IEditorFeature} from "../../data/info/EditorFeatureData";
import {ISocialMedia, SocialMediaData} from "../../data/info/SocialMediaData";
import {ImageButton} from "../Common/ImageButton/ImageButton";

interface IProps {
    size: ISize;
}

const MobileMainView: React.FC<IProps> = ({size}) => {
    const scrollPositionThreshold: number = 350;
    const [scrollPosition, setScrollPosition] = useState(0);

    const getClassName = () => {
        return classNames('MobileTopNavigationBar', {
            Hide: scrollPosition < scrollPositionThreshold,
            Show: scrollPosition >= scrollPositionThreshold,
        })
    };

    const onScroll = (value) => {
        setScrollPosition(value.scrollTop);
    };

    const getEditorFeatureTiles = (features: IEditorFeature[]) => {
        return features.map((data:IEditorFeature) => {
            return <div
                className="EditorFeaturesTiles"
                key={data.displayText}
            >
                <div
                    className="EditorFeaturesTilesWrapper"
                >
                    <img
                        draggable={false}
                        alt={data.imageAlt}
                        src={data.imageSrc}
                    />
                    <div className="EditorFeatureLabel">
                        {data.displayText}
                    </div>
                </div>
            </div>
        });
    };

    const getSocialMediaButtons = (mediaSize:ISize) => {
        return SocialMediaData.map((data:ISocialMedia, index: number) => {
            return <ImageButton
                key={index}
                buttonSize={mediaSize}
                image={data.imageSrc}
                imageAlt={data.imageAlt}
                href={data.href}
            />
        });
    };

    const topNavigationBar = <div className={getClassName()}>
        <div className="NavigationBarGroupWrapper">
            <div className="Header">
                <img
                    draggable={false}
                    alt={"make-sense"}
                    src={"/make-sense-ico-transparent.png"}
                />
                Make Sense
            </div>
        </div>
        <div className="TriangleHorizontal Bottom">
            <div className="TriangleHorizontalContent"/>
        </div>
    </div>;

    const firstStage = <div className="FirstStage">
        <img
            draggable={false}
            alt={"main-logo"}
            src={"ico/main-image-color.png"}
        />
        <div className="TriangleHorizontal Bottom">
            <div className="TriangleHorizontalContent"/>
        </div>
    </div>;

    const secondStage = <div className="SecondStage">
        {getEditorFeatureTiles(EditorFeatureData.slice(0, 3))}
    </div>;

    const thirdStage = <div className="ThirdStage">
        {getEditorFeatureTiles(EditorFeatureData.slice(3, 6))}
        <div className="TriangleHorizontal Top">
            <div className="TriangleHorizontalContent"/>
        </div>
        <div className="TriangleHorizontal Bottom">
            <div className="TriangleHorizontalContent"/>
        </div>
    </div>;

    const fourthStage = <div className="FourthStage">
        <div className="Message">
            Due to the small size of the screen we do not support our editor on mobile devices. Check what you missed and visit us from a desktop.
        </div>
        <div className="SocialMediaWrapper">
            {getSocialMediaButtons({width: 40, height: 40})}
        </div>
    </div>;

    return(<div className="MobileMainView">
        {topNavigationBar}
        <Scrollbars
            onScrollFrame={onScroll}
        >
            <div
                className="MobileMainViewContent"
                style={{width: size.width}}
            >
                {firstStage}
                {secondStage}
                {thirdStage}
                {fourthStage}
            </div>
        </Scrollbars>
    </div>)
};

const mapDispatchToProps = {};

const mapStateToProps = (state: AppState) => ({
    size: state.general.windowSize
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(MobileMainView);
```

Path: src/views/Common/TextButton/TextButton.tsx
```tsx
import * as React from 'react';
import './TextButton.scss';
import classNames from 'classnames';

interface IProps {
    key?:string;
    label:string;
    onClick?:() => any;
    style?:React.CSSProperties;
    isActive?:boolean;
    isDisabled?:boolean;
    externalClassName?:string;
}

export const TextButton = (props:IProps) => {
    const { key, label, onClick, style, isActive, isDisabled, externalClassName} = props;

    const getClassName = () => {
        return classNames(
            'TextButton',
            externalClassName,
            {
                'active': isActive,
                'disabled': isDisabled
            }
        );
    };

    const onClickHandler = (event: React.MouseEvent<HTMLDivElement,¬†MouseEvent>) => {
        event.stopPropagation();
        if (onClick) {
            onClick();
        }
    };

    return(
        <div
            className={getClassName()}
            onClick={onClickHandler}
            key={key}
            style={style}
        >
            {label}
        </div>
    )
};

```

Path: src/views/Common/TextInput/TextInput.tsx
```tsx
import React from 'react';
import './TextInput.scss';

interface IProps {
    label?: string;
    isPassword: boolean;
    onChange?: (event: React.ChangeEvent<HTMLInputElement>) => any;
    onFocus?: (event: React.FocusEvent<HTMLInputElement>) => any;
    inputStyle?: React.CSSProperties;
    labelStyle?: React.CSSProperties;
    barStyle?: React.CSSProperties;
    value?: string;
    onKeyUp?: (event: React.KeyboardEvent<HTMLInputElement>) => void;
}

const TextInput = (props: IProps) => {

    const {
        label,
        isPassword,
        onChange,
        onFocus,
        inputStyle,
        labelStyle,
        barStyle,
        value,
        onKeyUp
    } = props;

    const getInputType = () => {
        return isPassword ? 'password' : 'text';
    };

    return (
        <div className='TextInput'>
            <input
                value={!!value ? value : undefined}
                type={getInputType()}
                style={inputStyle}
                onChange={onChange ? onChange : undefined}
                onFocus={onFocus ? onFocus : undefined}
                onKeyUp={onKeyUp}
            />
            {!!label && <label
                style={labelStyle}
            >
                {label}
            </label>}
            <div
                className='Bar'
                style={barStyle}
            />
        </div>
    );
};

export default TextInput;

```

Path: src/views/Common/VirtualList/VirtualList.tsx
```tsx
import React from 'react';
import {ISize} from "../../../interfaces/ISize";
import {IRect} from "../../../interfaces/IRect";
import Scrollbars from 'react-custom-scrollbars-2';
import {VirtualListUtil} from "../../../utils/VirtualListUtil";
import {IPoint} from "../../../interfaces/IPoint";
import {RectUtil} from "../../../utils/RectUtil";

interface IProps {
    size: ISize;
    childCount: number;
    childSize: ISize;
    childRender: (index: number, isScrolling: boolean, isVisible: boolean, style: React.CSSProperties) => any;
    overScanHeight?: number;
}

interface IState {
    viewportRect: IRect;
    isScrolling: boolean;
}

export class VirtualList extends React.Component<IProps, IState> {
    private gridSize: ISize;
    private contentSize: ISize;
    private childAnchors: IPoint[];
    private scrollbars: Scrollbars;

    constructor(props) {
        super(props);
        this.state = {
            viewportRect: null,
            isScrolling: false
        };
    }

    public componentDidMount(): void {
        const {size, childSize, childCount} = this.props;
        this.calculate(size, childSize, childCount);
        this.setState({
            viewportRect: {
                x: 0,
                y: 0,
                width: this.props.size.width,
                height: this.props.size.height
            }
        });
    }

    public componentWillUpdate(nextProps: Readonly<IProps>, nextState: Readonly<IState>, nextContext: any): void {
        const {size, childSize, childCount} = nextProps;
        if (this.props.size.height !== size.height || this.props.size.width !== size.width ||
            this.props.childCount !== childCount) {
            this.calculate(size, childSize, childCount);
            this.setState({
                viewportRect: {
                    x: this.scrollbars.getValues().scrollLeft,
                    y: this.scrollbars.getValues().scrollTop,
                    width: size.width,
                    height: size.height
                }
            });
        }
    }

    private calculate = (size: ISize, childSize: ISize, childCount: number) => {
        this.gridSize = VirtualListUtil.calculateGridSize(size, childSize, childCount);
        this.contentSize = VirtualListUtil.calculateContentSize(size, childSize, this.gridSize);
        this.childAnchors = VirtualListUtil.calculateAnchorPoints(size, childSize, childCount);
    };

    private getVirtualListStyle = ():React.CSSProperties => {
        return {
            position: "relative",
            width: this.props.size.width,
            height: this.props.size.height,
        }
    };

    private getVirtualListContentStyle = ():React.CSSProperties => {
        return {
            width: this.contentSize.width,
            height: this.contentSize.height,
        }
    };

    private onScrollStart = () => {
        this.setState({isScrolling: true});
    };

    private onScrollStop = () => {
        this.setState({isScrolling: false});
    };

    private onScroll = (values) => {
        this.setState({
            viewportRect: {
                x: values.scrollLeft,
                y: values.scrollTop,
                width: this.props.size.width,
                height: this.props.size.height
            }
        });
    };

    private getChildren = () => {
        const {viewportRect, isScrolling} = this.state;
        const {overScanHeight, childSize} = this.props;
        const overScan: number = !!overScanHeight ? overScanHeight : 0;

        const viewportRectWithOverScan:IRect = {
            x: viewportRect.x,
            y: viewportRect.y - overScan,
            width: viewportRect.width,
            height: viewportRect.height + 2 * overScan
        };

        return this.childAnchors.reduce((children, anchor: IPoint, index: number) => {
            const childRect = Object.assign(anchor, childSize);
            const isVisible = RectUtil.intersect(viewportRectWithOverScan, childRect);

            if (isVisible) {
                const childStyle: React.CSSProperties = {
                    position: "absolute",
                    left: anchor.x,
                    top: anchor.y,
                    width: childSize.width,
                    height: childSize.height
                };

                return children.concat(this.props.childRender(index, isScrolling, isVisible, childStyle))
            }
            else {
                return children;
            }
        }, [])
    };

    public render() {
        const displayContent = !!this.props.size && !!this.props.childSize && !!this.gridSize;

        return(
            <div
                className="VirtualList"
                style={this.getVirtualListStyle()}
            >
                <Scrollbars
                    ref={ref => this.scrollbars = ref}
                    onScrollFrame={this.onScroll}
                    onScrollStart={this.onScrollStart}
                    onScrollStop={this.onScrollStop}
                    autoHide={true}
                >
                    {displayContent && <div
                        className="VirtualListContent"
                        style={this.getVirtualListContentStyle()}
                    >
                        {this.getChildren()}
                    </div>}
                </Scrollbars>
            </div>
        )
    }
}
```

Path: src/views/Common/StyledTextField/StyledTextField.tsx
```tsx
import { TextField } from '@mui/material';
import { styled } from '@mui/system';
import { Settings } from '../../../settings/Settings';


export const StyledTextField = styled(TextField)({
    '& .MuiInputBase-root': {
        color: 'white',
    },
    '& label': {
        color: 'white',
    },
    '& .MuiInput-underline:before': {
        borderBottomColor: 'white',
    },
    '& .MuiInput-underline:hover:before': {
        borderBottomColor: 'white',
    },
    '& label.Mui-focused': {
        color: Settings.SECONDARY_COLOR,
    },
    '& .MuiInput-underline:after': {
        borderBottomColor: Settings.SECONDARY_COLOR,
    }
});
```

Path: src/views/Common/UnderlineTextButton/UnderlineTextButton.tsx
```tsx
import React from 'react'
import classNames from 'classnames'
import './UnderlineTextButton.scss'

interface IProps {
  under?: boolean
  over?: boolean
  active?: boolean
  key?: string
  label: string
  onClick?: () => any
  style?: React.CSSProperties
}

export const UnderlineTextButton = (props: IProps) => {
  const { under, over, active, key, label, onClick, style } = props;

  const getClassName = () => {
    return classNames('UnderlineTextButton', {
      under: under,
      over: over,
      active: active,
    })
  };

  return (
    <div
      className={getClassName()}
      onClick={!!onClick ? onClick : undefined}
      key={key}
      style={style}
    >
      {label}
    </div>
  )
};

```

Path: src/views/Common/ImageButton/ImageButton.tsx
```tsx
import * as React from 'react';
import {ISize} from "../../../interfaces/ISize";
import './ImageButton.scss';
import classNames from "classnames";
import {LegacyRef} from "react";

export interface ImageButtonProps extends React.HTMLProps<HTMLDivElement> {
    buttonSize:ISize,
    padding?:number;
    image:string,
    imageAlt:string,
    href?:string
    onClick?:() => any;
    style?:React.CSSProperties
    isActive?:boolean;
    isDisabled?:boolean;
    externalClassName?:string;
}

export const ImageButton = React.forwardRef((props: ImageButtonProps, ref: LegacyRef<HTMLDivElement>) => {
    const {buttonSize, padding, image, imageAlt, href, onClick, style, isActive, isDisabled, externalClassName} = props;
    const imagePadding:number = !!padding ? padding : 10;

    const onClickHandler = (event: React.MouseEvent<HTMLDivElement,¬†MouseEvent>) => {
        event.stopPropagation();
        !!onClick && onClick();
    };

    const buttonStyle:React.CSSProperties = {
        ...style,
        width: buttonSize.width,
        height: buttonSize.height
    };

    const imageStyle:React.CSSProperties = {
        maxWidth: buttonSize.width - imagePadding,
        maxHeight: buttonSize.height - imagePadding
    };

    const getClassName = () => {
        return classNames(
            "ImageButton",
            externalClassName,
            {
                "active": isActive,
                "disabled": isDisabled,
            }
        );
    };

    return(
        <div
            className={getClassName()}
            style={buttonStyle}
            onClick={onClickHandler}
            ref={ref}
        >
            {!!href && <a href={href} style={imageStyle} target="_blank" rel="noopener noreferrer">
                <img
                    draggable={false}
                    alt={imageAlt}
                    src={image}
                    style={imageStyle}
                />
            </a>}
            {!href && <img
                draggable={false}
                alt={imageAlt}
                src={image}
                style={imageStyle}
            />}
        </div>
    );
});

```

Path: src/views/EditorView/EditorView.tsx
```tsx
import React from 'react';
import './EditorView.scss';
import EditorContainer from './EditorContainer/EditorContainer';
import {PopupWindowType} from '../../data/enums/PopupWindowType';
import {AppState} from '../../store';
import {connect} from 'react-redux';
import classNames from 'classnames';
import TopNavigationBar from './TopNavigationBar/TopNavigationBar';

interface IProps {
    activePopupType: PopupWindowType;
}

const EditorView: React.FC<IProps> = ({activePopupType}) => {

    const getClassName = () => {
        return classNames(
            'EditorView',
            {
                'withPopup': !!activePopupType
            }
        );
    };

    return (
        <div
            className={getClassName()}
            draggable={false}
        >
            <TopNavigationBar/>
            <EditorContainer/>
        </div>
    );
};

const mapStateToProps = (state: AppState) => ({
    activePopupType: state.general.activePopupType
});

export default connect(
    mapStateToProps
)(EditorView);

```

Path: src/views/EditorView/LabelControlPanel/LabelControlPanel.tsx
```tsx
import React, {useState} from 'react';
import './LabelControlPanel.scss';
import {updatePreventCustomCursorStatus} from "../../../store/general/actionCreators";
import {AppState} from "../../../store";
import {connect} from "react-redux";
import {IPoint} from "../../../interfaces/IPoint";
import classNames from "classnames";
import {LabelName, LabelPoint, LabelRect} from "../../../store/labels/types";
import {ImageButton} from "../../Common/ImageButton/ImageButton";
import {LabelActions} from "../../../logic/actions/LabelActions";
import {ImageData} from "../../../store/labels/types";
import {LabelStatus} from "../../../data/enums/LabelStatus";
import {updateImageDataById} from "../../../store/labels/actionCreators";
import {findLast} from "lodash";
import {LabelsSelector} from "../../../store/selectors/LabelsSelector";

interface IProps {
    position: IPoint;
    updatePreventCustomCursorStatus: (preventCustomCursor: boolean) => any;
    activeLabelId: string;
    highlightedLabelId: string;
    labelData: LabelRect | LabelPoint;
    imageData: ImageData;
    updateImageDataById: (id: string, newImageData: ImageData) => any;
}

const LabelControlPanel: React.FC<IProps> = ({position, updatePreventCustomCursorStatus, activeLabelId, highlightedLabelId, labelData, imageData, updateImageDataById}) => {
    const [isActive, setIsActiveStatus] = useState(false);

    const onMouseEnter = () => {
        updatePreventCustomCursorStatus(true);
        setIsActiveStatus(true);
    };

    const onMouseLeave = () => {
        updatePreventCustomCursorStatus(false);
        setIsActiveStatus(false);
    };

    const onAccept = () => {
        const newImageData = {
            ...imageData,
            labelRects: imageData.labelRects.map((labelRect: LabelRect) => {
                if (labelRect.id === labelData.id) {
                    const labelName: LabelName = findLast(LabelsSelector.getLabelNames(), {name: labelRect.suggestedLabel});
                    return {
                        ...labelRect,
                        status: LabelStatus.ACCEPTED,
                        labelId: !!labelName ? labelName.id : labelRect.labelId
                    }
                } else {
                    return labelRect
                }
            }),
            labelPoints: imageData.labelPoints.map((labelPoint: LabelPoint) => {
                if (labelPoint.id === labelData.id) {
                    const labelName: LabelName = findLast(LabelsSelector.getLabelNames(), {name: labelPoint.suggestedLabel});
                    return {
                        ...labelPoint,
                        status: LabelStatus.ACCEPTED,
                        labelId: !!labelName ? labelName.id : labelPoint.labelId
                    }
                } else {
                    return labelPoint
                }
            })
        };
        updateImageDataById(imageData.id, newImageData);
        updatePreventCustomCursorStatus(false);
    };

    const onReject = () => {
        LabelActions.deleteImageLabelById(imageData.id, labelData.id);
        updatePreventCustomCursorStatus(false);
    };

    const getClassName = () => {
        return classNames(
            "LabelControlPanel", {
                "is-active": isPanelActive()
            }
        );
    };

    const isPanelActive = () => {
        return isActive || labelData.id === activeLabelId || labelData.id === highlightedLabelId
    };

    return <div
        className={getClassName()}
        style={{top: position.y, left: position.x}}
        onMouseEnter={onMouseEnter}
        onMouseLeave={onMouseLeave}
    >
        {isPanelActive() && <>
            <ImageButton
                image={"ico/plus.png"}
                imageAlt={"plus"}
                buttonSize={{width: 30, height: 30}}
                padding={15}
                onClick={onAccept}
            />
            <ImageButton
                image={"ico/trash.png"}
                imageAlt={"trash"}
                buttonSize={{width: 30, height: 30}}
                padding={15}
                onClick={onReject}
            />
            {labelData.suggestedLabel && LabelActions.labelExistsInLabelNames(labelData.suggestedLabel) ?
                <div className="SuggestedLabel">
                    {labelData.suggestedLabel}
                </div> :
                null
            }
        </>}
    </div>
};

const mapDispatchToProps = {
    updatePreventCustomCursorStatus,
    updateImageDataById
};

const mapStateToProps = (state: AppState) => ({
    activeLabelId: state.labels.activeLabelId,
    highlightedLabelId: state.labels.highlightedLabelId,
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(LabelControlPanel);
```

Path: src/views/EditorView/FeatureInProgress/FeatureInProgress.tsx
```tsx
import React from 'react';
import './FeatureInProgress.scss';

export const FeatureInProgress: React.FC = () => {
    return(
        <div
            className="FeatureInProgress"
        >
            <img
                draggable={false}
                alt={"take_off"}
                src={"ico/take-off.png"}
            />
            <p className="extraBold">new feature <br/> coming soon...</p>
        </div>
    )
};
```

Path: src/views/EditorView/EditorBottomNavigationBar/EditorBottomNavigationBar.tsx
```tsx
import React from 'react';
import './EditorBottomNavigationBar.scss';
import {ImageData} from "../../../store/labels/types";
import {AppState} from "../../../store";
import {connect} from "react-redux";
import {ImageButton} from "../../Common/ImageButton/ImageButton";
import {ISize} from "../../../interfaces/ISize";
import {ContextType} from "../../../data/enums/ContextType";
import classNames from "classnames";
import {ImageActions} from "../../../logic/actions/ImageActions";

interface IProps {
    size: ISize;
    imageData: ImageData;
    totalImageCount: number;
    activeImageIndex: number;
    activeContext: ContextType;
}

const EditorBottomNavigationBar: React.FC<IProps> = ({size, imageData, totalImageCount, activeImageIndex, activeContext}) => {
    const minWidth:number = 400;

    const getImageCounter = () => {
        return (activeImageIndex + 1) + " / " + totalImageCount;
    };

    const getClassName = () => {
        return classNames(
            "EditorBottomNavigationBar",
            {
                "with-context": activeContext === ContextType.EDITOR
            }
        );
    };

    return (
        <div className={getClassName()}>
            <ImageButton
                image={"ico/left.png"}
                imageAlt={"previous"}
                buttonSize={{width: 25, height: 25}}
                onClick={() => ImageActions.getPreviousImage()}
                isDisabled={activeImageIndex === 0}
                externalClassName={"left"}
            />
            {size.width > minWidth ?
                <div className="CurrentImageName"> {imageData.fileData.name} </div> :
                <div className="CurrentImageCount"> {getImageCounter()} </div>
            }
            <ImageButton
                image={"ico/right.png"}
                imageAlt={"next"}
                buttonSize={{width: 25, height: 25}}
                onClick={() => ImageActions.getNextImage()}
                isDisabled={activeImageIndex === totalImageCount - 1}
                externalClassName={"right"}
            />
        </div>
    );
};

const mapDispatchToProps = {};

const mapStateToProps = (state: AppState) => ({
    activeImageIndex: state.labels.activeImageIndex,
    activeContext: state.general.activeContext
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(EditorBottomNavigationBar);

```

Path: src/views/EditorView/VerticalEditorButton/VerticalEditorButton.tsx
```tsx
import * as React from "react";
import classNames from "classnames";
import './VerticalEditorButton.scss';

interface IProps {
    key?:string;
    label:string;
    onClick?:() => any;
    style?:React.CSSProperties;
    isActive?:boolean;
    isDisabled?:boolean;
    image?:string,
    imageAlt?:string,
}

export const VerticalEditorButton = (props:IProps) => {

    const { key, label, onClick, style, isActive, isDisabled, image, imageAlt} = props;

    const getClassName = () => {
        return classNames(
            "VerticalEditorButton",
            {
                "active": isActive,
                "disabled": isDisabled
            }
        );
    };

    return(
        <div
            className={getClassName()}
            onClick={!!onClick ? onClick : undefined}
            key={key}
            style={style}
        >
            {image && <img
                draggable={false}
                alt={imageAlt}
                src={image}
            />}
            {label}
        </div>
    )
};
```

Path: src/views/EditorView/StateBar/StateBar.tsx
```tsx
import React from 'react';
import './StateBar.scss';
import {ImageData} from "../../../store/labels/types";
import {AppState} from "../../../store";
import {connect} from "react-redux";
import {LabelType} from "../../../data/enums/LabelType";

interface IProps {
    imagesData: ImageData[];
    activeLabelType: LabelType;
}

const StateBar: React.FC<IProps> = ({imagesData, activeLabelType}) => {

    const pointLabeledImages = imagesData.reduce((currentCount: number, currentImage: ImageData) => {
        return currentCount + (currentImage.labelPoints.length > 0 ? 1 : 0);
    }, 0);

    const rectLabeledImages = imagesData.reduce((currentCount: number, currentImage: ImageData) => {
        return currentCount + (currentImage.labelRects.length > 0 ? 1 : 0);
    }, 0);

    const polygonLabeledImages = imagesData.reduce((currentCount: number, currentImage: ImageData) => {
        return currentCount + (currentImage.labelPolygons.length > 0 ? 1 : 0);
    }, 0);

    const lineLabeledImages = imagesData.reduce((currentCount: number, currentImage: ImageData) => {
        return currentCount + (currentImage.labelLines.length > 0 ? 1 : 0);
    }, 0);

    const tagLabeledImages = imagesData.reduce((currentCount: number, currentImage: ImageData) => {
        return currentCount + (currentImage.labelNameIds.length !== 0 ? 1 : 0);
    }, 0);

    const getProgress = () => {
        switch (activeLabelType) {
            case LabelType.POINT:
                return (100 * pointLabeledImages) / imagesData.length;
            case LabelType.RECT:
                return (100 * rectLabeledImages) / imagesData.length;
            case LabelType.POLYGON:
                return (100 * polygonLabeledImages) / imagesData.length;
            case LabelType.LINE:
                return (100 * lineLabeledImages) / imagesData.length;
            case LabelType.IMAGE_RECOGNITION:
                return (100 * tagLabeledImages) / imagesData.length;
            default:
                return 0;
        }
    };

    return (
        <div className="StateBar">
            <div
                style={{width: getProgress() + "%"}}
                className="done"
            />
        </div>
    );
};

const mapDispatchToProps = {};

const mapStateToProps = (state: AppState) => ({
    imagesData: state.labels.imagesData,
    activeLabelType: state.labels.activeLabelType
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(StateBar);
```

Path: src/views/EditorView/EditorContainer/EditorContainer.tsx
```tsx
import React, {useState} from 'react';
import {connect} from 'react-redux';
import {Direction} from '../../../data/enums/Direction';
import {ISize} from '../../../interfaces/ISize';
import {Settings} from '../../../settings/Settings';
import {AppState} from '../../../store';
import {ImageData} from '../../../store/labels/types';
import ImagesList from '../SideNavigationBar/ImagesList/ImagesList';
import LabelsToolkit from '../SideNavigationBar/LabelsToolkit/LabelsToolkit';
import {SideNavigationBar} from '../SideNavigationBar/SideNavigationBar';
import {VerticalEditorButton} from '../VerticalEditorButton/VerticalEditorButton';
import './EditorContainer.scss';
import Editor from '../Editor/Editor';
import {ContextManager} from '../../../logic/context/ContextManager';
import {ContextType} from '../../../data/enums/ContextType';
import EditorBottomNavigationBar from '../EditorBottomNavigationBar/EditorBottomNavigationBar';
import EditorTopNavigationBar from '../EditorTopNavigationBar/EditorTopNavigationBar';
import {ProjectType} from '../../../data/enums/ProjectType';

interface IProps {
    windowSize: ISize;
    activeImageIndex: number;
    imagesData: ImageData[];
    activeContext: ContextType;
    projectType: ProjectType;
}

const EditorContainer: React.FC<IProps> = (
    {
        windowSize,
        activeImageIndex,
        imagesData,
        activeContext,
        projectType
    }) => {
    const [leftTabStatus, setLeftTabStatus] = useState(true);
    const [rightTabStatus, setRightTabStatus] = useState(true);

    const calculateEditorSize = (): ISize => {
        if (windowSize) {
            const leftTabWidth = leftTabStatus ? Settings.SIDE_NAVIGATION_BAR_WIDTH_OPEN_PX : Settings.SIDE_NAVIGATION_BAR_WIDTH_CLOSED_PX;
            const rightTabWidth = rightTabStatus ? Settings.SIDE_NAVIGATION_BAR_WIDTH_OPEN_PX : Settings.SIDE_NAVIGATION_BAR_WIDTH_CLOSED_PX;
            return {
                width: windowSize.width - leftTabWidth - rightTabWidth,
                height: windowSize.height - Settings.TOP_NAVIGATION_BAR_HEIGHT_PX
                    - Settings.EDITOR_BOTTOM_NAVIGATION_BAR_HEIGHT_PX - Settings.EDITOR_TOP_NAVIGATION_BAR_HEIGHT_PX,
            }
        }
        else
            return null;
    };

    const leftSideBarButtonOnClick = () => {
        if (!leftTabStatus)
            ContextManager.switchCtx(ContextType.LEFT_NAVBAR);
        else if (leftTabStatus && activeContext === ContextType.LEFT_NAVBAR)
            ContextManager.restoreCtx();

        setLeftTabStatus(!leftTabStatus);
    };

    const leftSideBarCompanionRender = () => {
        return <>
            <VerticalEditorButton
                label='Images'
                image={'/ico/camera.png'}
                imageAlt={'images'}
                onClick={leftSideBarButtonOnClick}
                isActive={leftTabStatus}
            />
        </>
    };

    const leftSideBarRender = () => {
        return <ImagesList/>
    };

    const rightSideBarButtonOnClick = () => {
        if (!rightTabStatus)
            ContextManager.switchCtx(ContextType.RIGHT_NAVBAR);
        else if (rightTabStatus && activeContext === ContextType.RIGHT_NAVBAR)
            ContextManager.restoreCtx();

        setRightTabStatus(!rightTabStatus);
    };

    const rightSideBarCompanionRender = () => {
        return <>
            <VerticalEditorButton
                label='Labels'
                image={'/ico/tags.png'}
                imageAlt={'labels'}
                onClick={rightSideBarButtonOnClick}
                isActive={rightTabStatus}
            />
        </>
    };

    const rightSideBarRender = () => {
        return <LabelsToolkit/>
    };

    return (
        <div className='EditorContainer'>
            <SideNavigationBar
                direction={Direction.LEFT}
                isOpen={leftTabStatus}
                isWithContext={activeContext === ContextType.LEFT_NAVBAR}
                renderCompanion={leftSideBarCompanionRender}
                renderContent={leftSideBarRender}
                key='left-side-navigation-bar'
            />
            <div className='EditorWrapper'
                onMouseDown={() => ContextManager.switchCtx(ContextType.EDITOR)}
                 key='editor-wrapper'
            >
                {projectType === ProjectType.OBJECT_DETECTION && <EditorTopNavigationBar
                    key='editor-top-navigation-bar'
                />}
                <Editor
                    size={calculateEditorSize()}
                    imageData={imagesData[activeImageIndex]}
                    key='editor'
                />
                <EditorBottomNavigationBar
                    imageData={imagesData[activeImageIndex]}
                    size={calculateEditorSize()}
                    totalImageCount={imagesData.length}
                    key='editor-bottom-navigation-bar'
                />
            </div>
            <SideNavigationBar
                direction={Direction.RIGHT}
                isOpen={rightTabStatus}
                isWithContext={activeContext === ContextType.RIGHT_NAVBAR}
                renderCompanion={rightSideBarCompanionRender}
                renderContent={rightSideBarRender}
                key='right-side-navigation-bar'
            />
        </div>
    );
};

const mapStateToProps = (state: AppState) => ({
    windowSize: state.general.windowSize,
    activeImageIndex: state.labels.activeImageIndex,
    imagesData: state.labels.imagesData,
    activeContext: state.general.activeContext,
    projectType: state.general.projectData.type
});

export default connect(
    mapStateToProps
)(EditorContainer);
```

Path: src/views/EditorView/SideNavigationBar/SideNavigationBar.tsx
```tsx
import React from 'react';
import classNames from 'classnames';
import './SideNavigationBar.scss';
import {Direction} from "../../../data/enums/Direction";

interface IProps {
    direction: Direction
    isOpen: boolean;
    isWithContext?: boolean;
    renderCompanion?: () => any;
    renderContent?: () => any;
}

export const SideNavigationBar: React.FC<IProps> = (props) => {
    const {direction, isOpen, isWithContext, renderContent, renderCompanion} = props;

    const getClassName = () => {
        return classNames(
            "SideNavigationBar",
            {
                "left": direction === Direction.LEFT,
                "right": direction === Direction.RIGHT,
                "with-context": isWithContext,
                "closed": !isOpen
            }
        );
    };

    return (
        <div className={getClassName()}>
            <div className="CompanionBar">
                {renderCompanion && renderCompanion()}
            </div>
            {isOpen && <div className="NavigationBarContentWrapper">
                {renderContent && renderContent()}
            </div>}
        </div>
    );
};
```

Path: src/views/EditorView/SideNavigationBar/ImagesList/ImagesList.tsx
```tsx
import React from 'react';
import {connect} from "react-redux";
import {LabelType} from "../../../../data/enums/LabelType";
import {ISize} from "../../../../interfaces/ISize";
import {AppState} from "../../../../store";
import {ImageData, LabelPoint, LabelRect} from "../../../../store/labels/types";
import {VirtualList} from "../../../Common/VirtualList/VirtualList";
import ImagePreview from "../ImagePreview/ImagePreview";
import './ImagesList.scss';
import {ContextManager} from "../../../../logic/context/ContextManager";
import {ContextType} from "../../../../data/enums/ContextType";
import {ImageActions} from "../../../../logic/actions/ImageActions";
import {EventType} from "../../../../data/enums/EventType";
import {LabelStatus} from "../../../../data/enums/LabelStatus";

interface IProps {
    activeImageIndex: number;
    imagesData: ImageData[];
    activeLabelType: LabelType;
}

interface IState {
    size: ISize;
}

class ImagesList extends React.Component<IProps, IState> {
    private imagesListRef: HTMLDivElement;

    constructor(props) {
        super(props);

        this.state = {
            size: null,
        }
    }

    public componentDidMount(): void {
        this.updateListSize();
        window.addEventListener(EventType.RESIZE, this.updateListSize);
    }

    public componentWillUnmount(): void {
        window.removeEventListener(EventType.RESIZE, this.updateListSize);
    }

    private updateListSize = () => {
        if (!this.imagesListRef)
            return;

        const listBoundingBox = this.imagesListRef.getBoundingClientRect();
        this.setState({
            size: {
                width: listBoundingBox.width,
                height: listBoundingBox.height
            }
        })
    };

    private isImageChecked = (index:number): boolean => {
        const imageData = this.props.imagesData[index]
        switch (this.props.activeLabelType) {
            case LabelType.LINE:
                return imageData.labelLines.length > 0
            case LabelType.IMAGE_RECOGNITION:
                return imageData.labelNameIds.length > 0
            case LabelType.POINT:
                return imageData.labelPoints
                    .filter((labelPoint: LabelPoint) => labelPoint.status === LabelStatus.ACCEPTED)
                    .length > 0
            case LabelType.POLYGON:
                return imageData.labelPolygons.length > 0
            case LabelType.RECT:
                return imageData.labelRects
                    .filter((labelRect: LabelRect) => labelRect.status === LabelStatus.ACCEPTED)
                    .length > 0
        }
    };

    private onClickHandler = (index: number) => {
        ImageActions.getImageByIndex(index)
    };

    private renderImagePreview = (index: number, isScrolling: boolean, isVisible: boolean, style: React.CSSProperties) => {
        return <ImagePreview
            key={index}
            style={style}
            size={{width: 150, height: 150}}
            isScrolling={isScrolling}
            isChecked={this.isImageChecked(index)}
            imageData={this.props.imagesData[index]}
            onClick={() => this.onClickHandler(index)}
            isSelected={this.props.activeImageIndex === index}
        />
    };

    public render() {
        const { size } = this.state;
        return(
            <div
                className="ImagesList"
                ref={ref => this.imagesListRef = ref}
                onClick={() => ContextManager.switchCtx(ContextType.LEFT_NAVBAR)}
            >
                {!!size && <VirtualList
                    size={size}
                    childSize={{width: 150, height: 150}}
                    childCount={this.props.imagesData.length}
                    childRender={this.renderImagePreview}
                    overScanHeight={200}
                />}
            </div>
        )
    }
}

const mapDispatchToProps = {};

const mapStateToProps = (state: AppState) => ({
    activeImageIndex: state.labels.activeImageIndex,
    imagesData: state.labels.imagesData,
    activeLabelType: state.labels.activeLabelType
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(ImagesList);
```

Path: src/views/EditorView/SideNavigationBar/PointLabelsList/PointLabelsList.tsx
```tsx
import React from 'react';
import {ISize} from '../../../../interfaces/ISize';
import Scrollbars from 'react-custom-scrollbars-2';
import {ImageData, LabelName, LabelPoint} from '../../../../store/labels/types';
import './PointLabelsList.scss';
import {
    updateActiveLabelId,
    updateActiveLabelNameId,
    updateImageDataById
} from '../../../../store/labels/actionCreators';
import {AppState} from '../../../../store';
import {connect} from 'react-redux';
import LabelInputField from '../LabelInputField/LabelInputField';
import EmptyLabelList from '../EmptyLabelList/EmptyLabelList';
import {LabelActions} from '../../../../logic/actions/LabelActions';
import {findLast} from 'lodash';
import {LabelStatus} from '../../../../data/enums/LabelStatus';

interface IProps {
    size: ISize;
    imageData: ImageData;
    updateImageDataByIdAction: (id: string, newImageData: ImageData) => any;
    activeLabelId: string;
    highlightedLabelId: string;
    updateActiveLabelNameIdAction: (activeLabelId: string) => any;
    labelNames: LabelName[];
    updateActiveLabelIdAction: (activeLabelId: string) => any;
}

const PointLabelsList: React.FC<IProps> = (
    {
        size,
        imageData,
        updateImageDataByIdAction,
        labelNames,
        updateActiveLabelNameIdAction,
        activeLabelId,
        highlightedLabelId,
        updateActiveLabelIdAction
    }
) => {
    const labelInputFieldHeight = 40;
    const listStyle: React.CSSProperties = {
        width: size.width,
        height: size.height
    };
    const listStyleContent: React.CSSProperties = {
        width: size.width,
        height: imageData.labelPoints.length * labelInputFieldHeight
    };

    const deletePointLabelById = (labelPointId: string) => {
        LabelActions.deletePointLabelById(imageData.id, labelPointId);
    };

    const togglePointLabelVisibilityById = (labelPointId: string) => {
        LabelActions.toggleLabelVisibilityById(imageData.id, labelPointId);
    };

    const updatePointLabel = (labelPointId: string, labelNameId: string) => {
        const newImageData = {
            ...imageData,
            labelPoints: imageData.labelPoints.map((labelPoint: LabelPoint) => {
                if (labelPoint.id === labelPointId) {
                    return {
                        ...labelPoint,
                        labelId: labelNameId
                    }
                }
                return labelPoint
            })
        };
        updateImageDataByIdAction(imageData.id, newImageData);
        updateActiveLabelNameIdAction(labelNameId);
    };

    const onClickHandler = () => {
        updateActiveLabelIdAction(null);
    };

    const getChildren = () => {
        return imageData.labelPoints
            .filter((labelPoint: LabelPoint) => labelPoint.status === LabelStatus.ACCEPTED)
            .map((labelPoint: LabelPoint) => {
            return <LabelInputField
                size={{
                    width: size.width,
                    height: labelInputFieldHeight
                }}
                isActive={labelPoint.id === activeLabelId}
                isHighlighted={labelPoint.id === highlightedLabelId}
                isVisible={labelPoint.isVisible}
                id={labelPoint.id}
                key={labelPoint.id}
                onDelete={deletePointLabelById}
                value={labelPoint.labelId !== null ? findLast(labelNames, {id: labelPoint.labelId}) : null}
                options={labelNames}
                onSelectLabel={updatePointLabel}
                toggleLabelVisibility={togglePointLabelVisibilityById}
            />
        });
    };

    return (
        <div
            className='PointLabelsList'
            style={listStyle}
            onClickCapture={onClickHandler}
        >
            {imageData.labelPoints.filter((labelPoint: LabelPoint) => labelPoint.status === LabelStatus.ACCEPTED).length === 0 ?
                <EmptyLabelList
                    labelBefore={'mark your first point'}
                    labelAfter={'no labels created for this image yet'}
                /> :
                <Scrollbars>
                    <div
                        className='PointLabelsListContent'
                        style={listStyleContent}
                    >
                        {getChildren()}
                    </div>
                </Scrollbars>
            }
        </div>
    );
};

const mapDispatchToProps = {
    updateImageDataByIdAction: updateImageDataById,
    updateActiveLabelNameIdAction: updateActiveLabelNameId,
    updateActiveLabelIdAction: updateActiveLabelId
};

const mapStateToProps = (state: AppState) => ({
    activeLabelId: state.labels.activeLabelId,
    highlightedLabelId: state.labels.highlightedLabelId,
    labelNames : state.labels.labels
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(PointLabelsList);

```

Path: src/views/EditorView/SideNavigationBar/LabelInputField/LabelInputField.tsx
```tsx
import React from 'react';
import {ISize} from '../../../../interfaces/ISize';
import './LabelInputField.scss';
import classNames from 'classnames';
import {ImageButton} from '../../../Common/ImageButton/ImageButton';
import {IRect} from '../../../../interfaces/IRect';
import {IPoint} from '../../../../interfaces/IPoint';
import {RectUtil} from '../../../../utils/RectUtil';
import {AppState} from '../../../../store';
import {connect} from 'react-redux';
import {updateActiveLabelId, updateHighlightedLabelId} from '../../../../store/labels/actionCreators';
import Scrollbars from 'react-custom-scrollbars-2';
import {EventType} from '../../../../data/enums/EventType';
import {LabelName} from '../../../../store/labels/types';
import {LabelsSelector} from '../../../../store/selectors/LabelsSelector';
import {PopupWindowType} from '../../../../data/enums/PopupWindowType';
import {updateActivePopupType} from '../../../../store/general/actionCreators';
import {truncate} from 'lodash';
import { Settings } from '../../../../settings/Settings';

interface IProps {
    size: ISize;
    isActive: boolean;
    isHighlighted: boolean;
    isVisible?: boolean;
    id: string;
    value?: LabelName;
    options: LabelName[];
    onDelete: (id: string) => any;
    onSelectLabel: (labelRectId: string, labelNameId: string) => any;
    updateHighlightedLabelId: (highlightedLabelId: string) => any;
    updateActiveLabelId: (highlightedLabelId: string) => any;
    updateActivePopupType: (activePopupType: PopupWindowType) => any;
    toggleLabelVisibility?: (labelNameId: string) => any;
}

interface IState {
    animate: boolean;
    isOpen: boolean;
}

class LabelInputField extends React.Component<IProps, IState> {
    private dropdownOptionHeight: number = 30;
    private dropdownOptionCount: number = 6;
    private dropdownMargin: number = 4;
    private dropdownLabel: HTMLDivElement;
    private dropdown: HTMLDivElement;

    public constructor(props) {
        super(props);
        this.state = {
            animate: false,
            isOpen: false
        }
    }

    public componentDidMount(): void {
        requestAnimationFrame(() => {
            this.setState({ animate: true });
        });
    }

    private getClassName() {
        return classNames(
            'LabelInputField',
            {
                'loaded': this.state.animate,
                'active': this.props.isActive,
                'highlighted': this.props.isHighlighted
            }
        );
    }

    private openDropdown = () => {
        if (LabelsSelector.getLabelNames().length === 0) {
            this.props.updateActivePopupType(PopupWindowType.UPDATE_LABEL);
        } else {
            this.setState({isOpen: true});
            window.addEventListener(EventType.MOUSE_DOWN, this.closeDropdown);
        }
    };

    private closeDropdown = (event: MouseEvent) => {
        const mousePosition: IPoint = {x: event.clientX, y: event.clientY};
        const clientRect = this.dropdown.getBoundingClientRect();
        const dropDownRect: IRect = {
            x: clientRect.left,
            y: clientRect.top,
            width: clientRect.width,
            height: clientRect.height
        };

        if (!RectUtil.isPointInside(dropDownRect, mousePosition)) {
            this.setState({isOpen: false});
            window.removeEventListener(EventType.MOUSE_DOWN, this.closeDropdown)
        }
    };

    private getDropdownStyle = ():React.CSSProperties => {
        const clientRect = this.dropdownLabel.getBoundingClientRect();
        const height: number = Math.min(this.props.options.length, this.dropdownOptionCount) * this.dropdownOptionHeight;
        const style = {
            width: clientRect.width,
            height,
            left: clientRect.left
        };

        if (window.innerHeight * 2/3 < clientRect.top)
            return Object.assign(style, {top: clientRect.top - this.dropdownMargin - height});
        else
            return Object.assign(style, {top: clientRect.bottom + this.dropdownMargin});
    };

    private getDropdownOptions = () => {
        const wrapOnClick = (id: string): (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void => {
            return (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {
                this.setState({isOpen: false});
                window.removeEventListener(EventType.MOUSE_DOWN, this.closeDropdown);
                this.props.onSelectLabel(this.props.id, id);
                this.props.updateHighlightedLabelId(null);
                this.props.updateActiveLabelId(this.props.id);
                event.stopPropagation();
            };
        }

        return this.props.options.map((option: LabelName) => {
            return <div
                className='DropdownOption'
                key={option.id}
                style={{height: this.dropdownOptionHeight}}
                onClick={wrapOnClick(option.id)}
            >
                {truncate(option.name, {length: Settings.MAX_DROPDOWN_OPTION_LENGTH})}
            </div>
        })
    };

    private mouseEnterHandler = () => {
        this.props.updateHighlightedLabelId(this.props.id);
    };

    private mouseLeaveHandler =() => {
        this.props.updateHighlightedLabelId(null);
    };

    private onClickHandler = () => {
        this.props.updateActiveLabelId(this.props.id);
    };

    private getToggleVisibilityButton = (id: string) => {
        if (this.props.toggleLabelVisibility === undefined) {
            return null
        }
        return(
            <ImageButton
                externalClassName={'icon'}
                image={this.props.isVisible ? 'ico/eye.png' : 'ico/hide.png'}
                imageAlt={'label is hidden'}
                buttonSize={{width: 28, height: 28}}
                onClick={() => this.props.toggleLabelVisibility(id)}
            />
        )
    }

    public render() {
        const {size, id, value, onDelete} = this.props;
        return(
            <div
                className={this.getClassName()}
                style={{
                    width: size.width,
                    height: size.height,
                }}
                key={id}
                onMouseEnter={this.mouseEnterHandler}
                onMouseLeave={this.mouseLeaveHandler}
                onClick={this.onClickHandler}
            >
                <div
                    className='LabelInputFieldWrapper'
                    style={{
                        width: size.width,
                        height: size.height,
                    }}
                >
                    <div
                        className='Marker'
                        style={value ? {backgroundColor: value.color} : {}}
                    />
                    <div className='Content'>
                        <div className='ContentWrapper'>
                            <div className='DropdownLabel'
                                 ref={ref => this.dropdownLabel = ref}
                                 onClick={this.openDropdown}
                            >
                                {value ? truncate(value.name, {length: Settings.MAX_DROPDOWN_OPTION_LENGTH}) : 'Select label'}
                            </div>
                            {this.state.isOpen && <div
                                className='Dropdown'
                                style={this.getDropdownStyle()}
                                ref={ref => this.dropdown = ref}
                            >
                                <Scrollbars
                                    renderTrackHorizontal={props => <div {...props} className='track-horizontal'/>}
                                >
                                    <div>
                                        {this.getDropdownOptions()}
                                    </div>
                                </Scrollbars>

                            </div>}
                        </div>
                        <div className='ContentWrapper'>
                            {this.getToggleVisibilityButton(id)}
                            <ImageButton
                                externalClassName={'icon'}
                                image={'ico/trash.png'}
                                imageAlt={'remove label'}
                                buttonSize={{width: 28, height: 28}}
                                onClick={() => onDelete(id)}
                            />
                        </div>
                    </div>
                </div>
            </div>
        )
    }
}

const mapDispatchToProps = {
    updateHighlightedLabelId,
    updateActiveLabelId,
    updateActivePopupType
};

const mapStateToProps = (state: AppState) => ({});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(LabelInputField);

```

Path: src/views/EditorView/SideNavigationBar/LineLabelsList/LineLabelsList.tsx
```tsx
import React from 'react';
import './LineLabelsList.scss';
import {ISize} from '../../../../interfaces/ISize';
import {ImageData, LabelLine, LabelName} from '../../../../store/labels/types';
import {LabelActions} from '../../../../logic/actions/LabelActions';
import LabelInputField from '../LabelInputField/LabelInputField';
import {findLast} from 'lodash';
import EmptyLabelList from '../EmptyLabelList/EmptyLabelList';
import Scrollbars from 'react-custom-scrollbars-2';
import {
    updateActiveLabelId,
    updateActiveLabelNameId,
    updateImageDataById
} from '../../../../store/labels/actionCreators';
import {AppState} from '../../../../store';
import {connect} from 'react-redux';

interface IProps {
    size: ISize;
    imageData: ImageData;
    updateImageDataByIdAction: (id: string, newImageData: ImageData) => any;
    activeLabelId: string;
    highlightedLabelId: string;
    updateActiveLabelNameIdAction: (activeLabelId: string) => any;
    labelNames: LabelName[];
    updateActiveLabelIdAction: (activeLabelId: string) => any;
}

const LineLabelsList: React.FC<IProps> = (
    {
        size,
        imageData,
        updateImageDataByIdAction,
        labelNames,
        updateActiveLabelNameIdAction,
        activeLabelId,
        highlightedLabelId,
        updateActiveLabelIdAction
    }
) => {
    const labelInputFieldHeight = 40;
    const listStyle: React.CSSProperties = {
        width: size.width,
        height: size.height
    };
    const listStyleContent: React.CSSProperties = {
        width: size.width,
        height: imageData.labelLines.length * labelInputFieldHeight
    };

    const deleteLineLabelById = (labelLineId: string) => {
        LabelActions.deleteLineLabelById(imageData.id, labelLineId);
    };

    const toggleLineLabelVisibilityById = (labelLineId: string) => {
        LabelActions.toggleLabelVisibilityById(imageData.id, labelLineId);
    };

    const updateLineLabel = (labelLineId: string, labelNameId: string) => {
        const newImageData = {
            ...imageData,
            labelLines: imageData.labelLines.map((labelLine: LabelLine) => {
                if (labelLine.id === labelLineId) {
                    return {
                        ...labelLine,
                        labelId: labelNameId
                    }
                }
                return labelLine
            })
        };
        updateImageDataByIdAction(imageData.id, newImageData);
        updateActiveLabelNameIdAction(labelNameId);
    };

    const onClickHandler = () => {
        updateActiveLabelIdAction(null);
    };

    const getChildren = () => {
        return imageData.labelLines
            .map((labelLine: LabelLine) => {
                return <LabelInputField
                    size={{
                        width: size.width,
                        height: labelInputFieldHeight
                    }}
                    isActive={labelLine.id === activeLabelId}
                    isHighlighted={labelLine.id === highlightedLabelId}
                    isVisible={labelLine.isVisible}
                    id={labelLine.id}
                    key={labelLine.id}
                    onDelete={deleteLineLabelById}
                    value={labelLine.labelId !== null ? findLast(labelNames, {id: labelLine.labelId}) : null}
                    options={labelNames}
                    onSelectLabel={updateLineLabel}
                    toggleLabelVisibility={toggleLineLabelVisibilityById}
                />
            });
    };

    return (
        <div
            className='LineLabelsList'
            style={listStyle}
            onClickCapture={onClickHandler}
        >
            {imageData.labelLines.length === 0 ?
                <EmptyLabelList
                    labelBefore={'draw your first line'}
                    labelAfter={'no labels created for this image yet'}
                /> :
                <Scrollbars>
                    <div
                        className='LineLabelsListContent'
                        style={listStyleContent}
                    >
                        {getChildren()}
                    </div>
                </Scrollbars>
            }
        </div>
    );
};

const mapDispatchToProps = {
    updateImageDataByIdAction: updateImageDataById,
    updateActiveLabelNameIdAction: updateActiveLabelNameId,
    updateActiveLabelIdAction: updateActiveLabelId
};

const mapStateToProps = (state: AppState) => ({
    activeLabelId: state.labels.activeLabelId,
    highlightedLabelId: state.labels.highlightedLabelId,
    labelNames : state.labels.labels
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(LineLabelsList);

```

Path: src/views/EditorView/SideNavigationBar/ImagePreview/ImagePreview.tsx
```tsx
import classNames from "classnames";
import React from 'react';
import { connect } from "react-redux";
import { ClipLoader } from "react-spinners";
import { ImageLoadManager } from "../../../../logic/imageRepository/ImageLoadManager";
import { IRect } from "../../../../interfaces/IRect";
import { ISize } from "../../../../interfaces/ISize";
import { ImageRepository } from "../../../../logic/imageRepository/ImageRepository";
import { AppState } from "../../../../store";
import { updateImageDataById } from "../../../../store/labels/actionCreators";
import { ImageData } from "../../../../store/labels/types";
import { FileUtil } from "../../../../utils/FileUtil";
import { RectUtil } from "../../../../utils/RectUtil";
import './ImagePreview.scss';
import { CSSHelper } from "../../../../logic/helpers/CSSHelper";

interface IProps {
    imageData: ImageData;
    style: React.CSSProperties;
    size: ISize;
    isScrolling?: boolean;
    isChecked?: boolean;
    onClick?: () => any;
    isSelected?: boolean;
    updateImageDataById: (id: string, newImageData: ImageData) => any;
}

interface IState {
    image: HTMLImageElement;
}

class ImagePreview extends React.Component<IProps, IState> {
    private isLoading: boolean = false;

    constructor(props) {
        super(props);

        this.state = {
            image: null,
        }
    }

    public componentDidMount(): void {
        ImageLoadManager.addAndRun(this.loadImage(this.props.imageData, this.props.isScrolling));
    }

    public componentWillUpdate(nextProps: Readonly<IProps>, nextState: Readonly<IState>, nextContext: any): void {
        if (this.props.imageData.id !== nextProps.imageData.id) {
            if (nextProps.imageData.loadStatus) {
                ImageLoadManager.addAndRun(this.loadImage(nextProps.imageData, nextProps.isScrolling));
            }
            else {
                this.setState({ image: null });
            }
        }

        if (this.props.isScrolling && !nextProps.isScrolling) {
            ImageLoadManager.addAndRun(this.loadImage(nextProps.imageData, false));
        }
    }

    shouldComponentUpdate(nextProps: Readonly<IProps>, nextState: Readonly<IState>, nextContext: any): boolean {
        return (
            this.props.imageData.id !== nextProps.imageData.id ||
            this.state.image !== nextState.image ||
            this.props.isSelected !== nextProps.isSelected ||
            this.props.isChecked !== nextProps.isChecked
        )
    }

    private loadImage = async (imageData: ImageData, isScrolling: boolean) => {
        if (imageData.loadStatus) {
            const image = ImageRepository.getById(imageData.id);
            if (this.state.image !== image) {
                this.setState({ image });
            }
        }
        else if (!isScrolling || !this.isLoading) {
            this.isLoading = true;
            const saveLoadedImagePartial = (image: HTMLImageElement) => this.saveLoadedImage(image, imageData);
            FileUtil.loadImage(imageData.fileData)
                .then((image: HTMLImageElement) => saveLoadedImagePartial(image))
                .catch((error) => this.handleLoadImageError())
        }
    };

    private saveLoadedImage = (image: HTMLImageElement, imageData: ImageData) => {
        imageData.loadStatus = true;
        this.props.updateImageDataById(imageData.id, imageData);
        ImageRepository.storeImage(imageData.id, image);
        if (imageData.id === this.props.imageData.id) {
            this.setState({ image });
            this.isLoading = false;
        }
    };

    private getStyle = () => {
        const { size } = this.props;

        const containerRect: IRect = {
            x: 0.15 * size.width,
            y: 0.15 * size.height,
            width: 0.7 * size.width,
            height: 0.7 * size.height
        };

        const imageRect: IRect = {
            x: 0,
            y: 0,
            width: this.state.image.width,
            height: this.state.image.height
        };

        const imageRatio = RectUtil.getRatio(imageRect);
        const imagePosition: IRect = RectUtil.fitInsideRectWithRatio(containerRect, imageRatio);

        return {
            width: imagePosition.width,
            height: imagePosition.height,
            left: imagePosition.x,
            top: imagePosition.y
        }
    };

    private handleLoadImageError = () => { };

    private getClassName = () => {
        return classNames(
            "ImagePreview",
            {
                "selected": this.props.isSelected,
            }
        );
    };

    public render() {
        const {
            isChecked,
            style,
            onClick
        } = this.props;

        return (
            <div
                className={this.getClassName()}
                style={style}
                onClick={onClick ? onClick : undefined}
            >
                {(!!this.state.image) ?
                    [
                        <div
                            className="Foreground"
                            key={"Foreground"}
                            style={this.getStyle()}
                        >
                            <img
                                className="Image"
                                draggable={false}
                                src={this.state.image.src}
                                alt={this.state.image.alt}
                                style={{ ...this.getStyle(), left: 0, top: 0 }}
                            />
                            {isChecked && <img
                                className="CheckBox"
                                draggable={false}
                                src={"ico/ok.png"}
                                alt={"checkbox"}
                            />}
                        </div>,
                        <div
                            className="Background"
                            key={"Background"}
                            style={this.getStyle()}
                        />
                    ] :
                    <ClipLoader
                        size={30}
                        color={CSSHelper.getLeadingColor()}
                        loading={true}
                    />}
            </div>)
    }
}

const mapDispatchToProps = {
    updateImageDataById
};

const mapStateToProps = (state: AppState) => ({});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(ImagePreview);
```

Path: src/views/EditorView/SideNavigationBar/LabelsToolkit/LabelsToolkit.tsx
```tsx
import React from "react";
import './LabelsToolkit.scss';
import {ImageData} from "../../../../store/labels/types";
import {updateActiveLabelId, updateActiveLabelType, updateImageDataById} from "../../../../store/labels/actionCreators";
import {AppState} from "../../../../store";
import {connect} from "react-redux";
import {LabelType} from "../../../../data/enums/LabelType";
import {ProjectType} from "../../../../data/enums/ProjectType";
import {ISize} from "../../../../interfaces/ISize";
import classNames from "classnames";
import {find} from "lodash";
import {ILabelToolkit, LabelToolkitData} from "../../../../data/info/LabelToolkitData";
import {Settings} from "../../../../settings/Settings";
import RectLabelsList from "../RectLabelsList/RectLabelsList";
import PointLabelsList from "../PointLabelsList/PointLabelsList";
import PolygonLabelsList from "../PolygonLabelsList/PolygonLabelsList";
import {ContextManager} from "../../../../logic/context/ContextManager";
import {ContextType} from "../../../../data/enums/ContextType";
import {EventType} from "../../../../data/enums/EventType";
import LineLabelsList from "../LineLabelsList/LineLabelsList";
import TagLabelsList from "../TagLabelsList/TagLabelsList";

interface IProps {
    activeImageIndex:number,
    activeLabelType: LabelType;
    imagesData: ImageData[];
    projectType: ProjectType;
    updateImageDataById: (id: string, newImageData: ImageData) => any;
    updateActiveLabelType: (activeLabelType: LabelType) => any;
    updateActiveLabelId: (highlightedLabelId: string) => any;
}

interface IState {
    size: ISize;
}

class LabelsToolkit extends React.Component<IProps, IState> {
    private labelsToolkitRef: HTMLDivElement;
    private readonly tabs: LabelType[];

    constructor(props) {
        super(props);

        this.state = {
            size: null,
        };

        this.tabs = props.projectType === ProjectType.IMAGE_RECOGNITION ?
            [
                LabelType.IMAGE_RECOGNITION
            ] :
            [
                LabelType.RECT,
                LabelType.POINT,
                LabelType.LINE,
                LabelType.POLYGON
            ];

        const activeTab: LabelType = props.activeLabelType ? props.activeLabelType : this.tabs[0];
        props.updateActiveLabelType(activeTab);
    }

    public componentDidMount(): void {
        this.updateToolkitSize();
        window.addEventListener(EventType.RESIZE, this.updateToolkitSize);
    }

    public componentWillUnmount(): void {
        window.removeEventListener(EventType.RESIZE, this.updateToolkitSize);
    }

    private updateToolkitSize = () => {
        if (!this.labelsToolkitRef)
            return;

        const listBoundingBox = this.labelsToolkitRef.getBoundingClientRect();
        this.setState({
            size: {
                width: listBoundingBox.width,
                height: listBoundingBox.height
            }
        })
    };

    private headerClickHandler = (activeTab: LabelType) => {
        this.props.updateActiveLabelType(activeTab);
        this.props.updateActiveLabelId(null);
    };

    private renderChildren = () => {
        const {size} = this.state;
        const {activeImageIndex, imagesData, activeLabelType} = this.props;
        return this.tabs.reduce((children, labelType: LabelType, index: number) => {
            const isActive: boolean = labelType === activeLabelType;
            const tabData: ILabelToolkit = find(LabelToolkitData, {labelType});
            const activeTabContentHeight: number = size.height - this.tabs.length * Settings.TOOLKIT_TAB_HEIGHT_PX;
            const getClassName = (baseClass: string) => classNames(
                baseClass,
                {
                    "active": isActive,
                }
            );

            const header =
                <div
                    key={"Header_" + index}
                    className={getClassName("Header")}
                    onClick={() => this.headerClickHandler(labelType)}
                    style={{height: Settings.TOOLKIT_TAB_HEIGHT_PX}}
                >
                    <div className="Marker"/>
                    <div className="HeaderGroupWrapper">
                        <img
                            draggable={false}
                            className="Ico"
                            src={tabData.imageSrc}
                            alt={tabData.imageAlt}
                        />
                        {tabData.headerText}
                    </div>
                    <div className="HeaderGroupWrapper">
                        <img
                            draggable={false}
                            className="Arrow"
                            src={"ico/down.png"}
                            alt={"down_arrow"}
                        />
                    </div>
                </div>;

            const content =
                <div
                    key={"Content_" + index}
                    className={getClassName("Content")}
                    style={{height: isActive ? activeTabContentHeight : 0}}
                >
                    {labelType === LabelType.RECT && <RectLabelsList
                        size={{
                            width: size.width - 20,
                            height: activeTabContentHeight - 20
                        }}
                        imageData={imagesData[activeImageIndex]}
                    />}
                    {labelType === LabelType.POINT && <PointLabelsList
                        size={{
                            width: size.width - 20,
                            height: activeTabContentHeight - 20
                        }}
                        imageData={imagesData[activeImageIndex]}
                    />}
                    {labelType === LabelType.LINE && <LineLabelsList
                        size={{
                            width: size.width - 20,
                            height: activeTabContentHeight - 20
                        }}
                        imageData={imagesData[activeImageIndex]}
                    />}
                    {labelType === LabelType.POLYGON && <PolygonLabelsList
                        size={{
                            width: size.width - 20,
                            height: activeTabContentHeight - 20
                        }}
                        imageData={imagesData[activeImageIndex]}
                    />}
                    {labelType === LabelType.IMAGE_RECOGNITION && <TagLabelsList
                        size={{
                            width: size.width - 20,
                            height: activeTabContentHeight - 20
                        }}
                        imageData={imagesData[activeImageIndex]}
                    />}
                </div>;

            children.push([header, content]);
            return children;
        }, [])
    };

    public render() {
        return(
            <div
                className="LabelsToolkit"
                ref={ref => this.labelsToolkitRef = ref}
                onClick={() => ContextManager.switchCtx(ContextType.RIGHT_NAVBAR)}
            >
                {this.state.size && this.renderChildren()}
            </div>
        )
    }
}

const mapDispatchToProps = {
    updateImageDataById,
    updateActiveLabelType,
    updateActiveLabelId
};

const mapStateToProps = (state: AppState) => ({
    activeImageIndex: state.labels.activeImageIndex,
    activeLabelType: state.labels.activeLabelType,
    imagesData: state.labels.imagesData,
    projectType: state.general.projectData.type,
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(LabelsToolkit);
```

Path: src/views/EditorView/SideNavigationBar/RectLabelsList/RectLabelsList.tsx
```tsx
import React from 'react';
import {ISize} from '../../../../interfaces/ISize';
import Scrollbars from 'react-custom-scrollbars-2';
import {ImageData, LabelName, LabelRect} from '../../../../store/labels/types';
import './RectLabelsList.scss';
import {
    updateActiveLabelId,
    updateActiveLabelNameId,
    updateImageDataById
} from '../../../../store/labels/actionCreators';
import {AppState} from '../../../../store';
import {connect} from 'react-redux';
import LabelInputField from '../LabelInputField/LabelInputField';
import EmptyLabelList from '../EmptyLabelList/EmptyLabelList';
import {LabelActions} from '../../../../logic/actions/LabelActions';
import {LabelStatus} from '../../../../data/enums/LabelStatus';
import {findLast} from 'lodash';

interface IProps {
    size: ISize;
    imageData: ImageData;
    updateImageDataByIdAction: (id: string, newImageData: ImageData) => any;
    activeLabelId: string;
    highlightedLabelId: string;
    updateActiveLabelNameIdAction: (activeLabelId: string) => any;
    labelNames: LabelName[];
    updateActiveLabelIdAction: (activeLabelId: string) => any;
}

const RectLabelsList: React.FC<IProps> = (
    {
        size,
        imageData,
        updateImageDataByIdAction,
        labelNames,
        updateActiveLabelNameIdAction,
        activeLabelId,
        highlightedLabelId,
        updateActiveLabelIdAction
    }
) => {
    const labelInputFieldHeight = 40;
    const listStyle: React.CSSProperties = {
        width: size.width,
        height: size.height
    };
    const listStyleContent: React.CSSProperties = {
        width: size.width,
        height: imageData.labelRects.length * labelInputFieldHeight
    };

    const deleteRectLabelById = (labelRectId: string) => {
        LabelActions.deleteRectLabelById(imageData.id, labelRectId);
    };

    const toggleRectLabelVisibilityById = (labelRectId: string) => {
        LabelActions.toggleLabelVisibilityById(imageData.id, labelRectId);
    };

    const updateRectLabel = (labelRectId: string, labelNameId: string) => {
        const newImageData = {
            ...imageData,
            labelRects: imageData.labelRects
                .map((labelRect: LabelRect) => {
                    if (labelRect.id === labelRectId) {
                        return {
                            ...labelRect,
                            labelId: labelNameId,
                            status: LabelStatus.ACCEPTED
                        }
                    } else {
                        return labelRect
                    }
                })
        };
        updateImageDataByIdAction(imageData.id, newImageData);
        updateActiveLabelNameIdAction(labelNameId);
    };

    const onClickHandler = () => {
        updateActiveLabelIdAction(null);
    };

    const getChildren = () => {
        return imageData.labelRects
            .filter((labelRect: LabelRect) => labelRect.status === LabelStatus.ACCEPTED)
            .map((labelRect: LabelRect) => {
                return <LabelInputField
                    size={{
                        width: size.width,
                        height: labelInputFieldHeight
                    }}
                    isActive={labelRect.id === activeLabelId}
                    isHighlighted={labelRect.id === highlightedLabelId}
                    isVisible={labelRect.isVisible}
                    id={labelRect.id}
                    key={labelRect.id}
                    onDelete={deleteRectLabelById}
                    value={labelRect.labelId !== null ? findLast(labelNames, {id: labelRect.labelId}) : null}
                    options={labelNames}
                    onSelectLabel={updateRectLabel}
                    toggleLabelVisibility={toggleRectLabelVisibilityById}
                />
            });
    };

    return (
        <div
            className='RectLabelsList'
            style={listStyle}
            onClickCapture={onClickHandler}
        >
            {imageData.labelRects.filter((labelRect: LabelRect) => labelRect.status === LabelStatus.ACCEPTED).length === 0 ?
                <EmptyLabelList
                    labelBefore={'draw your first bounding box'}
                    labelAfter={'no labels created for this image yet'}
                /> :
                <Scrollbars>
                    <div
                        className='RectLabelsListContent'
                        style={listStyleContent}
                    >
                        {getChildren()}
                    </div>
                </Scrollbars>
            }
        </div>
    );
};

const mapDispatchToProps = {
    updateImageDataByIdAction: updateImageDataById,
    updateActiveLabelNameIdAction: updateActiveLabelNameId,
    updateActiveLabelIdAction: updateActiveLabelId
};

const mapStateToProps = (state: AppState) => ({
    activeLabelId: state.labels.activeLabelId,
    highlightedLabelId: state.labels.highlightedLabelId,
    labelNames : state.labels.labels
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(RectLabelsList);

```

Path: src/views/EditorView/SideNavigationBar/TagLabelsList/TagLabelsList.tsx
```tsx
import {ISize} from "../../../../interfaces/ISize";
import {ImageData, LabelName} from "../../../../store/labels/types";
import React from "react";
import Scrollbars from "react-custom-scrollbars-2";
import {updateImageDataById} from "../../../../store/labels/actionCreators";
import {AppState} from "../../../../store";
import {connect} from "react-redux";
import {remove} from "lodash";
import './TagLabelsList.scss';
import classNames from "classnames";
import {ImageButton} from "../../../Common/ImageButton/ImageButton";
import {PopupWindowType} from "../../../../data/enums/PopupWindowType";
import {updateActivePopupType} from "../../../../store/general/actionCreators";
interface IProps {
    size: ISize;
    imageData: ImageData;
    updateImageDataById: (id: string, newImageData: ImageData) => any;
    labelNames: LabelName[];
    updateActivePopupType: (activePopupType: PopupWindowType) => any;
}

const TagLabelsList: React.FC<IProps> = (
    {
        size,
        imageData,
        updateImageDataById,
        labelNames,
        updateActivePopupType
    }) => {
    const labelInputFieldHeight = 40;
    const listStyle: React.CSSProperties = {
        width: size.width,
        height: size.height
    };
    const listStyleContent: React.CSSProperties = {
        width: size.width,
        height: imageData.labelPolygons.length * labelInputFieldHeight
    };

    const onTagClick = (labelId: string)  => {
        if (imageData.labelNameIds.includes(labelId)) {
            updateImageDataById(imageData.id, {
                ...imageData,
                labelNameIds: remove(imageData.labelNameIds, (element: string) => element !== labelId)
            })
        } else {
            updateImageDataById(imageData.id, {
                ...imageData,
                labelNameIds: imageData.labelNameIds.concat(labelId)
            })
        }
    }

    const getClassName = (labelId: string) => {
        return classNames(
            "TagItem",
            {
                "active": imageData.labelNameIds.includes(labelId)
            }
        );
    };

    const addNewOnClick = () => {
        updateActivePopupType(PopupWindowType.UPDATE_LABEL)
    }

    const getChildren = () => {
        return [
            ...labelNames.map((labelName: LabelName) => {
                return <div
                    className={getClassName(labelName.id)}
                    onClickCapture={() => onTagClick(labelName.id)}
                    key={labelName.id}
                >
                    {labelName.name}
                </div>
            }),
            <ImageButton
                image={"ico/plus.png"}
                imageAlt={"plus"}
                buttonSize={{width: 32, height: 32}}
                onClick={addNewOnClick}
            />
        ]
    };

    return (
        <div
            className="TagLabelsList"
            style={listStyle}
            key="tag-labels-list"
        >
            {labelNames.length === 0 ?
                <div
                    className="EmptyLabelList"
                    onClick={addNewOnClick}
                    key="empty-label-list"
                >
                    <img
                        draggable={false}
                        alt={"upload"}
                        src={"ico/type-writer.png"}
                    />
                    <p className="extraBold">Your label list is empty</p>
                </div> :
                <Scrollbars>
                    <div
                        className="TagLabelsListContent"
                        style={listStyleContent}
                        key="tag-labels-list-content"
                    >
                        {getChildren()}
                    </div>
                </Scrollbars>
            }
        </div>
    );
};

const mapDispatchToProps = {
    updateImageDataById,
    updateActivePopupType
};

const mapStateToProps = (state: AppState) => ({
    labelNames : state.labels.labels
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(TagLabelsList);
```

Path: src/views/EditorView/SideNavigationBar/PolygonLabelsList/PolygonLabelsList.tsx
```tsx
import React from 'react';
import {ISize} from '../../../../interfaces/ISize';
import Scrollbars from 'react-custom-scrollbars-2';
import {ImageData, LabelName, LabelPolygon} from '../../../../store/labels/types';
import './PolygonLabelsList.scss';
import {
    updateActiveLabelId,
    updateActiveLabelNameId,
    updateImageDataById
} from '../../../../store/labels/actionCreators';
import {AppState} from '../../../../store';
import {connect} from 'react-redux';
import LabelInputField from '../LabelInputField/LabelInputField';
import EmptyLabelList from '../EmptyLabelList/EmptyLabelList';
import {LabelActions} from '../../../../logic/actions/LabelActions';
import {findLast} from 'lodash';

interface IProps {
    size: ISize;
    imageData: ImageData;
    updateImageDataByIdAction: (id: string, newImageData: ImageData) => any;
    activeLabelId: string;
    highlightedLabelId: string;
    updateActiveLabelNameIdAction: (activeLabelId: string) => any;
    labelNames: LabelName[];
    updateActiveLabelIdAction: (activeLabelId: string) => any;
}

const PolygonLabelsList: React.FC<IProps> = (
    {
        size,
        imageData,
        updateImageDataByIdAction,
        labelNames,
        updateActiveLabelNameIdAction,
        activeLabelId,
        highlightedLabelId,
        updateActiveLabelIdAction
    }
) => {
    const labelInputFieldHeight = 40;
    const listStyle: React.CSSProperties = {
        width: size.width,
        height: size.height
    };
    const listStyleContent: React.CSSProperties = {
        width: size.width,
        height: imageData.labelPolygons.length * labelInputFieldHeight
    };

    const deletePolygonLabelById = (labelPolygonId: string) => {
        LabelActions.deletePolygonLabelById(imageData.id, labelPolygonId);
    };

    const togglePolygonLabelVisibilityById = (labelPolygonId: string) => {
        LabelActions.toggleLabelVisibilityById(imageData.id, labelPolygonId);
    };

    const updatePolygonLabel = (labelPolygonId: string, labelNameId: string) => {
        const newImageData = {
            ...imageData,
            labelPolygons: imageData.labelPolygons.map((currentLabel: LabelPolygon) => {
                if (currentLabel.id === labelPolygonId) {
                    return {
                        ...currentLabel,
                        labelId: labelNameId
                    }
                }
                return currentLabel
            })
        };
        updateImageDataByIdAction(imageData.id, newImageData);
        updateActiveLabelNameIdAction(labelNameId);
    };

    const onClickHandler = () => {
        updateActiveLabelIdAction(null);
    };

    const getChildren = () => {
        return imageData.labelPolygons.map((labelPolygon: LabelPolygon) => {
            return <LabelInputField
                size={{
                    width: size.width,
                    height: labelInputFieldHeight
                }}
                isActive={labelPolygon.id === activeLabelId}
                isHighlighted={labelPolygon.id === highlightedLabelId}
                isVisible={labelPolygon.isVisible}
                id={labelPolygon.id}
                key={labelPolygon.id}
                onDelete={deletePolygonLabelById}
                value={labelPolygon.labelId !== null ? findLast(labelNames, {id: labelPolygon.labelId}) : null}
                options={labelNames}
                onSelectLabel={updatePolygonLabel}
                toggleLabelVisibility={togglePolygonLabelVisibilityById}
            />
        });
    };

    return (
        <div
            className='PolygonLabelsList'
            style={listStyle}
            onClickCapture={onClickHandler}
        >
            {imageData.labelPolygons.length === 0 ?
                <EmptyLabelList
                    labelBefore={'draw your first polygon'}
                    labelAfter={'no labels created for this image yet'}
                /> :
                <Scrollbars>
                    <div
                        className='PolygonLabelsListContent'
                        style={listStyleContent}
                    >
                        {getChildren()}
                    </div>
                </Scrollbars>
            }
        </div>
    );
};

const mapDispatchToProps = {
    updateImageDataByIdAction: updateImageDataById,
    updateActiveLabelNameIdAction: updateActiveLabelNameId,
    updateActiveLabelIdAction: updateActiveLabelId
};

const mapStateToProps = (state: AppState) => ({
    activeLabelId: state.labels.activeLabelId,
    highlightedLabelId: state.labels.highlightedLabelId,
    labelNames : state.labels.labels
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(PolygonLabelsList);

```

Path: src/views/EditorView/SideNavigationBar/EmptyLabelList/EmptyLabelList.tsx
```tsx
import React from 'react';
import './EmptyLabelList.scss';
import {AppState} from "../../../../store";
import {connect} from "react-redux";

interface IProps {
    firstLabelCreatedFlag: boolean;
    labelBefore: string;
    labelAfter: string;
}

const EmptyLabelList: React.FC<IProps> = ({firstLabelCreatedFlag, labelBefore, labelAfter}) => {
    const before = <>
        <img
            draggable={false}
            alt={"lets_start"}
            src={"ico/rocket.png"}
        />
        <p className="extraBold">{labelBefore}</p>
    </>;

    const after = <>
        <img
            draggable={false}
            alt={"no_labels"}
            src={"ico/box-opened.png"}
        />
        <p className="extraBold">{labelAfter}</p>
    </>;

    return(<div className="EmptyLabelList">
        {!firstLabelCreatedFlag ? before : after}
    </div>)
};

const mapDispatchToProps = {};

const mapStateToProps = (state: AppState) => ({
    firstLabelCreatedFlag: state.labels.firstLabelCreatedFlag
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(EmptyLabelList);
```

Path: src/views/EditorView/TopNavigationBar/TopNavigationBar.tsx
```tsx
import React from 'react';
import './TopNavigationBar.scss';
import StateBar from '../StateBar/StateBar';
import {PopupWindowType} from '../../../data/enums/PopupWindowType';
import {AppState} from '../../../store';
import {connect} from 'react-redux';
import {updateActivePopupType, updateProjectData} from '../../../store/general/actionCreators';
import TextInput from '../../Common/TextInput/TextInput';
import {ImageButton} from '../../Common/ImageButton/ImageButton';
import {Settings} from '../../../settings/Settings';
import {ProjectData} from '../../../store/general/types';
import DropDownMenu from './DropDownMenu/DropDownMenu';

interface IProps {
    updateActivePopupTypeAction: (activePopupType: PopupWindowType) => any;
    updateProjectDataAction: (projectData: ProjectData) => any;
    projectData: ProjectData;
}

const TopNavigationBar: React.FC<IProps> = (props) => {
    const onFocus = (event: React.FocusEvent<HTMLInputElement>) => {
        event.target.setSelectionRange(0, event.target.value.length);
    };

    const onChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const value = event.target.value
            .toLowerCase()
            .replace(' ', '-');

        props.updateProjectDataAction({
            ...props.projectData,
            name: value
        })
    };

    const closePopup = () => props.updateActivePopupTypeAction(PopupWindowType.EXIT_PROJECT)

    return (
        <div className='TopNavigationBar'>
            <StateBar/>
            <div className='TopNavigationBarWrapper'>
                <div className='NavigationBarGroupWrapper'>
                    <div
                        className='Header'
                        onClick={closePopup}
                    >
                        <img
                            draggable={false}
                            alt={'make-sense'}
                            src={'/make-sense-ico-transparent.png'}
                        />
                        Make Sense
                    </div>
                </div>
                <div className='NavigationBarGroupWrapper'>
                    <DropDownMenu/>
                </div>
                <div className='NavigationBarGroupWrapper middle'>
                    <div className='ProjectName'>Project Name:</div>
                    <TextInput
                        isPassword={false}
                        value={props.projectData.name}
                        onChange={onChange}
                        onFocus={onFocus}
                    />
                </div>
                <div className='NavigationBarGroupWrapper'>
                    <ImageButton
                        image={'ico/github-logo.png'}
                        imageAlt={'github-logo.png'}
                        buttonSize={{width: 30, height: 30}}
                        href={Settings.GITHUB_URL}
                    />
                </div>
            </div>
        </div>
    );
};

const mapDispatchToProps = {
    updateActivePopupTypeAction: updateActivePopupType,
    updateProjectDataAction: updateProjectData
};

const mapStateToProps = (state: AppState) => ({
    projectData: state.general.projectData
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(TopNavigationBar);

```

Path: src/views/EditorView/TopNavigationBar/DropDownMenu/DropDownMenu.tsx
```tsx
import React, {useState} from 'react';
import classNames from 'classnames'
import './DropDownMenu.scss';
import {DropDownMenuData, DropDownMenuNode} from '../../../../data/info/DropDownMenuData';
import {EventType} from '../../../../data/enums/EventType';
import {updatePreventCustomCursorStatus} from '../../../../store/general/actionCreators';
import {AppState} from '../../../../store';
import {connect} from 'react-redux';

interface IProps {
    updatePreventCustomCursorStatusAction: (preventCustomCursor: boolean) => any;
}

const DropDownMenu: React.FC<IProps> = ({updatePreventCustomCursorStatusAction}) => {
    const topAnchor = 35;

    const [activeTabIdx, setActiveTabIdx] = useState(null);
    const [activeDropDownAnchor, setDropDownAnchor] = useState(null);

    const onTabClick = (tabIdx: number, event) => {
        if (activeTabIdx === null) {
            document.addEventListener(EventType.MOUSE_DOWN, onMouseDownBeyondDropDown);
        }

        if (activeTabIdx === tabIdx) {
            setActiveTabIdx(null);
            setDropDownAnchor(null);
        } else {
            setActiveTabIdx(tabIdx);
            setDropDownAnchor({x: event.target.offsetLeft, y: topAnchor});
        }
    }

    const onMouseEnterWindow = (event) => {
        updatePreventCustomCursorStatusAction(true);
    }

    const onMouseLeaveWindow = (event) => {
        updatePreventCustomCursorStatusAction(false);
    }

    const onMouseDownBeyondDropDown = (event) => {
        if (event.target.classList.contains('DropDownMenuTab') || event.target.classList.contains('DropDownMenuContentOption')) {
            return;
        }
        setActiveTabIdx(null);
        document.removeEventListener(EventType.MOUSE_DOWN, onMouseDownBeyondDropDown);
    }

    const onMouseEnterTab = (tabIdx: number, event) => {
        if (activeTabIdx !== null && activeTabIdx !== tabIdx) {
            setActiveTabIdx(tabIdx);
            setDropDownAnchor({x: event.target.offsetLeft, y: topAnchor});
        }
    }

    const getDropDownMenuTabClassName = (tabIdx: number) => {
        return classNames(
            'DropDownMenuTab',
            {'active': tabIdx === activeTabIdx}
        );
    };

    const getDropDownMenuContentOption = (disabled: boolean) => {
        return classNames(
            'DropDownMenuContentOption',
            {'active': !disabled}
        );
    }

    const getDropDownContent = () => {
        return DropDownMenuData.map((data: DropDownMenuNode, index: number) => getDropDownTab(data, index))
    }

    const wrapOnClick = (onClick?: () => void, disabled?: boolean): () => void => {
        return () => {
            if (!!disabled) return;
            if (!!onClick) onClick();
            setActiveTabIdx(null);
            updatePreventCustomCursorStatusAction(false);
            document.removeEventListener(EventType.MOUSE_DOWN, onMouseDownBeyondDropDown);
        }
    }

    const getDropDownTab = (data: DropDownMenuNode, index: number) => {
        return <div
            className={getDropDownMenuTabClassName(index)}
            key={index}
            onClick={(event) => onTabClick(index, event)}
            onMouseEnter={(event) => onMouseEnterTab(index, event)}
        >
            <img
                draggable={false}
                src={data.imageSrc}
                alt={data.imageAlt}
            />
            {data.name}
        </div>
    }

    const getDropDownWindow = (data: DropDownMenuNode) => {
        if (activeTabIdx !== null) {
            const style: React.CSSProperties = {
                top: 35,
                left: activeDropDownAnchor.x,
                height: 40 * data.children.length + 10
            }
            return <div
                className={'DropDownMenuContent'}
                style={style}
                onMouseEnter={onMouseEnterWindow}
                onMouseLeave={onMouseLeaveWindow}
            >
                {data.children.map((element: DropDownMenuNode, index: number) => {
                    return <div className={getDropDownMenuContentOption(element.disabled)}
                        onClick={wrapOnClick(element.onClick, element.disabled)}
                        key={index}
                    >
                        <div className='Marker'/>
                        <img src={element.imageSrc} alt={element.imageAlt}/>
                        {element.name}
                    </div>})}
            </div>
        } else {
            return null;
        }
    }

    return(<div className='DropDownMenuWrapper'>
        <>
            {getDropDownContent()}
            {getDropDownWindow(DropDownMenuData[activeTabIdx])}
        </>
    </div>)
}

const mapDispatchToProps = {
    updatePreventCustomCursorStatusAction: updatePreventCustomCursorStatus,
};

const mapStateToProps = (state: AppState) => ({});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(DropDownMenu);

```

Path: src/views/EditorView/EditorTopNavigationBar/EditorTopNavigationBar.tsx
```tsx
import { ContextType } from '../../../data/enums/ContextType';
import './EditorTopNavigationBar.scss';
import React from 'react';
import classNames from 'classnames';
import { AppState } from '../../../store';
import { connect } from 'react-redux';
import { updateCrossHairVisibleStatus, updateImageDragModeStatus } from '../../../store/general/actionCreators';
import { GeneralSelector } from '../../../store/selectors/GeneralSelector';
import { ViewPointSettings } from '../../../settings/ViewPointSettings';
import { ImageButton } from '../../Common/ImageButton/ImageButton';
import { ViewPortActions } from '../../../logic/actions/ViewPortActions';
import { LabelsSelector } from '../../../store/selectors/LabelsSelector';
import { LabelType } from '../../../data/enums/LabelType';
import { AISelector } from '../../../store/selectors/AISelector';
import { ISize } from '../../../interfaces/ISize';
import { AIActions } from '../../../logic/actions/AIActions';
import { Fade, styled, Tooltip, tooltipClasses, TooltipProps } from '@mui/material';
const BUTTON_SIZE: ISize = { width: 30, height: 30 };
const BUTTON_PADDING: number = 10;

const StyledTooltip = styled(({ className, ...props }: TooltipProps) => (
    <Tooltip {...props} classes={{ popper: className }} />
  ))(({ theme }) => ({
    [`& .${tooltipClasses.tooltip}`]: {
        backgroundColor: '#171717',
        color: '#ffffff',
        boxShadow: theme.shadows[1],
        fontSize: 12,
        maxWidth: 200,
        textAlign: 'center'
    },
  }));

const getButtonWithTooltip = (
    key: string,
    tooltipMessage: string,
    imageSrc: string,
    imageAlt: string,
    isActive: boolean,
    href?: string,
    onClick?: () => any
): React.ReactElement => {
    return <StyledTooltip
        key={key}
        disableFocusListener={true}
        title={tooltipMessage}
        TransitionComponent={Fade}
        TransitionProps={{ timeout: 600 }}
        placement='bottom'
    >
        <div>
            <ImageButton
                buttonSize={BUTTON_SIZE}
                padding={BUTTON_PADDING}
                image={imageSrc}
                imageAlt={imageAlt}
                href={href}
                onClick={onClick}
                isActive={isActive}
            />
        </div>
    </StyledTooltip>;
};

interface IProps {
    activeContext: ContextType;
    updateImageDragModeStatusAction: (imageDragMode: boolean) => any;
    updateCrossHairVisibleStatusAction: (crossHairVisible: boolean) => any;
    imageDragMode: boolean;
    crossHairVisible: boolean;
    activeLabelType: LabelType;
}

const EditorTopNavigationBar: React.FC<IProps> = (
    {
        activeContext,
        updateImageDragModeStatusAction,
        updateCrossHairVisibleStatusAction,
        imageDragMode,
        crossHairVisible,
        activeLabelType
    }) => {
    const getClassName = () => {
        return classNames(
            'EditorTopNavigationBar',
            {
                'with-context': activeContext === ContextType.EDITOR
            }
        );
    };

    const imageDragOnClick = () => {
        if (imageDragMode) {
            updateImageDragModeStatusAction(!imageDragMode);
        }
        else if (GeneralSelector.getZoom() !== ViewPointSettings.MIN_ZOOM) {
            updateImageDragModeStatusAction(!imageDragMode);
        }
    };

    const crossHairOnClick = () => {
        updateCrossHairVisibleStatusAction(!crossHairVisible);
    };

    const withAI = (
        (activeLabelType === LabelType.RECT && AISelector.isAISSDObjectDetectorModelLoaded()) ||
        (activeLabelType === LabelType.RECT && AISelector.isAIYOLOObjectDetectorModelLoaded()) ||
        (activeLabelType === LabelType.RECT && AISelector.isRoboflowAPIModelLoaded()) ||
        (activeLabelType === LabelType.POINT && AISelector.isAIPoseDetectorModelLoaded())
    )

    return (
        <div className={getClassName()}>
            <div className='ButtonWrapper'>
                {
                    getButtonWithTooltip(
                        'zoom-in',
                        'zoom in',
                        'ico/zoom-in.png',
                        'zoom-in',
                        false,
                        undefined,
                        () => ViewPortActions.zoomIn()
                    )
                }
                {
                    getButtonWithTooltip(
                        'zoom-out',
                        'zoom out',
                        'ico/zoom-out.png',
                        'zoom-out',
                        false,
                        undefined,
                        () => ViewPortActions.zoomOut()
                    )
                }
                {
                    getButtonWithTooltip(
                        'zoom-fit',
                        'fit image to available space',
                        'ico/zoom-fit.png',
                        'zoom-fit',
                        false,
                        undefined,
                        () => ViewPortActions.setDefaultZoom()
                    )
                }
                {
                    getButtonWithTooltip(
                        'zoom-max',
                        'maximum allowed image zoom',
                        'ico/zoom-max.png',
                        'zoom-max',
                        false,
                        undefined,
                        () => ViewPortActions.setOneForOneZoom()
                    )
                }
            </div>
            <div className='ButtonWrapper'>
                {
                    getButtonWithTooltip(
                        'image-drag-mode',
                        imageDragMode ? 'turn-off image drag mode' : 'turn-on image drag mode - works only when image is zoomed',
                        'ico/hand.png',
                        'image-drag-mode',
                        imageDragMode,
                        undefined,
                        imageDragOnClick
                    )
                }
                {
                    getButtonWithTooltip(
                        'cursor-cross-hair',
                        crossHairVisible ? 'turn-off cursor cross-hair' : 'turn-on cursor cross-hair',
                        'ico/cross-hair.png',
                        'cross-hair',
                        crossHairVisible,
                        undefined,
                        crossHairOnClick
                    )
                }
            </div>
            {withAI && <div className='ButtonWrapper'>
                    {
                        getButtonWithTooltip(
                            'accept-all',
                            'accept all proposed detections',
                            'ico/accept-all.png',
                            'accept-all',
                            false,
                            undefined,
                            () => AIActions.acceptAllSuggestedLabels(LabelsSelector.getActiveImageData())
                        )
                    }
                    {
                        getButtonWithTooltip(
                            'reject-all',
                            'reject all proposed detections',
                            'ico/reject-all.png',
                            'reject-all',
                            false,
                            undefined,
                            () => AIActions.rejectAllSuggestedLabels(LabelsSelector.getActiveImageData())
                        )
                    }
                </div>}
        </div>
    );
};

const mapDispatchToProps = {
    updateImageDragModeStatusAction: updateImageDragModeStatus,
    updateCrossHairVisibleStatusAction: updateCrossHairVisibleStatus
};

const mapStateToProps = (state: AppState) => ({
    activeContext: state.general.activeContext,
    imageDragMode: state.general.imageDragMode,
    crossHairVisible: state.general.crossHairVisible,
    activeLabelType: state.labels.activeLabelType
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(EditorTopNavigationBar);

```

Path: src/views/EditorView/Editor/Editor.tsx
```tsx
import React from 'react';
import './Editor.scss';
import {ISize} from '../../../interfaces/ISize';
import {ImageData, LabelPoint, LabelRect} from '../../../store/labels/types';
import {FileUtil} from '../../../utils/FileUtil';
import {AppState} from '../../../store';
import {connect} from 'react-redux';
import {updateImageDataById} from '../../../store/labels/actionCreators';
import {ImageRepository} from '../../../logic/imageRepository/ImageRepository';
import {LabelType} from '../../../data/enums/LabelType';
import {PopupWindowType} from '../../../data/enums/PopupWindowType';
import {CanvasUtil} from '../../../utils/CanvasUtil';
import {CustomCursorStyle} from '../../../data/enums/CustomCursorStyle';
import {ImageLoadManager} from '../../../logic/imageRepository/ImageLoadManager';
import {EventType} from '../../../data/enums/EventType';
import {EditorData} from '../../../data/EditorData';
import {EditorModel} from '../../../staticModels/EditorModel';
import {EditorActions} from '../../../logic/actions/EditorActions';
import {EditorUtil} from '../../../utils/EditorUtil';
import {ContextManager} from '../../../logic/context/ContextManager';
import {ContextType} from '../../../data/enums/ContextType';
import Scrollbars from 'react-custom-scrollbars-2';
import {ViewPortActions} from '../../../logic/actions/ViewPortActions';
import {PlatformModel} from '../../../staticModels/PlatformModel';
import LabelControlPanel from '../LabelControlPanel/LabelControlPanel';
import {IPoint} from '../../../interfaces/IPoint';
import {RenderEngineUtil} from '../../../utils/RenderEngineUtil';
import {LabelStatus} from '../../../data/enums/LabelStatus';
import {isEqual} from 'lodash';
import {AIActions} from '../../../logic/actions/AIActions';

interface IProps {
    size: ISize;
    imageData: ImageData;
    activeLabelType: LabelType;
    updateImageDataById: (id: string, newImageData: ImageData) => any;
    activePopupType: PopupWindowType;
    activeLabelId: string;
    customCursorStyle: CustomCursorStyle;
    imageDragMode: boolean;
    zoom: number;
}

interface IState {
    viewPortSize: ISize
}

class Editor extends React.Component<IProps, IState> {

    constructor(props) {
        super(props);
        this.state = {
            viewPortSize: {
                width: 0,
                height: 0
            },
        };
    }

    // =================================================================================================================
    // LIFE CYCLE
    // =================================================================================================================

    public componentDidMount(): void {
        this.mountEventListeners();

        const {imageData, activeLabelType} = this.props;

        ContextManager.switchCtx(ContextType.EDITOR);
        EditorActions.mountRenderEnginesAndHelpers(activeLabelType);
        ImageLoadManager.addAndRun(this.loadImage(imageData));
        ViewPortActions.resizeCanvas(this.props.size);
    }

    public componentWillUnmount(): void {
        this.unmountEventListeners();
    }

    public componentDidUpdate(prevProps: Readonly<IProps>, prevState: Readonly<{}>, snapshot?: any): void {
        const {imageData, activeLabelType} = this.props;

        prevProps.imageData.id !== imageData.id && ImageLoadManager.addAndRun(this.loadImage(imageData));

        if (prevProps.activeLabelType !== activeLabelType) {
            EditorActions.swapSupportRenderingEngine(activeLabelType);
            AIActions.detect(imageData.id, ImageRepository.getById(imageData.id));
        }

        this.updateModelAndRender();
    }

    // =================================================================================================================
    // EVENT HANDLERS
    // =================================================================================================================

    private mountEventListeners() {
        window.addEventListener(EventType.MOUSE_MOVE, this.update);
        window.addEventListener(EventType.MOUSE_UP, this.update);
        EditorModel.canvas.addEventListener(EventType.MOUSE_DOWN, this.update);
        EditorModel.canvas.addEventListener(EventType.MOUSE_WHEEL, this.handleZoom);
    }

    private unmountEventListeners() {
        window.removeEventListener(EventType.MOUSE_MOVE, this.update);
        window.removeEventListener(EventType.MOUSE_UP, this.update);
        EditorModel.canvas.removeEventListener(EventType.MOUSE_DOWN, this.update);
        EditorModel.canvas.removeEventListener(EventType.MOUSE_WHEEL, this.handleZoom);
    }

    // =================================================================================================================
    // LOAD IMAGE
    // =================================================================================================================

    private loadImage = async (imageData: ImageData): Promise<any> => {
        if (imageData.loadStatus) {
            EditorActions.setActiveImage(ImageRepository.getById(imageData.id));
            AIActions.detect(imageData.id, ImageRepository.getById(imageData.id));
            this.updateModelAndRender()
        }
        else {
            if (!EditorModel.isLoading) {
                EditorActions.setLoadingStatus(true);
                const saveLoadedImagePartial = (image: HTMLImageElement) => this.saveLoadedImage(image, imageData);
                FileUtil.loadImage(imageData.fileData)
                    .then((image:HTMLImageElement) => saveLoadedImagePartial(image))
                    .catch((error) => this.handleLoadImageError())
            }
        }
    };

    private saveLoadedImage = (image: HTMLImageElement, imageData: ImageData) => {
        imageData.loadStatus = true;
        this.props.updateImageDataById(imageData.id, imageData);
        ImageRepository.storeImage(imageData.id, image);
        EditorActions.setActiveImage(image);
        AIActions.detect(imageData.id, image);
        EditorActions.setLoadingStatus(false);
        this.updateModelAndRender()
    };

    private handleLoadImageError = () => {};

    // =================================================================================================================
    // HELPER METHODS
    // =================================================================================================================

    private updateModelAndRender = () => {
        ViewPortActions.updateViewPortSize();
        ViewPortActions.updateDefaultViewPortImageRect();
        ViewPortActions.resizeViewPortContent();
        EditorActions.fullRender();
    };

    private update = (event: MouseEvent) => {
        const editorData: EditorData = EditorActions.getEditorData(event);
        EditorModel.mousePositionOnViewPortContent = CanvasUtil.getMousePositionOnCanvasFromEvent(event, EditorModel.canvas);
        EditorModel.primaryRenderingEngine.update(editorData);

        if (this.props.imageDragMode) {
            EditorModel.viewPortHelper.update(editorData);
        } else {
            EditorModel.supportRenderingEngine && EditorModel.supportRenderingEngine.update(editorData);
        }

        !this.props.activePopupType && EditorActions.updateMousePositionIndicator(event);
        EditorActions.fullRender();
    };

    private handleZoom = (event: WheelEvent) => {
        if (event.ctrlKey || (PlatformModel.isMac && event.metaKey)) {
            const scrollSign: number = Math.sign(event.deltaY);
            if ((PlatformModel.isMac && scrollSign === -1) || (!PlatformModel.isMac && scrollSign === 1)) {
                ViewPortActions.zoomOut();
            }
            else if ((PlatformModel.isMac && scrollSign === 1) || (!PlatformModel.isMac && scrollSign === -1)) {
                ViewPortActions.zoomIn();
            }
        }
        EditorModel.mousePositionOnViewPortContent = CanvasUtil.getMousePositionOnCanvasFromEvent(event, EditorModel.canvas);
    };

    private getOptionsPanels = () => {
        const editorData: EditorData = EditorActions.getEditorData();
        if (this.props.activeLabelType === LabelType.RECT) {
            return this.props.imageData.labelRects
                .filter((labelRect: LabelRect) => labelRect.isCreatedByAI && labelRect.status !== LabelStatus.ACCEPTED)
                .map((labelRect: LabelRect) => {
                    const positionOnImage: IPoint = {x: labelRect.rect.x, y: labelRect.rect.y};
                    const positionOnViewPort: IPoint = RenderEngineUtil.transferPointFromImageToViewPortContent(positionOnImage, editorData);
                    return <LabelControlPanel
                        position={positionOnViewPort}
                        labelData={labelRect}
                        imageData={this.props.imageData}
                        key={labelRect.id}
                    />
                })
        }
        else if (this.props.activeLabelType === LabelType.POINT) {
            return this.props.imageData.labelPoints
                .filter((labelPoint: LabelPoint) => labelPoint.isCreatedByAI && labelPoint.status !== LabelStatus.ACCEPTED)
                .map((labelPoint: LabelPoint) => {
                    const positionOnImage: IPoint = {x: labelPoint.point.x, y: labelPoint.point.y};
                    const positionOnViewPort: IPoint = RenderEngineUtil.transferPointFromImageToViewPortContent(positionOnImage, editorData);
                    return <LabelControlPanel
                        position={positionOnViewPort}
                        labelData={labelPoint}
                        imageData={this.props.imageData}
                        key={labelPoint.id}
                    />
                })
        }
        else return null;
    };

    private onScrollbarsUpdate = (scrollbarContent)=>{
        const newViewPortContentSize = {
            width: scrollbarContent.scrollWidth,
            height: scrollbarContent.scrollHeight
        };
        if(!isEqual(newViewPortContentSize, this.state.viewPortSize)) {
            this.setState({viewPortSize: newViewPortContentSize})
        }
    };

    public render() {
        return (
            <div
                className='Editor'
                ref={ref => EditorModel.editor = ref}
                draggable={false}
            >
                <Scrollbars
                    ref={ref => EditorModel.viewPortScrollbars = ref}
                    renderTrackHorizontal={props => <div {...props} className='track-horizontal'/>}
                    renderTrackVertical={props => <div {...props} className='track-vertical'/>}
                    onUpdate={this.onScrollbarsUpdate}
                >
                    <div
                        className='ViewPortContent'
                    >
                        <canvas
                            className='ImageCanvas'
                            ref={ref => EditorModel.canvas = ref}
                            draggable={false}
                            onContextMenu={(event: React.MouseEvent<HTMLCanvasElement>) => event.preventDefault()}
                        />
                        {this.getOptionsPanels()}
                    </div>
                </Scrollbars>
                <div
                    className='MousePositionIndicator'
                    ref={ref => EditorModel.mousePositionIndicator = ref}
                    draggable={false}
                />
                <div
                    className={EditorUtil.getCursorStyle(this.props.customCursorStyle)}
                    ref={ref => EditorModel.cursor = ref}
                    draggable={false}
                >
                    <img
                        draggable={false}
                        alt={'indicator'}
                        src={EditorUtil.getIndicator(this.props.customCursorStyle)}
                    />
                </div>
            </div>
        );
    }
}

const mapDispatchToProps = {
    updateImageDataById
};

const mapStateToProps = (state: AppState) => ({
    activeLabelType: state.labels.activeLabelType,
    activePopupType: state.general.activePopupType,
    activeLabelId: state.labels.activeLabelId,
    customCursorStyle: state.general.customCursorStyle,
    imageDragMode: state.general.imageDragMode,
    zoom: state.general.zoom
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(Editor);

```

Path: src/views/SizeItUpView/SizeItUpView.tsx
```tsx
import React from 'react';
import './SizeItUpView.scss';
import {Settings} from "../../settings/Settings";

export const SizeItUpView: React.FC = () => {
    return(<div className="SizeItUpView">
        <p className="extraBold">Ops... This window is to tight for me!</p>
        <img
            draggable={false}
            alt={"small_window"}
            src={"ico/small_window.png"}
        />
        <p className="extraBold">Please... make it at least {Settings.EDITOR_MIN_WIDTH} x {Settings.EDITOR_MIN_HEIGHT} px.</p>
    </div>)
};
```

Path: src/views/MainView/MainView.tsx
```tsx
import React, { useState } from 'react';
import './MainView.scss';
import { TextButton } from '../Common/TextButton/TextButton';
import classNames from 'classnames';
import { ISize } from '../../interfaces/ISize';
import { ImageButton } from '../Common/ImageButton/ImageButton';
import { ISocialMedia, SocialMediaData } from '../../data/info/SocialMediaData';
import { EditorFeatureData, IEditorFeature } from '../../data/info/EditorFeatureData';
import { styled, Tooltip, tooltipClasses, TooltipProps } from '@mui/material';
import Fade from '@mui/material/Fade';
import ImagesDropZone from './ImagesDropZone/ImagesDropZone';

const MainView: React.FC = () => {
    const [projectInProgress, setProjectInProgress] = useState(false);
    const [projectCanceled, setProjectCanceled] = useState(false);

    const startProject = () => {
        setProjectInProgress(true);
    };

    const endProject = () => {
        setProjectInProgress(false);
        setProjectCanceled(true);
    };

    const getClassName = () => {
        return classNames(
            'MainView', {
            'InProgress': projectInProgress,
            'Canceled': !projectInProgress && projectCanceled
        }
        );
    };

    const DarkTooltip = styled(({ className, ...props }: TooltipProps) => (
        <Tooltip {...props} classes={{ popper: className }} />
    ))(({ theme }) => ({
        [`& .${tooltipClasses.tooltip}`]: {
            backgroundColor: '#171717',
            color: '#ffffff',
            boxShadow: theme.shadows[1],
            fontSize: 11,
            maxWidth: 120
        },
    }));

    const getSocialMediaButtons = (size: ISize) => {
        return SocialMediaData.map((data: ISocialMedia, index: number) => {
            return <DarkTooltip
                key={index}
                disableFocusListener={true}
                title={data.tooltipMessage}
                TransitionComponent={Fade}
                TransitionProps={{ timeout: 600 }}
                placement='left'
            >
                <div>
                    <ImageButton
                        buttonSize={size}
                        image={data.imageSrc}
                        imageAlt={data.imageAlt}
                        href={data.href}
                    />
                </div>
            </DarkTooltip>;
        });
    };

    const getEditorFeatureTiles = () => {
        return EditorFeatureData.map((data: IEditorFeature) => {
            return <div
                className='EditorFeaturesTiles'
                key={data.displayText}
            >
                <div
                    className='EditorFeaturesTilesWrapper'
                >
                    <img
                        draggable={false}
                        alt={data.imageAlt}
                        src={data.imageSrc}
                    />
                    <div className='EditorFeatureLabel'>
                        {data.displayText}
                    </div>
                </div>
            </div>;
        });
    };

    return (
        <div className={getClassName()}>
            <div className='Slider' id='lower'>
                <div className='TriangleVertical'>
                    <div className='TriangleVerticalContent' />
                </div>
            </div>

            <div className='Slider' id='upper'>
                <div className='TriangleVertical'>
                    <div className='TriangleVerticalContent' />
                </div>
            </div>

            <div className='LeftColumn'>
                <div className={'LogoWrapper'}>
                    <img
                        draggable={false}
                        alt={'main-logo'}
                        src={'ico/main-image-color.png'}
                    />
                </div>
                <div className='EditorFeaturesWrapper'>
                    {getEditorFeatureTiles()}
                </div>
                <div className='TriangleVertical'>
                    <div className='TriangleVerticalContent' />
                </div>
                {projectInProgress && <TextButton
                    label={'Go Back'}
                    onClick={endProject}
                />}
            </div>
            <div className='RightColumn'>
                <div />
                <ImagesDropZone />
                <div className='SocialMediaWrapper'>
                    {getSocialMediaButtons({ width: 30, height: 30 })}
                </div>
                {!projectInProgress && <TextButton
                    label={'Get Started'}
                    onClick={startProject}
                    externalClassName={'get-started-button'}
                />}
            </div>
        </div>
    );
};

export default MainView;

```

Path: src/views/MainView/ImagesDropZone/ImagesDropZone.tsx
```tsx
import React, {PropsWithChildren} from 'react';
import './ImagesDropZone.scss';
import {useDropzone,DropzoneOptions} from 'react-dropzone';
import {TextButton} from '../../Common/TextButton/TextButton';
import {ImageData} from '../../../store/labels/types';
import {connect} from 'react-redux';
import {addImageData, updateActiveImageIndex} from '../../../store/labels/actionCreators';
import {AppState} from '../../../store';
import {ProjectType} from '../../../data/enums/ProjectType';
import {PopupWindowType} from '../../../data/enums/PopupWindowType';
import {updateActivePopupType, updateProjectData} from '../../../store/general/actionCreators';
import {ProjectData} from '../../../store/general/types';
import {ImageDataUtil} from '../../../utils/ImageDataUtil';
import { sortBy } from 'lodash';

interface IProps {
    updateActiveImageIndexAction: (activeImageIndex: number) => any;
    addImageDataAction: (imageData: ImageData[]) => any;
    updateProjectDataAction: (projectData: ProjectData) => any;
    updateActivePopupTypeAction: (activePopupType: PopupWindowType) => any;
    projectData: ProjectData;
}

const ImagesDropZone: React.FC<IProps> = (props: PropsWithChildren<IProps>) => {
    const {acceptedFiles, getRootProps, getInputProps} = useDropzone({
        accept: {
            'image/*': ['.jpeg', '.png']
        }
    } as DropzoneOptions);

    const startEditor = (projectType: ProjectType) => {
        if (acceptedFiles.length > 0) {
            const files = sortBy(acceptedFiles, (item: File) => item.name)
            props.updateProjectDataAction({
                ...props.projectData,
                type: projectType
            });
            props.updateActiveImageIndexAction(0);
            props.addImageDataAction(files.map((file:File) => ImageDataUtil
                .createImageDataFromFileData(file)));
            props.updateActivePopupTypeAction(PopupWindowType.INSERT_LABEL_NAMES);
        }
    };

    const getDropZoneContent = () => {
        if (acceptedFiles.length === 0)
            return <>
                <input {...getInputProps()} />
                <img
                    draggable={false}
                    alt={'upload'}
                    src={'ico/box-opened.png'}
                />
                <p className='extraBold'>Drop images</p>
                <p>or</p>
                <p className='extraBold'>Click here to select them</p>
            </>;
        else if (acceptedFiles.length === 1)
            return <>
                <img
                    draggable={false}
                    alt={'uploaded'}
                    src={'ico/box-closed.png'}
                />
                <p className='extraBold'>1 image loaded</p>
            </>;
        else
            return <>
                <input {...getInputProps()} />
                <img
                    draggable={false}
                    key={1}
                    alt={'uploaded'}
                    src={'ico/box-closed.png'}
                />
                <p key={2} className='extraBold'>{acceptedFiles.length} images loaded</p>
            </>;
    };

    const startEditorWithObjectDetection = () => startEditor(ProjectType.OBJECT_DETECTION)
    const startEditorWithImageRecognition = () => startEditor(ProjectType.IMAGE_RECOGNITION)

    return(
        <div className='ImagesDropZone'>
            <div {...getRootProps({className: 'DropZone'})}>
                {getDropZoneContent()}
            </div>
            <div className='DropZoneButtons'>
                <TextButton
                    label={'Object Detection'}
                    isDisabled={!acceptedFiles.length}
                    onClick={startEditorWithObjectDetection}
                />
                <TextButton
                    label={'Image recognition'}
                    isDisabled={!acceptedFiles.length}
                    onClick={startEditorWithImageRecognition}
                />
            </div>
        </div>
    )
};

const mapDispatchToProps = {
    updateActiveImageIndexAction: updateActiveImageIndex,
    addImageDataAction: addImageData,
    updateProjectDataAction: updateProjectData,
    updateActivePopupTypeAction: updateActivePopupType
};

const mapStateToProps = (state: AppState) => ({
    projectData: state.general.projectData
});

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(ImagesDropZone);

```

Path: src/interfaces/ILabelFormatData.ts
```ts
import {AnnotationFormatType} from "../data/enums/AnnotationFormatType";

export interface ILabelFormatData {
    type: AnnotationFormatType,
    label: string
}
```

Path: src/interfaces/ILine.ts
```ts
import {IPoint} from "./IPoint";

export interface ILine {
    start: IPoint,
    end: IPoint
}
```

Path: src/interfaces/IPoint.ts
```ts
export interface IPoint {
    x:number,
    y:number
}
```

Path: src/interfaces/IRect.ts
```ts
export interface IRect {
    x: number,
    y: number,
    height: number,
    width: number
}

```

Path: src/interfaces/ISize.ts
```ts
export interface ISize {
    width:number,
    height:number
}
```

Path: src/store/Actions.ts
```ts
export enum Action {
    // AI
    UPDATE_SUGGESTED_LABEL_LIST = '@@UPDATE_SUGGESTED_LABEL_LIST',
    UPDATE_REJECTED_SUGGESTED_LABEL_LIST = '@@UPDATE_REJECTED_SUGGESTED_LABEL_LIST',
    UPDATE_SSD_OBJECT_DETECTOR_STATUS = '@@UPDATE_SSD_OBJECT_DETECTOR_STATUS',
    UPDATE_YOLO_V5_OBJECT_DETECTOR_STATUS = '@@UPDATE_YOLO_V5_OBJECT_DETECTOR_STATUS',
    UPDATE_POSE_DETECTOR_STATUS = '@@UPDATE_POSE_DETECTOR_STATUS',
    UPDATE_DISABLED_AI_FLAG = '@@UPDATE_DISABLED_AI_FLAG',
    UPDATE_ROBOFLOW_API_DETAILS = '@@UPDATE_ROBOFLOW_API_DETAILS',

    // GENERAL
    UPDATE_PROJECT_DATA = '@@UPDATE_PROJECT_DATA',
    UPDATE_WINDOW_SIZE = '@@UPDATE_WINDOW_SIZE',
    UPDATE_ACTIVE_POPUP_TYPE = '@@UPDATE_ACTIVE_POPUP_TYPE',
    UPDATE_CUSTOM_CURSOR_STYLE = '@@UPDATE_CUSTOM_CURSOR_STYLE',
    UPDATE_CONTEXT = '@@UPDATE_CONTEXT',
    UPDATE_PREVENT_CUSTOM_CURSOR_STATUS = '@@UPDATE_PREVENT_CUSTOM_CURSOR_STATUS',
    UPDATE_IMAGE_DRAG_MODE_STATUS = '@@UPDATE_IMAGE_DRAG_MODE_STATUS',
    UPDATE_CROSS_HAIR_VISIBLE_STATUS = '@@UPDATE_CROSS_HAIR_VISIBLE_STATUS',
    UPDATE_ENABLE_PER_CLASS_COLORATION_STATUS = '@@UPDATE_ENABLE_PER_CLASS_COLORATION_STATUS',
    UPDATE_ZOOM = '@@UPDATE_ZOOM',

    // LABELS
    UPDATE_ACTIVE_IMAGE_INDEX = '@@UPDATE_ACTIVE_IMAGE_INDEX',
    UPDATE_IMAGE_DATA_BY_ID = '@@UPDATE_IMAGE_DATA_BY_ID',
    ADD_IMAGES_DATA = '@@ADD_IMAGES_DATA',
    UPDATE_IMAGES_DATA = '@@UPDATE_IMAGES_DATA',
    UPDATE_ACTIVE_LABEL_NAME_ID = '@@UPDATE_ACTIVE_LABEL_NAME_ID',
    UPDATE_ACTIVE_LABEL_TYPE = '@@UPDATE_ACTIVE_LABEL_TYPE',
    UPDATE_ACTIVE_LABEL_ID = '@@UPDATE_ACTIVE_LABEL_ID',
    UPDATE_HIGHLIGHTED_LABEL_ID = '@@UPDATE_HIGHLIGHTED_LABEL_ID',
    UPDATE_LABEL_NAMES = '@@UPDATE_LABEL_NAMES',
    UPDATE_FIRST_LABEL_CREATED_FLAG = '@@UPDATE_FIRST_LABEL_CREATED_FLAG',

    // NOTIFICATIONS
    SUBMIT_NEW_NOTIFICATION = '@@SUBMIT_NEW_NOTIFICATION',
    DELETE_NOTIFICATION_BY_ID = '@@DELETE_NOTIFICATION_BY_ID'
}

```

Path: src/store/index.ts
```ts
import { combineReducers } from 'redux';
import {labelsReducer} from './labels/reducer';
import {generalReducer} from './general/reducer';
import {aiReducer} from './ai/reducer';
import {notificationsReducer} from './notifications/reducer';

export const rootReducer = combineReducers({
    general: generalReducer,
    labels: labelsReducer,
    ai: aiReducer,
    notifications: notificationsReducer
});

export type AppState = ReturnType<typeof rootReducer>;

```

Path: src/store/general/actionCreators.ts
```ts
import {ISize} from '../../interfaces/ISize';
import {GeneralActionTypes, ProjectData} from './types';
import {Action} from '../Actions';
import {PopupWindowType} from '../../data/enums/PopupWindowType';
import {CustomCursorStyle} from '../../data/enums/CustomCursorStyle';
import {ContextType} from '../../data/enums/ContextType';

export function updateWindowSize(windowSize: ISize): GeneralActionTypes {
    return {
        type: Action.UPDATE_WINDOW_SIZE,
        payload: {
            windowSize,
        },
    };
}

export function updateActivePopupType(activePopupType: PopupWindowType): GeneralActionTypes {
    return {
        type: Action.UPDATE_ACTIVE_POPUP_TYPE,
        payload: {
            activePopupType,
        }
    }
}

export function updateCustomCursorStyle(customCursorStyle: CustomCursorStyle): GeneralActionTypes {
    return {
        type: Action.UPDATE_CUSTOM_CURSOR_STYLE,
        payload: {
            customCursorStyle,
        }
    }
}

export function updateActiveContext(activeContext: ContextType): GeneralActionTypes {
    return {
        type: Action.UPDATE_CONTEXT,
        payload: {
            activeContext,
        },
    };
}

export function updatePreventCustomCursorStatus(preventCustomCursor: boolean): GeneralActionTypes {
    return {
        type: Action.UPDATE_PREVENT_CUSTOM_CURSOR_STATUS,
        payload: {
            preventCustomCursor,
        },
    };
}

export function updateImageDragModeStatus(imageDragMode: boolean): GeneralActionTypes {
    return {
        type: Action.UPDATE_IMAGE_DRAG_MODE_STATUS,
        payload: {
            imageDragMode,
        },
    };
}

export function updateCrossHairVisibleStatus(crossHairVisible: boolean): GeneralActionTypes {
    return {
        type: Action.UPDATE_CROSS_HAIR_VISIBLE_STATUS,
        payload: {
            crossHairVisible,
        },
    };
}

export function updateProjectData(projectData: ProjectData): GeneralActionTypes {
    return {
        type: Action.UPDATE_PROJECT_DATA,
        payload: {
            projectData,
        },
    };
}

export function updateZoom(zoom: number): GeneralActionTypes {
    return {
        type: Action.UPDATE_ZOOM,
        payload: {
            zoom,
        },
    };
}

export function updatePerClassColorationStatus(enablePerClassColoration: boolean): GeneralActionTypes {
    return {
        type: Action.UPDATE_ENABLE_PER_CLASS_COLORATION_STATUS,
        payload: {
            enablePerClassColoration,
        },
    };
}

```

Path: src/store/general/reducer.ts
```ts
import {GeneralActionTypes, GeneralState} from './types';
import {Action} from '../Actions';
import {CustomCursorStyle} from '../../data/enums/CustomCursorStyle';
import {ViewPointSettings} from '../../settings/ViewPointSettings';

const initialState: GeneralState = {
    windowSize: null,
    activePopupType: null,
    customCursorStyle: CustomCursorStyle.DEFAULT,
    activeContext: null,
    preventCustomCursor: false,
    imageDragMode: false,
    crossHairVisible: true,
    enablePerClassColoration: true,
    projectData: {
        type: null,
        name: 'my-project-name',
    },
    zoom: ViewPointSettings.MIN_ZOOM
};

export function generalReducer(
    state = initialState,
    action: GeneralActionTypes
): GeneralState {
    switch (action.type) {
        case Action.UPDATE_WINDOW_SIZE: {
            return {
                ...state,
                windowSize: action.payload.windowSize
            }
        }
        case Action.UPDATE_ACTIVE_POPUP_TYPE: {
            return {
                ...state,
                activePopupType: action.payload.activePopupType
            }
        }
        case Action.UPDATE_CUSTOM_CURSOR_STYLE: {
            return {
                ...state,
                customCursorStyle: action.payload.customCursorStyle
            }
        }
        case Action.UPDATE_CONTEXT: {
            return {
                ...state,
                activeContext: action.payload.activeContext
            }
        }
        case Action.UPDATE_PREVENT_CUSTOM_CURSOR_STATUS: {
            return {
                ...state,
                preventCustomCursor: action.payload.preventCustomCursor
            }
        }
        case Action.UPDATE_IMAGE_DRAG_MODE_STATUS: {
            return {
                ...state,
                imageDragMode: action.payload.imageDragMode
            }
        }
        case Action.UPDATE_CROSS_HAIR_VISIBLE_STATUS: {
            return {
                ...state,
                crossHairVisible: action.payload.crossHairVisible
            }
        }
        case Action.UPDATE_PROJECT_DATA: {
            return {
                ...state,
                projectData: action.payload.projectData
            }
        }
        case Action.UPDATE_ZOOM: {
            return {
                ...state,
                zoom: action.payload.zoom
            }
        }
        case Action.UPDATE_ENABLE_PER_CLASS_COLORATION_STATUS: {
            return {
                ...state,
                enablePerClassColoration: action.payload.enablePerClassColoration
            }
        }
        default:
            return state;
    }
}

```

Path: src/store/general/types.ts
```ts
import {ISize} from '../../interfaces/ISize';
import {Action} from '../Actions';
import {PopupWindowType} from '../../data/enums/PopupWindowType';
import {CustomCursorStyle} from '../../data/enums/CustomCursorStyle';
import {ContextType} from '../../data/enums/ContextType';
import {ProjectType} from '../../data/enums/ProjectType';

export type ProjectData = {
    type: ProjectType;
    name: string,
}

export type GeneralState = {
    windowSize: ISize;
    activePopupType: PopupWindowType;
    customCursorStyle: CustomCursorStyle;
    preventCustomCursor: boolean;
    imageDragMode: boolean;
    crossHairVisible: boolean;
    enablePerClassColoration: boolean;
    activeContext: ContextType;
    projectData: ProjectData;
    zoom: number;
}

interface UpdateProjectData {
    type: typeof Action.UPDATE_PROJECT_DATA;
    payload: {
        projectData: ProjectData;
    }
}

interface UpdateWindowSize {
    type: typeof Action.UPDATE_WINDOW_SIZE;
    payload: {
        windowSize: ISize;
    }
}

interface UpdateActivePopupType {
    type: typeof Action.UPDATE_ACTIVE_POPUP_TYPE;
    payload: {
        activePopupType: PopupWindowType;
    }
}

interface UpdateCustomCursorStyle {
    type: typeof Action.UPDATE_CUSTOM_CURSOR_STYLE;
    payload: {
        customCursorStyle: CustomCursorStyle;
    }
}

interface UpdateActiveContext {
    type: typeof Action.UPDATE_CONTEXT;
    payload: {
        activeContext: ContextType;
    }
}

interface UpdatePreventCustomCursorStatus {
    type: typeof Action.UPDATE_PREVENT_CUSTOM_CURSOR_STATUS;
    payload: {
        preventCustomCursor: boolean;
    }
}

interface UpdateImageDragModeStatus {
    type: typeof Action.UPDATE_IMAGE_DRAG_MODE_STATUS;
    payload: {
        imageDragMode: boolean;
    }
}

interface UpdateCrossHairVisibleStatus {
    type: typeof Action.UPDATE_CROSS_HAIR_VISIBLE_STATUS;
    payload: {
        crossHairVisible: boolean;
    }
}

interface UpdateZoom {
    type: typeof Action.UPDATE_ZOOM,
    payload: {
        zoom: number;
    }
}

interface UpdatePerClassColoration {
    type: typeof Action.UPDATE_ENABLE_PER_CLASS_COLORATION_STATUS,
    payload: {
        enablePerClassColoration: boolean;
    }
}

export type GeneralActionTypes = UpdateProjectData
    | UpdateWindowSize
    | UpdateActivePopupType
    | UpdateCustomCursorStyle
    | UpdateActiveContext
    | UpdatePreventCustomCursorStatus
    | UpdateImageDragModeStatus
    | UpdateCrossHairVisibleStatus
    | UpdateZoom
    | UpdatePerClassColoration

```

Path: src/store/labels/actionCreators.ts
```ts
import {LabelsActionTypes, ImageData, LabelName} from './types';
import {Action} from '../Actions';
import {LabelType} from '../../data/enums/LabelType';

export function updateActiveImageIndex(activeImageIndex: number): LabelsActionTypes {
    return {
        type: Action.UPDATE_ACTIVE_IMAGE_INDEX,
        payload: {
            activeImageIndex,
        },
    };
}

export function updateActiveLabelNameId(activeLabelNameId: string): LabelsActionTypes {
    return {
        type: Action.UPDATE_ACTIVE_LABEL_NAME_ID,
        payload: {
            activeLabelNameId,
        },
    };
}

export function updateActiveLabelId(activeLabelId: string): LabelsActionTypes {
    return {
        type: Action.UPDATE_ACTIVE_LABEL_ID,
        payload: {
            activeLabelId,
        },
    };
}

export function updateHighlightedLabelId(highlightedLabelId: string): LabelsActionTypes {
    return {
        type: Action.UPDATE_HIGHLIGHTED_LABEL_ID,
        payload: {
            highlightedLabelId,
        },
    };
}

export function updateActiveLabelType(activeLabelType: LabelType): LabelsActionTypes {
    return {
        type: Action.UPDATE_ACTIVE_LABEL_TYPE,
        payload: {
            activeLabelType,
        },
    };
}

export function updateImageDataById(id: string, newImageData: ImageData): LabelsActionTypes {
    return {
        type: Action.UPDATE_IMAGE_DATA_BY_ID,
        payload: {
            id,
            newImageData
        },
    };
}

export function addImageData(imageData: ImageData[]): LabelsActionTypes {
    return {
        type: Action.ADD_IMAGES_DATA,
        payload: {
            imageData,
        },
    };
}

export function updateImageData(imageData: ImageData[]): LabelsActionTypes {
    return {
        type: Action.UPDATE_IMAGES_DATA,
        payload: {
            imageData,
        },
    };
}

export function updateLabelNames(labels: LabelName[]): LabelsActionTypes {
    return {
        type: Action.UPDATE_LABEL_NAMES,
        payload: {
            labels
        }
    }
}

export function updateFirstLabelCreatedFlag(firstLabelCreatedFlag: boolean): LabelsActionTypes {
    return {
        type: Action.UPDATE_FIRST_LABEL_CREATED_FLAG,
        payload: {
            firstLabelCreatedFlag
        }
    }
}

```

Path: src/store/labels/reducer.ts
```ts
import {LabelsActionTypes, LabelsState, ImageData} from './types';
import {Action} from '../Actions';

const initialState: LabelsState = {
    activeImageIndex: null,
    activeLabelNameId: null,
    activeLabelType: null,
    activeLabelId: null,
    highlightedLabelId: null,
    imagesData: [],
    firstLabelCreatedFlag: false,
    labels: []
};

export function labelsReducer(
    state = initialState,
    action: LabelsActionTypes
): LabelsState {
    switch (action.type) {
        case Action.UPDATE_ACTIVE_IMAGE_INDEX: {
            return {
                ...state,
                activeImageIndex: action.payload.activeImageIndex
            }
        }
        case Action.UPDATE_ACTIVE_LABEL_NAME_ID: {
            return {
                ...state,
                activeLabelNameId: action.payload.activeLabelNameId
            }
        }
        case Action.UPDATE_ACTIVE_LABEL_ID: {
            return {
                ...state,
                activeLabelId: action.payload.activeLabelId
            }
        }
        case Action.UPDATE_HIGHLIGHTED_LABEL_ID: {
            return {
                ...state,
                highlightedLabelId: action.payload.highlightedLabelId
            }
        }
        case Action.UPDATE_ACTIVE_LABEL_TYPE: {
            return {
                ...state,
                activeLabelType: action.payload.activeLabelType
            }
        }
        case Action.UPDATE_IMAGE_DATA_BY_ID: {
            return {
                ...state,
                imagesData: state.imagesData.map((imageData: ImageData) =>
                    imageData.id === action.payload.id ? action.payload.newImageData : imageData
                )
            }
        }
        case Action.ADD_IMAGES_DATA: {
            return {
                ...state,
                imagesData: state.imagesData.concat(action.payload.imageData)
            }
        }
        case Action.UPDATE_IMAGES_DATA: {
            return {
                ...state,
                imagesData: action.payload.imageData
            }
        }
        case Action.UPDATE_LABEL_NAMES: {
            return {
                ...state,
                labels: action.payload.labels
            }
        }
        case Action.UPDATE_FIRST_LABEL_CREATED_FLAG: {
            return {
                ...state,
                firstLabelCreatedFlag: action.payload.firstLabelCreatedFlag
            }
        }
        default:
            return state;
    }
}

```

Path: src/store/labels/types.ts
```ts
import {IRect} from '../../interfaces/IRect';
import {Action} from '../Actions';
import {LabelType} from '../../data/enums/LabelType';
import {IPoint} from '../../interfaces/IPoint';
import {LabelStatus} from '../../data/enums/LabelStatus';
import {ILine} from '../../interfaces/ILine';

export type Annotation = {
    id: string;
    labelId: string | null;
    isVisible: boolean;
}

export type LabelRect = Annotation & {
    rect: IRect;
    isCreatedByAI: boolean;
    status: LabelStatus;
    suggestedLabel: string;
}

export type LabelPoint = Annotation & {
    point: IPoint;
    isCreatedByAI: boolean;
    status: LabelStatus;
    suggestedLabel: string;
}

export type LabelPolygon = Annotation & {
    vertices: IPoint[];
}

export type LabelLine = Annotation & {
    line: ILine;
}

export type LabelName = {
    name: string;
    id: string;
    color?: string;
}

export type ImageData = {
    id: string;
    fileData: File;
    loadStatus: boolean;
    labelRects: LabelRect[];
    labelPoints: LabelPoint[];
    labelLines: LabelLine[];
    labelPolygons: LabelPolygon[];
    labelNameIds: string[];

    // YOLO
    isVisitedByYOLOObjectDetector: boolean;

    // SSD
    isVisitedBySSDObjectDetector: boolean;

    // POSE NET
    isVisitedByPoseDetector: boolean;

    // ROBOFLOW API
    isVisitedByRoboflowAPI: boolean;
}

export type LabelsState = {
    activeImageIndex: number;
    activeLabelNameId: string;
    activeLabelType: LabelType;
    activeLabelId: string | null;
    highlightedLabelId: string;
    imagesData: ImageData[];
    firstLabelCreatedFlag: boolean;
    labels: LabelName[];
}

interface UpdateActiveImageIndex {
    type: typeof Action.UPDATE_ACTIVE_IMAGE_INDEX;
    payload: {
        activeImageIndex: number;
    }
}

interface UpdateActiveLabelNameId {
    type: typeof Action.UPDATE_ACTIVE_LABEL_NAME_ID;
    payload: {
        activeLabelNameId: string;
    }
}

interface UpdateActiveLabelId {
    type: typeof Action.UPDATE_ACTIVE_LABEL_ID;
    payload: {
        activeLabelId: string;
    }
}

interface UpdateHighlightedLabelId {
    type: typeof Action.UPDATE_HIGHLIGHTED_LABEL_ID;
    payload: {
        highlightedLabelId: string;
    }
}

interface UpdateActiveLabelType {
    type: typeof Action.UPDATE_ACTIVE_LABEL_TYPE;
    payload: {
        activeLabelType: LabelType;
    }
}

interface UpdateImageDataById {
    type: typeof Action.UPDATE_IMAGE_DATA_BY_ID;
    payload: {
        id: string;
        newImageData: ImageData;
    }
}

interface AddImageData {
    type: typeof Action.ADD_IMAGES_DATA;
    payload: {
        imageData: ImageData[];
    }
}

interface UpdateImageData {
    type: typeof Action.UPDATE_IMAGES_DATA;
    payload: {
        imageData: ImageData[];
    }
}

interface UpdateLabelNames {
    type: typeof Action.UPDATE_LABEL_NAMES;
    payload: {
        labels: LabelName[];
    }
}

interface UpdateFirstLabelCreatedFlag {
    type: typeof Action.UPDATE_FIRST_LABEL_CREATED_FLAG;
    payload: {
        firstLabelCreatedFlag: boolean;
    }
}

export type LabelsActionTypes = UpdateActiveImageIndex
    | UpdateActiveLabelNameId
    | UpdateActiveLabelType
    | UpdateImageDataById
    | AddImageData
    | UpdateImageData
    | UpdateLabelNames
    | UpdateActiveLabelId
    | UpdateHighlightedLabelId
    | UpdateFirstLabelCreatedFlag


```

Path: src/store/ai/actionCreators.ts
```ts
import { Action } from '../Actions';
import { AIActionTypes, RoboflowAPIDetails } from './types';

export function updateSuggestedLabelList(labelList: string[]): AIActionTypes {
    return {
        type: Action.UPDATE_SUGGESTED_LABEL_LIST,
        payload: {
            labelList,
        }
    }
}

export function updateRejectedSuggestedLabelList(labelList: string[]): AIActionTypes {
    return {
        type: Action.UPDATE_REJECTED_SUGGESTED_LABEL_LIST,
        payload: {
            labelList,
        }
    }
}

export function updateSSDObjectDetectorStatus(isSSDObjectDetectorLoaded: boolean): AIActionTypes {
    return {
        type: Action.UPDATE_SSD_OBJECT_DETECTOR_STATUS,
        payload: {
            isSSDObjectDetectorLoaded,
        }
    }
}

export function updateYOLOV5ObjectDetectorStatus(isYOLOV5ObjectDetectorLoaded: boolean): AIActionTypes {
    return {
        type: Action.UPDATE_YOLO_V5_OBJECT_DETECTOR_STATUS,
        payload: {
            isYOLOV5ObjectDetectorLoaded,
        }
    }
}

export function updatePoseDetectorStatus(isPoseDetectorLoaded: boolean): AIActionTypes {
    return {
        type: Action.UPDATE_POSE_DETECTOR_STATUS,
        payload: {
            isPoseDetectorLoaded,
        }
    }
}

export function updateDisabledAIFlag(isAIDisabled: boolean): AIActionTypes {
    return {
        type: Action.UPDATE_DISABLED_AI_FLAG,
        payload: {
            isAIDisabled,
        }
    }
}

export function updateRoboflowAPIDetails(roboflowAPIDetails: RoboflowAPIDetails): AIActionTypes {
    return {
        type: Action.UPDATE_ROBOFLOW_API_DETAILS,
        payload: {
            roboflowAPIDetails
        }
    }
}

```

Path: src/store/ai/reducer.ts
```ts
import { AIActionTypes, AIState } from './types';
import { Action } from '../Actions';

const initialState: AIState = {
    suggestedLabelList: [],
    rejectedSuggestedLabelList: [],
    isSSDObjectDetectorLoaded: false,
    isYOLOV5ObjectDetectorLoaded: false,
    isPoseDetectorLoaded: false,
    roboflowAPIDetails: {
        status: false,
        model: '',
        key: ''
    },
    isAIDisabled: false
};

export function aiReducer(
    state = initialState,
    action: AIActionTypes
): AIState {
    switch (action.type) {
        case Action.UPDATE_SUGGESTED_LABEL_LIST: {
            return {
                ...state,
                suggestedLabelList: action.payload.labelList
            }
        }
        case Action.UPDATE_REJECTED_SUGGESTED_LABEL_LIST: {
            return {
                ...state,
                rejectedSuggestedLabelList: action.payload.labelList
            }
        }
        case Action.UPDATE_SSD_OBJECT_DETECTOR_STATUS: {
            return {
                ...state,
                isSSDObjectDetectorLoaded: action.payload.isSSDObjectDetectorLoaded
            }
        }
        case Action.UPDATE_YOLO_V5_OBJECT_DETECTOR_STATUS: {
            return {
                ...state,
                isYOLOV5ObjectDetectorLoaded: action.payload.isYOLOV5ObjectDetectorLoaded
            }
        }
        case Action.UPDATE_POSE_DETECTOR_STATUS: {
            return {
                ...state,
                isPoseDetectorLoaded: action.payload.isPoseDetectorLoaded
            }
        }
        case Action.UPDATE_DISABLED_AI_FLAG: {
            return {
                ...state,
                isAIDisabled: action.payload.isAIDisabled
            }
        }
        case Action.UPDATE_ROBOFLOW_API_DETAILS: {
            return {
                ...state,
                roboflowAPIDetails: action.payload.roboflowAPIDetails
            }
        }
        default:
            return state;
    }
}

```

Path: src/store/ai/types.ts
```ts
import {Action} from '../Actions';

export type RoboflowAPIDetails = {
    status: boolean,
    model: string,
    key: string
}

export type AIState = {
    // SSD LOCAL
    isSSDObjectDetectorLoaded: boolean;

    // YOLO V5 LOCAL
    isYOLOV5ObjectDetectorLoaded: boolean;

    // POSE NET LOCAL
    isPoseDetectorLoaded: boolean;

    // ROBOFLOW API
    roboflowAPIDetails: RoboflowAPIDetails;

    // GENERAL
    suggestedLabelList: string[];
    rejectedSuggestedLabelList: string[];
    isAIDisabled: boolean;
}

interface UpdateSuggestedLabelList {
    type: typeof Action.UPDATE_SUGGESTED_LABEL_LIST;
    payload: {
        labelList: string[];
    }
}

interface UpdateRejectedSuggestedLabelList {
    type: typeof Action.UPDATE_REJECTED_SUGGESTED_LABEL_LIST;
    payload: {
        labelList: string[];
    }
}

interface UpdateSSDObjectDetectorStatus {
    type: typeof Action.UPDATE_SSD_OBJECT_DETECTOR_STATUS;
    payload: {
        isSSDObjectDetectorLoaded: boolean;
    }
}

interface UpdateYOLOV5ObjectDetectorStatus {
    type: typeof Action.UPDATE_YOLO_V5_OBJECT_DETECTOR_STATUS;
    payload: {
        isYOLOV5ObjectDetectorLoaded: boolean;
    }
}

interface UpdatePoseDetectorStatus {
    type: typeof Action.UPDATE_POSE_DETECTOR_STATUS;
    payload: {
        isPoseDetectorLoaded: boolean;
    }
}

interface UpdateDisabledAIFlag {
    type: typeof Action.UPDATE_DISABLED_AI_FLAG;
    payload: {
        isAIDisabled: boolean;
    }
}

interface UpdateRoboflowAPIDetails {
    type: typeof Action.UPDATE_ROBOFLOW_API_DETAILS;
    payload: {
        roboflowAPIDetails: RoboflowAPIDetails
    }
}

export type AIActionTypes = UpdateSuggestedLabelList
    | UpdateRejectedSuggestedLabelList
    | UpdateSSDObjectDetectorStatus
    | UpdateYOLOV5ObjectDetectorStatus
    | UpdatePoseDetectorStatus
    | UpdateDisabledAIFlag
    | UpdateRoboflowAPIDetails

```

Path: src/store/notifications/actionCreators.ts
```ts
import {INotification, NotificationsActionType} from './types';
import {Action} from '../Actions';

export function submitNewNotification(notification: INotification): NotificationsActionType {
    return {
        type: Action.SUBMIT_NEW_NOTIFICATION,
        payload: {
            notification,
        },
    };
}


export function deleteNotificationById(id: string): NotificationsActionType {
    return {
        type: Action.DELETE_NOTIFICATION_BY_ID,
        payload: {
            id,
        },
    };
}

```

Path: src/store/notifications/reducer.ts
```ts
import {INotification, NotificationsActionType, NotificationsState} from './types';
import {Action} from '../Actions';

const initialState: NotificationsState = {
    queue: []
}

export function notificationsReducer(
    state = initialState,
    action: NotificationsActionType
): NotificationsState {
    switch (action.type) {
        case Action.SUBMIT_NEW_NOTIFICATION: {
            if (state.queue.length > 0 && state.queue.at(-1).type === action.payload.notification.type) {
                return state;
            } else {
                return {
                    ...state,
                    queue: [...state.queue, action.payload.notification]
                }
            }
        }
        case Action.DELETE_NOTIFICATION_BY_ID: {
            return {
                ...state,
                queue: state.queue
                    .filter((message: INotification) => message.id !== action.payload.id)
            }
        }
        default:
            return state;
    }
}

```

Path: src/store/notifications/types.ts
```ts
import {NotificationType} from '../../data/enums/NotificationType';
import {Action} from '../Actions';

export interface INotification {
    id: string,
    type: NotificationType,
    header: string,
    description: string
}

export type NotificationsState = {
    queue: INotification[]
}

interface SubmitNewNotification {
    type: typeof Action.SUBMIT_NEW_NOTIFICATION;
    payload: {
        notification: INotification;
    }
}

interface DeleteNotificationById {
    type: typeof Action.DELETE_NOTIFICATION_BY_ID;
    payload: {
        id: string;
    }
}

export type NotificationsActionType = SubmitNewNotification | DeleteNotificationById

```

Path: src/store/selectors/AISelector.ts
```ts
import {store} from '../..';
import { RoboflowAPIDetails } from '../ai/types';

export class AISelector {
    public static getSuggestedLabelList(): string[] {
        return store.getState().ai.suggestedLabelList;
    }

    public static getRejectedSuggestedLabelList(): string[] {
        return store.getState().ai.rejectedSuggestedLabelList;
    }

    public static isAISSDObjectDetectorModelLoaded(): boolean {
        return store.getState().ai.isSSDObjectDetectorLoaded;
    }

    public static isAIYOLOObjectDetectorModelLoaded(): boolean {
        return store.getState().ai.isYOLOV5ObjectDetectorLoaded;
    }

    public static isAIPoseDetectorModelLoaded(): boolean {
        return store.getState().ai.isPoseDetectorLoaded;
    }

    public static isRoboflowAPIModelLoaded(): boolean {
        const roboflowAPIDetails = store.getState().ai.roboflowAPIDetails;
        return (
            roboflowAPIDetails.model !== '' && roboflowAPIDetails.key !== '' && roboflowAPIDetails.status
        );
    }

    public static isAIDisabled(): boolean {
        return store.getState().ai.isAIDisabled;
    }

    public static getRoboflowAPIDetails(): RoboflowAPIDetails {
        return store.getState().ai.roboflowAPIDetails
    }
}

```

Path: src/store/selectors/GeneralSelector.ts
```ts
import {store} from '../..';
import {PopupWindowType} from '../../data/enums/PopupWindowType';
import {ContextType} from '../../data/enums/ContextType';
import {CustomCursorStyle} from '../../data/enums/CustomCursorStyle';
import {ProjectType} from '../../data/enums/ProjectType';

export class GeneralSelector {
    public static getActivePopupType(): PopupWindowType {
        return store.getState().general.activePopupType;
    }

    public static getActiveContext(): ContextType {
        return store.getState().general.activeContext;
    }

    public static getPreventCustomCursorStatus(): boolean {
        return store.getState().general.preventCustomCursor;
    }

    public static getImageDragModeStatus(): boolean {
        return store.getState().general.imageDragMode;
    }

    public static getCrossHairVisibleStatus(): boolean {
        return store.getState().general.crossHairVisible;
    }

    public static getCustomCursorStyle(): CustomCursorStyle {
        return store.getState().general.customCursorStyle;
    }

    public static getProjectName(): string {
        return store.getState().general.projectData.name;
    }

    public static getProjectType(): ProjectType {
        return store.getState().general.projectData.type;
    }

    public static getZoom(): number {
        return store.getState().general.zoom;
    }

    public static getEnablePerClassColorationStatus(): boolean {
        return store.getState().general.enablePerClassColoration
    }
}

```

Path: src/store/selectors/LabelsSelector.ts
```ts
import {store} from '../..';
import {ImageData, LabelLine, LabelName, LabelPoint, LabelPolygon, LabelRect} from '../labels/types';
import {find} from 'lodash';
import {LabelType} from '../../data/enums/LabelType';

export class LabelsSelector {
    public static getLabelNames(): LabelName[] {
        return store.getState().labels.labels;
    }

    public static getLabelNameById(id: string): LabelName | undefined {
        const labelName: LabelName[] = LabelsSelector.getLabelNames()
        return find(labelName, {id});
    }

    public static getActiveLabelNameId(): string {
        return store.getState().labels.activeLabelNameId;
    }

    public static getActiveLabelType(): LabelType {
        return store.getState().labels.activeLabelType;
    }

    public static getImagesData(): ImageData[] {
        return store.getState().labels.imagesData;
    }

    public static getActiveImageIndex(): number {
        return store.getState().labels.activeImageIndex;
    }

    public static getActiveImageData(): ImageData | null {
        const activeImageIndex: number | null = LabelsSelector.getActiveImageIndex();

        if (activeImageIndex === null)
            return null;

        return LabelsSelector.getImageDataByIndex(activeImageIndex);
    }

    public static getImageDataByIndex(index: number): ImageData {
        const imagesData: ImageData[] = LabelsSelector.getImagesData();
        return imagesData[index];
    }

    public static getImageDataById(id: string): ImageData {
        const imagesData: ImageData[] = LabelsSelector.getImagesData();
        return find(imagesData, {id});
    }

    public static getActiveLabelId(): string | null {
        return store.getState().labels.activeLabelId;
    }

    public static getHighlightedLabelId(): string | null {
        return store.getState().labels.highlightedLabelId;
    }

    public static getActiveRectLabel(): LabelRect | null {
        const activeLabelId: string | null = LabelsSelector.getActiveLabelId();

        if (activeLabelId === null)
            return null;

        return find(LabelsSelector.getActiveImageData().labelRects, {id: activeLabelId});
    }

    public static getActivePointLabel(): LabelPoint | null {
        const activeLabelId: string | null = LabelsSelector.getActiveLabelId();

        if (activeLabelId === null)
            return null;

        return find(LabelsSelector.getActiveImageData().labelPoints, {id: activeLabelId});
    }

    public static getActivePolygonLabel(): LabelPolygon | null {
        const activeLabelId: string | null = LabelsSelector.getActiveLabelId();

        if (activeLabelId === null)
            return null;

        return find(LabelsSelector.getActiveImageData().labelPolygons, {id: activeLabelId});
    }

    public static getActiveLineLabel(): LabelLine | null {
        const activeLabelId: string | null = LabelsSelector.getActiveLabelId();

        if (activeLabelId === null)
            return null;

        return find(LabelsSelector.getActiveImageData().labelLines, {id: activeLabelId});
    }
}

```
